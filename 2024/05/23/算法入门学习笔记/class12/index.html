<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>12动态规划 | 超级无敌大帅哥</title><meta name="author" content="chaojiwudidashuaige"><meta name="copyright" content="chaojiwudidashuaige"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态规划1.1 初探动态规划 动态规划dynamic programming是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率(重叠子问题) 在本节中，我们从一个经典例题入手，先给出暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法 问题：爬楼梯：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，请问有多少种方案">
<meta property="og:type" content="article">
<meta property="og:title" content="12动态规划">
<meta property="og:url" content="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/index.html">
<meta property="og:site_name" content="超级无敌大帅哥">
<meta property="og:description" content="动态规划1.1 初探动态规划 动态规划dynamic programming是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率(重叠子问题) 在本节中，我们从一个经典例题入手，先给出暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法 问题：爬楼梯：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，请问有多少种方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-23T11:55:27.587Z">
<meta property="article:author" content="chaojiwudidashuaige">
<meta property="article:tag" content="算法入门学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chaojiwudidashuaige","link":"链接: ","source":"来源: 超级无敌大帅哥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '12动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 19:55:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="超级无敌大帅哥"><span class="site-name">超级无敌大帅哥</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">12动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T11:55:27.587Z" title="更新于 2024-05-23 19:55:27">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="12动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-1-初探动态规划"><a href="#1-1-初探动态规划" class="headerlink" title="1.1 初探动态规划"></a>1.1 初探动态规划</h2><ol>
<li>动态规划<code>dynamic programming</code>是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率(重叠子问题)</li>
<li>在本节中，我们从一个经典例题入手，先给出暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法</li>
<li>问题：爬楼梯：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，请问有多少种方案可以爬到楼顶<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_110.png" alt="img_110.png"></li>
<li>本题的目标是求解方案数量，我们可以考虑通过回溯来穷举所有可能性。</li>
<li>将爬楼梯想象成一个多轮选择的过程：从地面出发，每轮选择上1阶或2阶，每当到达楼梯顶部时就将方案数量+1，当越过楼梯顶部时就将其剪枝<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climb</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">   ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(n,<span class="number">0</span>,ints,res);</span><br><span class="line">   <span class="keyword">return</span> res.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> state, <span class="type">int</span>[] choices, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state==n)&#123;</span><br><span class="line">      res.set(<span class="number">0</span>,res.get(<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> choice : choices) &#123;</span><br><span class="line">      <span class="keyword">if</span>(state+choice&gt;n)&#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      backTrack(n,state+choice,choices,res);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="1-1-1-方法一：暴力搜索"><a href="#1-1-1-方法一：暴力搜索" class="headerlink" title="1.1.1 方法一：暴力搜索"></a>1.1.1 方法一：暴力搜索</h3><ol>
<li>回溯算法通常并不显式地对问题进行拆解，而是将求解问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解</li>
<li>我们可以尝试从“问题分解”的角度分析这道题。设爬到第i阶共有dp[i]种方案，那么dp[i]就是原问题，其子问题包括dp[i-1],dp[i-2]…dp[2],dp[1]</li>
<li>由于每轮只能上1阶或2阶，因此当我们站在第i阶楼梯上时，上一轮只可能站在第i-1阶或第i-2阶上。换句话说，我们只能从第i-1阶或第i-2阶迈向第i阶</li>
<li>由此便可得出一个重要推论：爬到第i-1阶的方案数加上爬到第i-2阶的方案书就等于爬到第i阶的方案数<ul>
<li><code>dp[i]=dp[i-1]+dp[i-2]</code></li>
</ul>
</li>
<li>这意味着在爬楼梯问题中，各个子问题之间存在递推关系，原问题的解可以由子问题的解构建而来<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_111.png" alt="img_111.png"></li>
</ul>
</li>
<li>我们可以根据递推公式得到暴力搜索解法。以dp[n]为起始点，递归地将一个较大问题拆解为两个较小问题的和，直至到达最小子问题dp[1]和dp[2]时返回。其中，最小子问题的解是已知的，即dp[1]&#x3D;1,dp[2]&#x3D;2，表示爬到第1，2阶分别有1，2种方案<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dfs(n-<span class="number">1</span>)+dfs(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> dfs(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于问题dp[n]，其递归树的深度为n，时间复杂度为O(2^n)。指数阶属于爆炸式增长，如果我们输入一个比较大的n，则会陷入漫长的等待中<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_112.png" alt="img_112.png"></li>
</ul>
</li>
<li>观察图，<em><strong>指数阶的时间复杂度是“重叠子问题”导致的</strong></em>。<ul>
<li>例如dp[9]被分解为dp[8]和dp[7]，dp[8]被分解为dp[7]和dp[6]。两者都包含子问题dp[7]</li>
<li>以此类推，子问题中包含更小的重叠子问题。绝大部分计算资源都浪费在这些重叠的子问题上</li>
</ul>
</li>
</ol>
<h3 id="1-1-2-方法二：记忆化搜索"><a href="#1-1-2-方法二：记忆化搜索" class="headerlink" title="1.1.2 方法二：记忆化搜索"></a>1.1.2 方法二：记忆化搜索</h3><ol>
<li>为了提升算法效率，<em><strong>我们希望所有重叠的子问题都只被计算一次</strong></em>。</li>
<li>为此，我们声明一个数组mem来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝<ul>
<li>当首次计算dp[i]时，我们将其记录至mem[i]，以便之后使用</li>
<li>当再次需要计算dp[i]时，我们便可直接从mem[i]中获取结果，从而避免重复计算该子问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> dfs(n,ints);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] mem)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(mem[n]==<span class="number">0</span>)&#123;</span><br><span class="line">      mem[n]=dfs(n-<span class="number">1</span>,mem)+dfs(n-<span class="number">2</span>,mem);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mem[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至O(n)<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_113.png" alt="img_113.png"></li>
</ul>
</li>
</ol>
<h3 id="1-1-3-方法三：动态规划"><a href="#1-1-3-方法三：动态规划" class="headerlink" title="1.1.3 方法三：动态规划"></a>1.1.3 方法三：动态规划</h3><ol>
<li>记忆化搜索是一种“从顶至底”的方法：我们从原问题(根节点)开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题(叶节点)。之后，通过回溯逐层收集子问题的解，构建出原问题的解</li>
<li>与之相反，<em><strong>动态规划是一种“从底至顶”的方法</strong></em>：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解</li>
<li>由于动态规划不包含回溯过程，因此只需使用“循环迭代”实现，无须使用递归。</li>
<li>在以下代码中，我们初始化一个数组dp来存储子问题的解，它起到了与记忆化搜索中数组mem相同的记录作用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDP</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//初始化dp表，用于存储子问题的解</span></span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始状态：预设最小子问题的解</span></span><br><span class="line">   dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//状态转移：从较小子问题逐步求解(构建)较大子问题</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_114.png" alt="img_114.png"></li>
<li>与回溯算法一样，动态规划也使用“状态”概念来表示“问题求解的特定阶段”，每个状态都对应一个子问题以及相应的局部最优解。<ul>
<li>例如，爬楼梯问题的状态定义为当前所在楼梯阶数i</li>
</ul>
</li>
<li>动态规划的常用术语:<ul>
<li>将数组dp称为<code>dp表</code>,dp[i]表示“状态i对应子问题的解”</li>
<li>将最小子问题对应的状态(第1阶和第2阶楼梯)，称为<code>初始状态</code></li>
<li>将递推公式 dp[i]&#x3D;dp[i-1]+dp[i-2]称为<code>状态转移方程</code></li>
</ul>
</li>
</ol>
<h3 id="1-1-4-空间优化"><a href="#1-1-4-空间优化" class="headerlink" title="1.1.4 空间优化"></a>1.1.4 空间优化</h3><p>由于dp[i]只与dp[i-1]和dp[i-2]有关，因此我们无须使用一个数组dp来存储所有子问题的解。而只需要“两个变量滚动前进”即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDP</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=b;</span><br><span class="line">        b=a+b;</span><br><span class="line">        a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>观察以上代码，由于省去了数组dp占用的空间，因此空间复杂度从O(n)降至O(1)</li>
<li>在动态规划问题中，<em><strong>当前状态往往仅与前面有限个状态有关</strong></em>，这时我们可以<em><strong>只保留必要的状态</strong></em>，通过“降维”来节省内存空间。</li>
<li>这种空间优化技巧被称为“滚动变量”或“滚动数组”</li>
</ol>
<h2 id="1-2-动态规划问题特性"><a href="#1-2-动态规划问题特性" class="headerlink" title="1.2 动态规划问题特性"></a>1.2 动态规划问题特性</h2><ol>
<li>在上一节中，学习了动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治，动态规划，回溯中的侧重点不同<ul>
<li>分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解</li>
<li>动态规划也对原问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题</li>
<li>回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题</li>
</ul>
</li>
<li>实际上，动态规划常用来求解“最优化问题”，它们不仅包含“重叠子问题”，还具有另外两大特性：最优子结构，无后效性</li>
</ol>
<h3 id="1-2-1-最优子结构"><a href="#1-2-1-最优子结构" class="headerlink" title="1.2.1 最优子结构"></a>1.2.1 最优子结构</h3><ol>
<li>我们对爬楼梯问题稍作改动，使之更加适合展示最优子结构概念<ul>
<li>给定一个楼梯，每步可以上1阶或2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶需要付出的代价。给定一个非负整数数组cost，其中cost[i]表示在第i个台阶需要付出的代价，cost[0]为地面(起始点)。请计算最少需要付出多少代价才能到达顶部</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_115.png" alt="img_115.png"></li>
</ul>
</li>
<li>设dp[i]为爬到第i阶累计付出的代价，由于第i阶只可能从第i-1阶或第i-2阶走来。因此dp[i]只可能等于<code>dp[i-1]+cost[i]</code>或<code>dp[i-2]+cost[i]</code>。<ul>
<li>为了尽可能减少代价，我们应该选择两者中较小的那一个 <code>dp[i]=min(dp[i-1],dp[i-2])+cost[i]</code></li>
</ul>
</li>
<li>这便可以引出最优子结构的含义：<em><strong>原问题的最优解是从子问题的最优解构建而来的</strong></em></li>
<li>本题显然具有最优子结构：我们从两个子问题的最优解dp[i-1]和dp[i-2]中挑选出最优的那一个，并用它构建出原问题dp[i]的最优解<ul>
<li>那么，上一节的爬楼梯题目是否有最优子结构呢？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。</li>
<li>意外发现，虽然题目修改前后是等价的，但最优子结构浮现出来了：第n阶最大方案数量等于第n-1阶和第n-2阶最大方案数量之和。</li>
<li>最优子结构的解释方式比较灵活，在不同问题中会有不同的含义</li>
</ul>
</li>
<li>根据状态转移方程:<code>dp[i]=min(dp[i-1],dp[i-2])+cost[i]</code>，以及初始状态<code>dp[1]=cost[1]</code>和<code>dp[2]=cost[2]</code>，可以得到动态规划代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] cost,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> cost[n];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//还可以使用dp表存储从下至上的信息，</span></span><br><span class="line">   <span class="comment">// 不过本题每一个子问题只与有限个更小子问题有关，因此可以使用滚动变量</span></span><br><span class="line">   <span class="comment">//初始状态</span></span><br><span class="line">   <span class="type">int</span> a=cost[<span class="number">1</span>];</span><br><span class="line">   <span class="type">int</span> b=cost[<span class="number">2</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="type">int</span> tmp=b;</span><br><span class="line">      b=Math.min(a,b)+cost[i];<span class="comment">//状态转移方程</span></span><br><span class="line">      a=tmp;</span><br><span class="line">      <span class="comment">//滚动数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_116.png" alt="img_116.png"></li>
</ol>
<h3 id="1-2-2-无后效性"><a href="#1-2-2-无后效性" class="headerlink" title="1.2.2 无后效性"></a>1.2.2 无后效性</h3><ol>
<li>无后效性是动态规划能够有效解决问题的重要特性之一，其定义为：<em><strong>给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关</strong></em></li>
<li>以爬楼梯问题为例，给定状态i，它会发展出状态i+1和状态i+2，分别对应跳1步和跳2步。在做出这两种选择时，我们无须考虑状态i之前的状态，它们对状态i的未来没有影响</li>
<li>然而，如果我们给爬楼梯问题添加一个约束，情况就不一样了<ul>
<li>问题：给定一个共有n阶的楼梯，你每步可以上1阶或2阶，但不能连续两轮跳1阶，请问有多少中方案可以爬到楼顶</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_117.png" alt="img_117.png"></li>
</ul>
</li>
<li>在该问题中，如果上一轮是跳1阶上来的，那么下一轮就必须跳2阶。这意味着：<em><strong>下一步选择不能由当前状态(当前所在楼梯阶数)独立决定，还和前一个状态(上一轮所在楼梯阶数)有关</strong></em><ul>
<li>不难发现，此问题已不满足“无后效性”，状态转移方程dp[i]&#x3D;dp[i-1]+dp[i-2]也失效了。</li>
<li>因为dp[i-1]代表本轮跳1阶，但其中包含了许多“上一轮是跳1阶上来的”方案，而为了满足约束，我们就不能将dp[i-1]直接计入dp[i]中</li>
</ul>
</li>
<li>为此，我们需要“扩展状态定义”：状态[i,j]表示处在第i阶并且上一轮跳了j阶(j的取值范围为{1,2})。此状态定义有效区分了上一轮跳了1阶还是2阶，我们可以据此判断当前状态是从何而来的<ul>
<li>当上一轮跳了1阶时，上上一轮只能选择跳2阶，即dp[i,1]只能从dp[i-1,2]转移过来</li>
<li>当上一轮跳了2阶时，上上一轮可以选择跳1阶或2阶，即dp[i,2]可以从dp[i-2,1]或dp[i-2,2]转移过来</li>
</ul>
</li>
<li>此时的状态转移方程为：<ul>
<li><code>dp[i,1]=dp[i-1,2]</code></li>
<li><code>dp[i,2]=dp[i-2,1]+dp[i-2,2]</code></li>
</ul>
</li>
<li>最终，返回 dp[n,1]+dp[n,2]即可，两者之和代表爬到第n阶的方案总数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//状态转移方程</span></span><br><span class="line">   <span class="comment">//`dp[i,1]=dp[i-1,2]`</span></span><br><span class="line">   <span class="comment">// `dp[i,2]=dp[i-2,1]+dp[i-2,2]`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//设计dp表</span></span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">   <span class="comment">//初始化</span></span><br><span class="line">   dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   dp[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">   dp[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   dp[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">1</span>]=dp[i-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">      dp[i][<span class="number">2</span>]=dp[i-<span class="number">2</span>][<span class="number">1</span>]+dp[i-<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][<span class="number">1</span>]+dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在上面的案例中，由于“仅需多考虑前面一个状态”，因此我们仍然可以通过“扩展状态定义”(让本层的状态包含前几层的信息)，使得问题重新满足无后效性。</li>
<li>然而，某些问题具有非常严重的无后效性<ul>
<li>问题：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶。规定当爬到第i阶时，系统自动会在第2i阶上放置障碍物，之后所有轮都不允许跳到第2i阶上。例如，前两轮分别跳到了第2，3阶上，则之后就不能跳到第4，6阶上。请问有多少种方案可以爬到楼顶</li>
</ul>
</li>
<li>在这个问题中，下次跳跃依赖过去的所有状态，因为每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃。对于这类问题，动态规划往往难以解决</li>
<li>实际上，许多复杂的组合优化问题(例如旅行商问题)不满足无后效性。对于这类问题，我们通常会选择使用其他方法，例如启发式搜索，遗传算法，强化学习等，从而在有限时间内得到可用的局部最优解</li>
</ol>
<h2 id="1-3-动态规划解题思路"><a href="#1-3-动态规划解题思路" class="headerlink" title="1.3 动态规划解题思路"></a>1.3 动态规划解题思路</h2><ol>
<li>如何判断一个问题是不是动态规划问题？</li>
<li>求解动态规划问题该从何处入手，完整步骤是什么？</li>
</ol>
<h3 id="1-3-1-问题判断"><a href="#1-3-1-问题判断" class="headerlink" title="1.3.1 问题判断"></a>1.3.1 问题判断</h3><ol>
<li>总的来说，如果一个问题包含重叠子问题，最优子结构，并满足无后效性，那么它通常适合用动态规划求解。</li>
<li>然而，我们很难从问题描述中直接提取出这些特性。因此我们通常会放宽条件，先观察问题是否适合使用回溯(穷举)解决<ul>
<li>适合用回溯解决的问题通常满足“决策树模型”，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列</li>
<li>换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决</li>
</ul>
</li>
<li>在此基础上，动态规划问题还有一些判断的“加分项”<ul>
<li>问题包含最大(小)或最多(少)等最优化描述</li>
<li>问题的状态能够使用一个列表，多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系</li>
</ul>
</li>
<li>相应地，也存在一些“减分项”<ul>
<li>问题的目标是找出所有可能的解决方案，而不是找出最优解</li>
<li>问题描述中有明显的排列组合的特征，需要返回具体的多个方案</li>
</ul>
</li>
<li>如果一个问题满足决策树模型，并具有较为明显的“加分项”，我们就可以假设它是一个动态规划问题，并在求解过程中验证它</li>
</ol>
<h3 id="1-3-2-问题求解步骤"><a href="#1-3-2-问题求解步骤" class="headerlink" title="1.3.2 问题求解步骤"></a>1.3.2 问题求解步骤</h3><ol>
<li>动态规划的解题流程：<code>描述决策，定义状态，建立dp表，推导状态转移方程，确定边界条件</code></li>
<li>例题：最小路径和<ul>
<li>给定一个n*m的二维网格grid，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_118.png" alt="img_118.png"></li>
</ul>
</li>
<li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul>
<li>本题每一轮的决策就是从当前格子向下或向右走一步。设当前格子的行列索引为(i,j)，则向下或向右走一步后，索引变为(i+1,j)或(i,j+1)。因此，状态应包含行索引和列索引两个变量，记为(i,j)</li>
<li>状态(i,j)对应的子问题为：从起始点(0,0)走到(i,j)的最小路径和，解记为dp[i,j]</li>
<li>由此得到二维dp矩阵<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_119.png" alt="img_119.png"></li>
</ul>
</li>
</ul>
</li>
<li>Note：动态规划和回溯过程可以描述为一个“决策序列”，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态<ul>
<li>每个状态都对应一个子问题，我们会定义一个dp表来“存储所有子问题的解”，状态的每个独立变量都是dp表的一个维度。从本质上看<code>dp表是状态和子问题的解之间的映射</code></li>
</ul>
</li>
<li>第二步：找出最优子结构，进而推导出状态转移方程<ul>
<li>对于状态(i,j)，它只能从上边格子(i-1,j)和左边格子(i,j-1)转移而来。因此最优子结构为：到达(i,j)的最小路径和 由到达(i,j-1)的最小路径和与到达(i-1,j)的最小路径和中较小的那一个决定</li>
<li>由此可得状态转移方程<code>dp[i,j]=min(dp[i-1,j],dp[i,j-1])+grid[i,j]</code></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_120.png" alt="img_120.png"></li>
</ul>
</li>
<li>Note：根据定义好的dp表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构<ul>
<li>一旦我们找到了最优子结构，就可以使用它来构建状态转移方程</li>
</ul>
</li>
<li>第三步：确定边界条件和状态转移顺序<ul>
<li>在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此，首行i&#x3D;0和首列j&#x3D;0是边界条件</li>
<li>由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_121.png" alt="img_121.png"></li>
</ul>
</li>
<li>Note：边界条件在动态规划中用于“初始化dp表”，在搜索中用于剪枝<ul>
<li>状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确的计算出来</li>
</ul>
</li>
</ol>
<h4 id="1-3-2-1-方法一：暴力搜索"><a href="#1-3-2-1-方法一：暴力搜索" class="headerlink" title="1.3.2.1 方法一：暴力搜索"></a>1.3.2.1 方法一：暴力搜索</h4><p>从状态(i,j)开始搜索，不断分解为更小的状态(i-1,j)和(i,j-1)，递归函数包括以下要素</p>
<ol>
<li>递归参数：状态i,j</li>
<li>返回值：从(0,0)到(i,j)的最小路径和(dp[i,j])</li>
<li>终止条件：当i&#x3D;0且j&#x3D;0时返回代价grid[0,0]</li>
<li>剪枝：当i&lt;0或j&lt;0时索引越界，返回代价maxvalue，代表不可行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPath</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="comment">//若为左上角单元格，则终止搜索，因为它为“初始状态”</span></span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果越界，那么就返回无穷大代价(因为是去最小值，就相当于舍去这种情况)</span></span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> left=minPath(grid,i,j-<span class="number">1</span>);</span><br><span class="line">   <span class="type">int</span> up=minPath(grid,i-<span class="number">1</span>,j);</span><br><span class="line">   <span class="comment">//&quot;状态转移方程&quot;</span></span><br><span class="line">   <span class="keyword">return</span> Math.min(up,left)+grid[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_122.png" alt="img_122.png"><ul>
<li>该方法包含了一些“重叠子问题”，其数量会随着网格grid的尺寸变大而急剧增多</li>
<li>从本质上看，造成重叠子问题的原因为：存在多条路径可以从左上角到达某一单元格</li>
</ul>
</li>
<li>每个状态都有向下和向右两种选择，从左上角走到右下角总共需要m+n-2步，所以最差时间复杂度为O(2^(m+n))。<ul>
<li>请注意，这种计算方式未考虑临近网格边界的情况，当到达网格边界时只剩下一种选择，因此实际的路径数量会少一些</li>
</ul>
</li>
</ol>
<h4 id="1-3-2-2-方法二：记忆化搜索"><a href="#1-3-2-2-方法二：记忆化搜索" class="headerlink" title="1.3.2.2 方法二：记忆化搜索"></a>1.3.2.2 方法二：记忆化搜索</h4><p>引入一个和网格grid相同尺寸的记忆列表mem，用于记录各个子问题的解，并将重叠子问题进行剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathMem</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span>[][] mem,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> grid[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若已有记录，则直接返回(剪枝)</span></span><br><span class="line">   <span class="keyword">if</span>(mem[i][j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mem[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> left=minPathMem(grid, mem, i, j-<span class="number">1</span>);</span><br><span class="line">   <span class="type">int</span> up=minPathMem(grid, mem, i-<span class="number">1</span>, j);</span><br><span class="line">   <span class="comment">//记录并返回</span></span><br><span class="line">   mem[i][j]=Math.min(left,up)+grid[i][j];</span><br><span class="line">   <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决与状态总数，即网格尺寸O(mn)</p>
<h4 id="1-3-2-3-方法三：动态规划"><a href="#1-3-2-3-方法三：动态规划" class="headerlink" title="1.3.2.3 方法三：动态规划"></a>1.3.2.3 方法三：动态规划</h4><p>基于迭代实现动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathDP</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m= grid.length;</span><br><span class="line">   <span class="type">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">   <span class="comment">//初始化dp表</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;m;x++)&#123;</span><br><span class="line">      dp[x][<span class="number">0</span>]=dp[x-<span class="number">1</span>][<span class="number">0</span>]+grid[x][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;n;x++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][x]=dp[<span class="number">0</span>][x-<span class="number">1</span>]+grid[<span class="number">0</span>][x];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//状态转移，其余行列</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;m;x++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;n;y++)&#123;</span><br><span class="line">         dp[x][y]=Math.min(dp[x-<span class="number">1</span>][y],dp[x][y-<span class="number">1</span>])+grid[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>遍历了整个网格，时间复杂度为O(mn)</li>
<li>数组dp大小为nm，因此空间复杂度为O(mn)</li>
</ol>
<h4 id="1-3-2-4-空间优化"><a href="#1-3-2-4-空间优化" class="headerlink" title="1.3.2.4 空间优化"></a>1.3.2.4 空间优化</h4><ol>
<li>由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现dp表</li>
<li>因为数组dp只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathDPComp</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m= grid.length;</span><br><span class="line">   <span class="type">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">   dp[<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">      dp[i]=dp[i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="comment">//状态转移：首列</span></span><br><span class="line">      dp[<span class="number">0</span>]=grid[i][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">         dp[j]=Math.min(dp[j-<span class="number">1</span>],dp[j])+grid[i][j];</span><br><span class="line">         <span class="comment">//dp[j-1]表示左边格子，dp[i]表示上边格子</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-4-0-1背包问题"><a href="#1-4-0-1背包问题" class="headerlink" title="1.4 0-1背包问题"></a>1.4 0-1背包问题</h2><ol>
<li>例题：给定n个物品，第i个物品的重量为wgt[i-1],价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_123.png" alt="img_123.png"><ul>
<li>由于物品编号i从1开始计数，数组索引从0开始计数，因此物品i对应重量wgt[i-1]和价值val[i-1]</li>
</ul>
</li>
<li>我们可以将0-1背包问题看作一个由n轮决策组成的过程，对于每个物体都有放入和不放入两种决策，因此该问题满足决策树模型</li>
<li>该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题</li>
<li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul>
<li>对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减少。由此可得状态定义：当前物品编号i和剩余背包容量c，记为[i,c]</li>
<li>状态[i,c]对应的子问题为：前i个物品在剩余容量为c的背包中的最大价值，记为dp[i,c]</li>
<li>待求解的是dp[n,cap]，因此需要一个尺寸为(n+1)*(cap+1)的二维dp表</li>
</ul>
</li>
<li>第二步：找出最优子结构，进而推导出状态转移方程<ul>
<li>当我们做出物品i的决策后，剩余的是前i-1个物品的决策，可分为以下两种情况<ul>
<li>不放入物品i：背包容量不变，状态变化为[i-1,c]</li>
<li>放入物品i：背包容量减少wgt[i-1],价值增加val[i-1]，状态变化为[i-1,c-wgt[i-1]]</li>
</ul>
</li>
<li>上述分析向我们揭示了本题的最优子结构：最大价值dp[i,c]等于不放入物品i和放入物品i两种方案中价值更大的那一个<ul>
<li>状态转移方程:<code>dp[i,c]=max(dp[i-1,c],dp[i-1,c-wgt[i-1]]+val[i-1])</code><ul>
<li>如果没放入i：说明[i,c]处的val等于[i-1,c]处的val</li>
<li>如果放入i：说明[i,c]处的val等于[i-1,c-wgt[i-1]]处的val再加上i的val<ul>
<li>dp[i-1,c-wgt[i-1]]:前i-1个物品在剩余容量为“c-wgt[i-1]”的情况下所占的最大价值(wgt[i-1]的容量被i占了)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>确定边界条件和状态转移顺序：<ul>
<li>当无物品或无剩余背包容量时最大价值为0，即首列dp[i,0]和首行dp[0,c]都等于0</li>
<li>当前状态[i,c]由上方的状态[i-1,c]和左上方的状态[i-1,c-wgt[i-1]]转移而来，因此通过两层循环正序遍历整个dp表即可</li>
</ul>
</li>
</ol>
<h3 id="1-4-1-方法一：暴力搜索"><a href="#1-4-1-方法一：暴力搜索" class="headerlink" title="1.4.1 方法一：暴力搜索"></a>1.4.1 方法一：暴力搜索</h3><ol>
<li>递归参数：状态i，c</li>
<li>返回值：子问题的解dp[i,c]</li>
<li>终止条件：当物品编号越界i&#x3D;0或背包剩余容量为0时，终止递归并返回价值0(边界条件的值)</li>
<li>剪枝：若当前物品重量超出背包剩余容量，则只能选择不放入背包<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span> i,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>||c==<span class="number">0</span>)&#123;<span class="comment">//边界情况</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(wgt[i-<span class="number">1</span>]&gt;c)&#123;</span><br><span class="line">      <span class="keyword">return</span> knapsackDFS(wgt, val, i-<span class="number">1</span>, c);<span class="comment">//只能选择不放入</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> no=knapsackDFS(wgt, val, i-<span class="number">1</span>, c);</span><br><span class="line">   <span class="type">int</span> yes=knapsackDFS(wgt,val,i-<span class="number">1</span>,c-wgt[i-<span class="number">1</span>])+val[i-<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> Math.max(no,yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_124.png" alt="img_124.png"></li>
</ol>
<ul>
<li>由于每个物品都会产生选和不选两条搜索分支，因此时间复杂度为O(2^n)</li>
<li>观察递归树，容易发现其中存在重叠子问题，例如dp[1,10]等。而当物品较多，背包容量较大时，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多</li>
</ul>
<h3 id="1-4-2-记忆化搜索"><a href="#1-4-2-记忆化搜索" class="headerlink" title="1.4.2 记忆化搜索"></a>1.4.2 记忆化搜索</h3><ol>
<li>为了保证重叠子问题只被计算一次，我们借助记忆列表mem来记录子问题的解，其中mem[i,c]对应dp[i,c]</li>
<li>引入记忆化后，时间复杂度取决于子问题数量，也就是O(n*cap)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDFSMem</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span>[][] mem,<span class="type">int</span> i,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>||c==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若已有记录，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span>(mem[i][c]!=-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mem[i][c];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(wgt[i-<span class="number">1</span>]&gt;c)&#123;</span><br><span class="line">      <span class="keyword">return</span> knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> no=knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c);</span><br><span class="line">   <span class="type">int</span> yes=knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c-wgt[i-<span class="number">1</span>])+val[i-<span class="number">1</span>];</span><br><span class="line">   mem[i][c]=Math.max(no,yes);</span><br><span class="line">   <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_125.png" alt="img_125.png"></li>
</ol>
<h3 id="1-4-3-方法三：动态规划"><a href="#1-4-3-方法三：动态规划" class="headerlink" title="1.4.3 方法三：动态规划"></a>1.4.3 方法三：动态规划</h3><p>动态规划实质上就是在状态转移中填充dp表的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDP</span><span class="params">(<span class="type">int</span>[] val,<span class="type">int</span>[] wgt,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n= val.length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//默认初始化第一列和第一行都为0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(wgt[i]&gt;c)&#123;<span class="comment">//不选</span></span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-wgt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度和空间复杂度都有数组dp大小决定，即O(n*cap)</p>
<h3 id="1-4-4-空间优化"><a href="#1-4-4-空间优化" class="headerlink" title="1.4.4 空间优化"></a>1.4.4 空间优化</h3><ol>
<li>由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从O(n^2)降至O(n)</li>
<li>进一步思考，能否仅用一个数组实现空间优化。每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第i行时，该数组存储的仍然是第i-1行的状态<ul>
<li>如果采取正序遍历，那么遍历到dp[i,j]时，左上方dp[i-1,1]~dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果</li>
<li>如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] val,<span class="type">int</span>[] wgt,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=val.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[c + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(wgt[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j-wgt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>],dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="1-5-完全背包问题"><a href="#1-5-完全背包问题" class="headerlink" title="1.5 完全背包问题"></a>1.5 完全背包问题</h2><h3 id="1-5-1-完全背包问题"><a href="#1-5-1-完全背包问题" class="headerlink" title="1.5.1 完全背包问题"></a>1.5.1 完全背包问题</h3><p>例题：给定n个物品，第i个物品的重量为wgt[i-1]，价值为val[i-1]，和一个容量为cap的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_126.png" alt="img_126.png"></li>
</ul>
<h4 id="1-5-1-1-动态规划思路"><a href="#1-5-1-1-动态规划思路" class="headerlink" title="1.5.1.1 动态规划思路"></a>1.5.1.1 动态规划思路</h4><ol>
<li>完全背包问题和0-1背包问题非常相似，区别在于不限制物品的选择次数<ul>
<li>在0-1背包问题中，每种物品只有一个，因此将物品i放入背包后，只能从前i-1个物品中选择</li>
<li>在完全背包问题中，每种物品的数量是无限的，因此将物品i放入背包后，仍可以从前i个物品中选择</li>
</ul>
</li>
<li>在完全背包问题的规定下，状态[i,c]的变化分为两种情况<ul>
<li>不放入物品：与0-1背包问题相同，转移至[i-1,c]</li>
<li>放入物品，与0-1背包问题不同，转移至[i,c-wgt[i-1]]</li>
</ul>
</li>
<li>从而状态转移方程变为:<code>dp[i,c]=max(dp[i-1,c],dp[i,c-wgt[i-1]]+val[i-1])</code></li>
</ol>
<h4 id="1-5-1-2-代码实现"><a href="#1-5-1-2-代码实现" class="headerlink" title="1.5.1.2 代码实现"></a>1.5.1.2 代码实现</h4><p>只有状态转移方程有些许不一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDP</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">   <span class="comment">// 初始化 dp 表</span></span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][cap + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">// 状态转移</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">            dp[i][c] = Math.max(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-1-3-空间优化"><a href="#1-5-1-3-空间优化" class="headerlink" title="1.5.1.3 空间优化"></a>1.5.1.3 空间优化</h4><ol>
<li>由于当前状态是从左边和上边的状态转移而来的，因此空间优化后应该对dp表中的每一行进行正序遍历</li>
<li>这个遍历顺序与0-1背包正好相反(因为0-1背包问题的当前状态是从左上方和上方的状态转移而来的)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">   <span class="comment">// 初始化 dp 表</span></span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">// 状态转移</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            dp[c] = dp[c];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">            dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-5-2-零钱兑换问题"><a href="#1-5-2-零钱兑换问题" class="headerlink" title="1.5.2 零钱兑换问题"></a>1.5.2 零钱兑换问题</h3><p>例题：给定n种硬币，第i中硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，返回-1</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_127.png" alt="img_127.png"></li>
</ul>
<h4 id="1-5-2-1-动态规划思路"><a href="#1-5-2-1-动态规划思路" class="headerlink" title="1.5.2.1 动态规划思路"></a>1.5.2.1 动态规划思路</h4><ol>
<li>零钱兑换可以看作完全背包问题的一种特殊情况，两者具有以下联系和不同点<ul>
<li>两道题可以相互转换，“物品”对应“硬币”，“物品重量”对应“硬币面值”，“背包容量”对应“目标金额”</li>
<li>优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量</li>
<li>完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解</li>
</ul>
</li>
<li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul>
<li>状态[i,a]对应的子问题为：前i种硬币能够凑出金额a的最少硬币数量，记为dp[i,a]</li>
<li>二维dp表的尺寸为(n+1)*(amt+1)</li>
</ul>
</li>
<li>第二步：找出最优子结构，进而推导出状态转移方程<ul>
<li>本题与完全背包问题的状态转移方程存在以下两点差异<ul>
<li>本题要求最小值，因此需要min()</li>
<li>优化主体是硬币数量而非商品价值，因此在选中硬币时执行+1即可</li>
</ul>
</li>
<li>状态转移方程：<code>dp[i,a]=min(dp[i-1,a],dp[i,a-coins[i-1]]+1)</code></li>
</ul>
</li>
<li>第三步：确定边界条件和状态转移顺序<ul>
<li>当目标金额为0时，凑出它的最少硬币数量为0，即首列所有dp[i,0]都等于0</li>
<li>当无硬币时，无法凑出任意&gt;0的目标金额，即是无效解。为使状态转移方程中的min()函数能够识别并过滤无效解，我们考虑使用+∞来表示它们，即令首行所有dp[0,a]都等于+∞</li>
</ul>
</li>
</ol>
<h4 id="1-5-2-2-代码实现"><a href="#1-5-2-2-代码实现" class="headerlink" title="1.5.2.2 代码实现"></a>1.5.2.2 代码实现</h4><ol>
<li>大多数编程语言并未提供+∞变量，只能使用整型int的最大值来代替。而这样又会导致大数越界：状态转移方程中的+1操作可能发生溢出</li>
<li>为此，我们采用数字amt+1来表示无效解，因为凑出amt的硬币数量最多为amt。最后返回前，判断dp[n,amt]是否等于amt+1，若是则返回-1，代表无法凑出目标金额(如果无法凑出目标金额，即表示会存在子问题的a小于任意的coins[i]，导致其值等于dp[i&#x3D;0,a])<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeDP</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span> MAX=amt+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始化dp表</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amt;i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i]=MAX;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][amt]==MAX?-<span class="number">1</span>:dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-5-2-3-空间优化"><a href="#1-5-2-3-空间优化" class="headerlink" title="1.5.2.3 空间优化"></a>1.5.2.3 空间优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeDPComp</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span> MAX=amt+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amt;i++)&#123;</span><br><span class="line">      dp[i]=MAX;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!(coins[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">            dp[j]=Math.min(dp[j],dp[j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[amt]==MAX?-<span class="number">1</span>:dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-3-零钱兑换问题II"><a href="#1-5-3-零钱兑换问题II" class="headerlink" title="1.5.3 零钱兑换问题II"></a>1.5.3 零钱兑换问题II</h3><p>例题：给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问凑出目标金额的硬币组合数量—&gt;最大组合数量</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_128.png" alt="img_128.png"></li>
</ul>
<h4 id="1-5-3-1-动态规划思路"><a href="#1-5-3-1-动态规划思路" class="headerlink" title="1.5.3.1 动态规划思路"></a>1.5.3.1 动态规划思路</h4><ol>
<li>子问题为：前i种硬币能够凑出金额a的(最大)组合数量。dp表为(n+1)*(amt+1)的二维矩阵</li>
<li>当前状态的组合数量等于“不选当前硬币”与“选当前硬币”这两种决策的组合数量之和。状态转移方程为：<ul>
<li><code>dp[i,a]=dp[i-1,a]+dp[i,a-coins[i-1]]</code></li>
</ul>
</li>
<li>当目标金额为0时，无须选择任何硬币即可凑出目标金额，因此应将首列所有dp[i,0]都初始化为1.当无硬币时，无法凑出任何&gt;0的目标金额，因此首行所有dp[0,a]都等于0</li>
</ol>
<h4 id="1-5-3-2-代码实现"><a href="#1-5-3-2-代码实现" class="headerlink" title="1.5.3.2 代码实现"></a>1.5.3.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-3-3-代码优化"><a href="#1-5-3-3-代码优化" class="headerlink" title="1.5.3.3 代码优化"></a>1.5.3.3 代码优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">   dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!(coins[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">            dp[j]=dp[j]+dp[j-coins[i-<span class="number">1</span>]];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-编辑距离问题"><a href="#1-6-编辑距离问题" class="headerlink" title="1.6 编辑距离问题"></a>1.6 编辑距离问题</h2><ol>
<li>编辑距离，也称“Levenshtein”距离，指“两个字符串之间互相转换的最少修改次数”，通常用于在信息检索和自然语言处理中度量两个序列的相似度</li>
<li>例题：输入两个字符串s和t，返回将s转换为t所需要的最少编辑步数<ul>
<li>你可以在一个字符串中进行三种编辑操作：插入一个字符，删除一个字符，将字符替换为任意一个字符</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_129.png" alt="img_129.png"></li>
</ul>
</li>
<li>编辑距离问题可以很自然的用决策树模型来解释。字符串对应树节点，一轮决策(一轮编辑操作)对应树的一条边</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_130.png" alt="img_130.png"><ul>
<li>在不限制操作的情况下，每个节点都可以派生出许多条边，每条边对应一种操作，这意味着从hello转换到algo有许多种可能的路径</li>
<li>从决策树的角度看，本题的目标是求解节点hello和节点algo之间的最短路径</li>
</ul>
</li>
</ol>
<h3 id="1-6-1-动态规划思路"><a href="#1-6-1-动态规划思路" class="headerlink" title="1.6.1 动态规划思路"></a>1.6.1 动态规划思路</h3><ol>
<li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul>
<li>每一轮的决策是对字符串s进行一次编辑操作</li>
<li>我们希望在编辑操作的过程中，问题的规模逐渐缩小，这样才能构建子问题。设字符串s和t的长度分别为n和m，我们先考虑两字符串尾部的字符s[n-1]和t[m-1]<ul>
<li>若s[n-1]和t[m-1]相同，我们可以跳过它们，直接考虑s[n-2]和t[m-2]</li>
<li>若s[n-1]和t[m-1]不同，我们需要对s进行一次编辑(插入，删除，替换)，使得两字符串尾部的字符相同，从而可以跳过它们，考虑规模更小的问题</li>
</ul>
</li>
<li>也就是说，我们在字符串中进行的每一轮决策(编辑操作)，都会使得s和t中剩余的待匹配字符发生变化。因此，状态为 当前在s和t中考虑的第i和第j个字符，记为[i,j]</li>
<li>状态[i,j]对应的子问题：将s的前i个字符更改为t的前j个字符所需要的最少编辑步数</li>
<li>至此，得到一个(n+1)*(m+1)的二维dp表</li>
</ul>
</li>
<li>找出最优子结构，进而推导出状态转移方程<ul>
<li>考虑子问题dp[i,j]，其对应的两个字符串的尾部字符为s[i-1]和t[j-1]，可根据不同编辑操作分为三种情况</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_131.png" alt="img_131.png"><ul>
<li>在s[i-1]之后添加t[j-1]，则剩余子问题dp[i,j-1] (i不动，j前移)</li>
<li>删除s[i-1],则剩余子问题dp[i-1,j] (j不动，i前移)</li>
<li>将s[i-1]替换为t[j-1]，则剩余子问题dp[i-1,j-1] (i,j都前移)</li>
</ul>
</li>
<li>根据以上分析可得最优子结构：dp[i,j]的最少编辑步数等于dp[i-1,j],dp[i,j-1],dp[i-1,j-1]三者中的最少编辑步数，再加上本次的编辑步数1<ul>
<li>对应的状态转移方程为<code>dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</code></li>
</ul>
</li>
<li>请注意，当s[i-1]和t[j-1]相同时，无须编辑当前字符，这种状态下的状态转移方程为<ul>
<li><code>dp[i,j]=dp[i-1,j-1]</code></li>
</ul>
</li>
</ul>
</li>
<li>确定边界条件和状态转移顺序<ul>
<li>当两字符串都为空时，编辑步数为0，即dp[0,0]&#x3D;0。</li>
<li>当s为空但t不为空时，最少编辑步数等于t的长度，即首行dp[0,j]&#x3D;j。</li>
<li>当s不为空但是t为空时，最少编辑步数等于s的长度，即首列dp[i,0]&#x3D;i</li>
<li>观察状态转移方程，解dp[i,j]依赖左方，上方，左上方的解，因此通过两层循环正序遍历整个dp表即可</li>
</ul>
</li>
</ol>
<h3 id="1-6-2-代码实现"><a href="#1-6-2-代码实现" class="headerlink" title="1.6.2 代码实现"></a>1.6.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistanceDP</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=s.length();</span><br><span class="line">   <span class="type">int</span> m=t.length();</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]),dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-3-空间优化"><a href="#1-6-3-空间优化" class="headerlink" title="1.6.3 空间优化"></a>1.6.3 空间优化</h3><ol>
<li>由于dp[i,j]是由上方dp[i-1,j]，左方dp[i,j-1]，左上方dp[i-1,j-1]转移而来的，而正序遍历会丢失左上方dp[i-1,j-1]。倒序遍历无法提前构建dp[i,j-1]，因此两种遍历顺序都不可取</li>
<li>为此，我们可以使用一个变量leftup来暂存左上方的解dp[i-1,j-1]，从而只需考虑左方和上方的解。此时可使用正序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistanceDPComp</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m=t.length();</span><br><span class="line">   <span class="type">int</span> n=s.length();</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      dp[i]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="type">int</span> leftup=dp[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">0</span>]=i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">         <span class="type">int</span> temp=dp[j];<span class="comment">//dp[j]会被覆盖掉</span></span><br><span class="line">         <span class="keyword">if</span>(!(s.charAt(i)==t.charAt(j)))&#123;</span><br><span class="line">            dp[j]=Math.min(Math.min(dp[j],dp[j-<span class="number">1</span>]),leftup)+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[j]=leftup;</span><br><span class="line">         &#125;</span><br><span class="line">         leftup=temp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-7-小结："><a href="#1-7-小结：" class="headerlink" title="1.7 小结："></a>1.7 小结：</h2><ol>
<li>动态规划对问题进行分解，并通过存储子问题的解来规避重复计算，提高计算效率</li>
<li>不考虑时间的前提下，所有动态规划问题都可以用回溯(暴力搜索)进行求解，但递归树中存在大量的重叠子问题，效率极低。通过引入记忆化列表，可以存储所有计算过的子问题，从而保证重叠子问题只被计算一次</li>
<li>记忆化搜索时一种从顶至底的递归式解法，而与之对应的动态规划是一种从底至顶的递推式解法，其如同“填写表格”一样。由于当前状态仅依赖某些局部状态，因此我们可以消除dp表的一个维度，从而降低空间复杂度</li>
<li>子问题分解是一种通用的算法思路，在分治，动态规划，回溯中具有不同的性质</li>
<li>动态规划问题有三大特性：重叠子问题，最优子结构，无后效性</li>
<li>如果原问题的最优解可以从子问题的最优解构建得来，则它就具有最优子结构</li>
<li>无后效性指对于一个状态，其未来发展只与该状态有关，而与过去的所有状态无关。许多组合优化问题不具有无后效性，无法使用动态规划快速求解</li>
</ol>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ol>
<li>背包问题是最典型的动态规划问题之一，具有0-1背包，完全背包，多重背包等变种</li>
<li>0-1背包问题的状态定义为 前i个物品在剩余容量为c的背包中的最大价值。根据不放入背包和放入背包两种决策，可得到最优子结构，并构建出状态转移方程。在空间优化中，由于每个状态依赖正上方和左上方的状态，因此需要倒序遍历列表，避免左上方状态被覆盖</li>
<li>完全背包问题的每种物品的选取数量无限制，因此选择放入物品的状态转移与0-1背包问题不同。由于状态依赖与正上方状态和正左方状态，因此在空间优化中应当正序遍历</li>
<li>零钱兑换问题是完全背包问题的一个变种。它从求“最大”价值变为求“最小”硬币数量，因此状态转移方程中的max()应改为min()。从追求“不超过”背包容量到追求“恰好”凑出目标金额，因此使用amt+1来表示“无法凑出目标金额”的无效解</li>
<li>零钱兑换问题II从求“最少硬币数量”改为求“最大硬币组合数量”，状态转移方程相应地从min()改为求和运算符</li>
</ol>
<h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><ol>
<li>编辑距离(Levenshtein距离)用于衡量两个字符串之间的相似度，其定义为从一个字符串到另一个字符串的最少编辑步数。编辑操作包括 添加，删除，替换</li>
<li>编辑距离问题的状态定义为将s的前i个字符更改为t的前j个字符所需的最少编辑步数。当s[i]!&#x3D;t[j]时，具有三种决策：添加，删除，替换，它们都有相应的剩余子问题。据此便可以找出最优子结构与构建状态转移方程。而当s[i]&#x3D;t[j]时，无须编辑当前字符</li>
<li>在编辑距离中，状态依赖其正上方，正左方，左上方的状态，因此空间优化后正序或倒序遍历都无法正确的进行状态转移。为此，我们使用一个变量暂存左上方状态，从而转化到与完全背包问题等价的情况，可以在空间优化后进行正序遍历</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io">chaojiwudidashuaige</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/">https://chaojiwudidashuaige492.github.io/2024/05/23/算法入门学习笔记/class12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaojiwudidashuaige492.github.io" target="_blank">超级无敌大帅哥</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法入门学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class6/" title="06堆"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">06堆</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/" title="13贪心算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">13贪心算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/" title="03栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">03栈与队列</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/" title="01数据的结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">01数据的结构</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">02数组与链表</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/" title="05二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">05二叉树</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">10分治算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/" title="11回溯算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">11回溯算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chaojiwudidashuaige</div><div class="author-info__description">Plan first,Then code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chaojiwudidashuaige492" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaojiwudidashuaige492@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">1.1 初探动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2"><span class="toc-text">1.1.1 方法一：暴力搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">1.1.2 方法二：记忆化搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">1.1.3 方法三：动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.1.4 空间优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 动态规划问题特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">1.2.1 最优子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7"><span class="toc-text">1.2.2 无后效性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">1.3 动态规划解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E9%97%AE%E9%A2%98%E5%88%A4%E6%96%AD"><span class="toc-text">1.3.1 问题判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.3.2 问题求解步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2"><span class="toc-text">1.3.2.1 方法一：暴力搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-2-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">1.3.2.2 方法二：记忆化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-3-%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">1.3.2.3 方法三：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-4-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.3.2.4 空间优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.4 0-1背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2"><span class="toc-text">1.4.1 方法一：暴力搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">1.4.2 记忆化搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">1.4.3 方法三：动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.4.4 空间优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.5 完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.5.1 完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="toc-text">1.5.1.1 动态规划思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.5.1.2 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-3-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.5.1.3 空间优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-text">1.5.2 零钱兑换问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="toc-text">1.5.2.1 动态规划思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.5.2.2 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-3-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.5.2.3 空间优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98II"><span class="toc-text">1.5.3 零钱兑换问题II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="toc-text">1.5.3.1 动态规划思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.5.3.2 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-3-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-text">1.5.3.3 代码优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-text">1.6 编辑距离问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF"><span class="toc-text">1.6.1 动态规划思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.6.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">1.6.3 空间优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">1.7 小结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-text">编辑距离问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/t/" title="t">t</a><time datetime="2024-05-23T10:28:39.000Z" title="发表于 2024-05-23 18:28:39">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/" title="01Git概念">01Git概念</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/" title="02GitHubDesktop">02GitHubDesktop</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/" title="03IDEA集成GitHub">03IDEA集成GitHub</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/" title="05Git命令">05Git命令</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By chaojiwudidashuaige</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>