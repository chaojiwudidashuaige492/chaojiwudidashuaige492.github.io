<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>13贪心算法 | 超级无敌大帅哥</title><meta name="author" content="chaojiwudidashuaige"><meta name="copyright" content="chaojiwudidashuaige"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="贪心1.1 贪心算法 贪心算法greedy algorithm是一种常见的解决优化问题的算法 其“基本思想”是：在问题的每个决策阶段，都选择“当前看起来最优的选择” 即贪心的做出“局部最优的决策”，以期获得全局最优解   贪心算法简洁而高效，在许多实际问题中有着广泛的应用 贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同 动态规划会根据之前">
<meta property="og:type" content="article">
<meta property="og:title" content="13贪心算法">
<meta property="og:url" content="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/index.html">
<meta property="og:site_name" content="超级无敌大帅哥">
<meta property="og:description" content="贪心1.1 贪心算法 贪心算法greedy algorithm是一种常见的解决优化问题的算法 其“基本思想”是：在问题的每个决策阶段，都选择“当前看起来最优的选择” 即贪心的做出“局部最优的决策”，以期获得全局最优解   贪心算法简洁而高效，在许多实际问题中有着广泛的应用 贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同 动态规划会根据之前">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-23T11:55:27.582Z">
<meta property="article:author" content="chaojiwudidashuaige">
<meta property="article:tag" content="算法入门学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chaojiwudidashuaige","link":"链接: ","source":"来源: 超级无敌大帅哥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '13贪心算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 19:55:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="超级无敌大帅哥"><span class="site-name">超级无敌大帅哥</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">13贪心算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T11:55:27.582Z" title="更新于 2024-05-23 19:55:27">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="13贪心算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="1-1-贪心算法"><a href="#1-1-贪心算法" class="headerlink" title="1.1 贪心算法"></a>1.1 贪心算法</h2><ol>
<li>贪心算法<code>greedy algorithm</code>是一种常见的解决优化问题的算法</li>
<li>其“基本思想”是：在问题的每个决策阶段，都选择“当前看起来最优的选择”<ul>
<li>即贪心的做出“局部最优的决策”，以期获得全局最优解</li>
</ul>
</li>
<li>贪心算法简洁而高效，在许多实际问题中有着广泛的应用</li>
<li>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同<ul>
<li>动态规划会根据之前阶段的所有决策(的结果)来考虑当前决策，并使用过去子问题的解来构建当前子问题的解</li>
<li>贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决</li>
</ul>
</li>
<li>先通过例题“零钱兑换”了解贪心算法的工作原理<ul>
<li>例题：给定n种硬币，第i中硬币的面值为coins[i-1],目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回-1</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_132.png" alt="img_132.png"><ul>
<li>给定目标金额，我们贪心地选择不大于且最接近它的硬币(局部最优)，不断循环该步骤，直至凑出目标金额为止<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeGreedy</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(amt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i]&lt;amt&amp;&amp;coins[i]&gt;max)&#123;</span><br><span class="line">            max=coins[i];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      amt-=max;</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> amt==<span class="number">0</span>?count:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-1-1-贪心算法的优点和局限性"><a href="#1-1-1-贪心算法的优点和局限性" class="headerlink" title="1.1.1 贪心算法的优点和局限性"></a>1.1.1 贪心算法的优点和局限性</h3><ol>
<li>贪心算法不仅操作直接，实现简单，而且通常效率也很高<ul>
<li>在以上代码中，记硬币最小面值为min(coins)，则贪心选择最多循环 amt&#x2F;min(coins)次，时间复杂度为O(amt&#x2F;min(coins))。</li>
<li>这比动态规划解法的时间复杂度O(n*amt)少了一个数量级</li>
</ul>
</li>
<li>然而，对于某些硬币面值组合，贪心算法并不能找到最优解<ul>
<li>正例：coins&#x3D;[1,5,10,20,50,100]:在该硬币组合下，给定任意amt，贪心算法都可以找到最优解</li>
<li>反例：coins&#x3D;[1,20,50]:假设amt&#x3D;60，贪心算法只能找到 50+10<em>1的兑换组合，共计11枚硬币，但动态规划可以找到最优解 20</em>3，只需3枚硬币</li>
<li>反例：coins&#x3D;[1,49,50]:假设amt&#x3D;98，贪心算法只能找到 50+48<em>1的兑换组合，共计49枚硬币，但动态规划可以找到最优解 49</em>2，只需2枚硬币</li>
</ul>
</li>
<li>也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。硬币兑换问题更适合用动态规划解决</li>
<li>一般情况下，贪心算法的使用情况分为以下两种：<ul>
<li>可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯，动态规划更高效</li>
<li>可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的</li>
</ul>
</li>
</ol>
<h3 id="1-1-2-贪心算法特性"><a href="#1-1-2-贪心算法特性" class="headerlink" title="1.1.2 贪心算法特性"></a>1.1.2 贪心算法特性</h3><p>什么样的问题适合用贪心算法求解？贪心算法在什么情况下可以保证找到最优解？</p>
<ol>
<li>相较于动态规划，贪心算法的“使用条件”更加苛刻，其主要关注问题的两个性质<ul>
<li>贪心选择性质：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解</li>
<li>最优子结构：原问题的最优解包含子问题的最优解</li>
</ul>
</li>
<li>值的注意的是，一些问题的最优子结构并不明显，但仍然可用贪心算法解决</li>
<li>证明贪心选择性质很难</li>
</ol>
<h3 id="1-1-3-贪心算法解题步骤"><a href="#1-1-3-贪心算法解题步骤" class="headerlink" title="1.1.3 贪心算法解题步骤"></a>1.1.3 贪心算法解题步骤</h3><ol>
<li>贪心问题的解决流程大体可分为以下三步：<ul>
<li>问题分析：梳理与理解问题特性，包括状态定义，优化目标和约束条件等。这一步在回溯和动态规划中都有涉及</li>
<li>确定贪心策略：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题</li>
<li>正确性证明：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用数学证明，例如归纳法或反证法等</li>
</ul>
</li>
<li>确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因：<ul>
<li>不同问题的贪心策略的差异较大。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂的问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了</li>
<li>某些贪心策略具有较强的迷惑性。当我们设计好贪心策略，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，例如上文介绍的零钱兑换</li>
</ul>
</li>
<li>为保证正确性，我们应该对贪心策略进行严谨的数学证明，通常需要用到反证法或数学归纳法</li>
</ol>
<h3 id="1-1-4-贪心算法典型例题"><a href="#1-1-4-贪心算法典型例题" class="headerlink" title="1.1.4 贪心算法典型例题"></a>1.1.4 贪心算法典型例题</h3><ol>
<li>硬币找零问题：在某些硬币组合下，贪心算法总是可以得到最优解</li>
<li>区间调度问题：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。<ul>
<li>如果每次都选择 结束时间最早的任务，那么贪心算法就可以得到最优解</li>
</ul>
</li>
<li>分数背包问题：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。<ul>
<li>如果每次都选择性价比最高(价值&#x2F;重量)的物品，那么贪心算法在一些情况下可以得到最优解</li>
</ul>
</li>
<li>股票买卖问题：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润</li>
<li>霍夫曼编码：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度(编码长度)最小</li>
<li>Dijkstra算法：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法</li>
</ol>
<h2 id="1-2-分数背包问题"><a href="#1-2-分数背包问题" class="headerlink" title="1.2 分数背包问题"></a>1.2 分数背包问题</h2><p>例题：给定n个物品，第i个物品的重量为wgt[i-1]，价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_133.png" alt="img_133.png"></li>
</ul>
<ol>
<li>分数背包问题和0-1背包问题整体上非常相似，状态包含当前物品i和容量c，目标是求限定背包容量下的最大价值</li>
<li>不同点在于，本题允许“只选择物品的一部分”。我们可以对物品任意地进行切分，并按照重量比例来计算相应价值<ul>
<li>对于物品i，它在单位重量下的价值为 val[i-1]&#x2F;wgt[i-1]，简称 单位价值</li>
<li>假设放入一部分物品i，重量为w，则背包增加的价值为 w*(val[i-1]&#x2F;wgt[i-1])</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_134.png" alt="img_134.png"></li>
</ul>
</li>
</ol>
<h3 id="1-2-1-贪心策略确定"><a href="#1-2-1-贪心策略确定" class="headerlink" title="1.2.1 贪心策略确定"></a>1.2.1 贪心策略确定</h3><ol>
<li>最大化背包内物品总价值，本质上是“最大化单位重量下的物品价值”</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_135.png" alt="img_135.png"><ul>
<li>将物品按照单位价值从高到低进行排序</li>
<li>遍历所有物品，每轮贪心的选择单位价值最高的物品</li>
<li>若剩余背包容量不足，则使用当前物品的一部分填满背包</li>
</ul>
</li>
</ol>
<h3 id="1-2-2-代码实现"><a href="#1-2-2-代码实现" class="headerlink" title="1.2.2 代码实现"></a>1.2.2 代码实现</h3><p>我们建立了一个物品类Item，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>&#123;</span><br><span class="line">   <span class="type">int</span> w;</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.w = w;</span><br><span class="line">      <span class="built_in">this</span>.v = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">fractionalKnapsack</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span> cap)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=wgt.length;</span><br><span class="line">   Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[n];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      items[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(wgt[i], val[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//按照单位价值从高到低进行排序</span></span><br><span class="line">   Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((<span class="type">double</span>) item.v/item.w)));</span><br><span class="line">   <span class="comment">//循环贪心选择</span></span><br><span class="line">   <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">      <span class="keyword">if</span>(item.w&lt;cap)&#123;</span><br><span class="line">         res+=item.v;</span><br><span class="line">         cap-= item.w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">         res+=(<span class="type">double</span>)cap* item.v/item.w;</span><br><span class="line">         <span class="comment">//已无剩余容量，因此跳出循环</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除排序之外，在最差情况下，需要遍历整个物品列表，因此时间复杂度为O(n)，其中n为物品数量。由于初始化了一个Item对象列表，因此空间复杂度为O(n)</p>
<h3 id="1-2-3-正确性声明"><a href="#1-2-3-正确性声明" class="headerlink" title="1.2.3 正确性声明"></a>1.2.3 正确性声明</h3><ol>
<li>采用反证法。假设物品x是单位价值最高的物品，使用某算法求得最大价值为res，但该解中不包含物品x</li>
<li>现在从背包中拿出单位重量的任何物品，并替换为单位重量的物品x。由于物品x的单位价值最高，因此替换后的总价值一定大于res。这与res是最优解矛盾，说明最优解中必须包含物品x</li>
<li>对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，单位价值更大的物品总是更优选择，这说明贪心策略是有效地</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_136.png" alt="img_136.png"></li>
</ol>
<h2 id="1-3-最大容量问题"><a href="#1-3-最大容量问题" class="headerlink" title="1.3 最大容量问题"></a>1.3 最大容量问题</h2><p>例题：输入一个数组ht，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。容器的容量等于高度和宽度的乘积，其高度由较短的隔板决定，宽度是两个隔板的数组索引之差。请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_137.png" alt="img_137.png"></li>
</ul>
<ol>
<li>容器由任意两个隔板围成，因此本题的状态为两个隔板的索引，记为[i,j]</li>
<li>根据题意，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的数组索引之差。设容量为cap[i,j]，可得计算公式<ul>
<li><code>cap[i,j]=min(ht[i],ht[j])*(j-i)</code></li>
</ul>
</li>
<li>设数组长度为n，两个隔板的组合数量(状态总数)为 n(n-1)&#x2F;2。最直接的，我们可以穷举所有状态，从而求得最大容量，时间复杂度为O(n^2)</li>
</ol>
<h3 id="1-3-1-贪心策略确定"><a href="#1-3-1-贪心策略确定" class="headerlink" title="1.3.1 贪心策略确定"></a>1.3.1 贪心策略确定</h3><ol>
<li>这道题还有更高效率的解法。现选取一个状态[i,j]，其满足索引i&lt;j且高度ht[i]&lt;ht[j]，即i为短板，j为长板<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_138.png" alt="img_138.png"></li>
</ul>
</li>
<li>若此时将长板j向短板i靠近，则容量一定减小<ul>
<li>这是因为在移动长板j后，宽度j-i一定变小。而高度由短板决定，因此高度只可能不变或减小</li>
</ul>
</li>
<li>反过来思考，我们只有向内收缩短板i，才“有可能”使容量变大。<ul>
<li>因为虽然宽度一定变小，但是高度可能会变大(移动后的短板i可能会变长)</li>
</ul>
</li>
<li>由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇</li>
<li>贪心策略的执行过程<ul>
<li>初始状态下，指针i和指针j分列数据两端</li>
<li>计算当前状态的容量cap[i,j]，并更新最大容量</li>
<li>比较板i和板j的高度，并将短板向内移动一格</li>
<li>循环执行第2步和第3步，直至i和j相遇时结束</li>
</ul>
</li>
</ol>
<h3 id="1-3-2-代码实现"><a href="#1-3-2-代码实现" class="headerlink" title="1.3.2 代码实现"></a>1.3.2 代码实现</h3><ol>
<li>代码最多循环n轮，因此时间复杂度为O(n)</li>
<li>变量i，j，res使用常数大小的额外空间，因此空间复杂度为O(1)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxCapacity</span><span class="params">(<span class="type">int</span>[] ht)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=ht.length-<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> cap=Math.min(ht[i],ht[j])*(j-i);</span><br><span class="line">      max=Math.max(max,cap);</span><br><span class="line">      <span class="keyword">if</span>(ht[i]&gt;ht[j])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-3-正确性证明"><a href="#1-3-3-正确性证明" class="headerlink" title="1.3.3 正确性证明"></a>1.3.3 正确性证明</h3><ol>
<li>之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态</li>
<li>比如在状态cap[i,j]下，i为短板，j为长板。若贪心地将短板i向内移动一格，会导致如图状态被“跳过”。这意味着之后无法验证这些状态的容量大小<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_139.png" alt="img_139.png"></li>
</ul>
</li>
<li>观察发现，这些被跳过的状态实际上就是将长板j向内移动的所有状态。前面我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，跳过它们不会导致错过最优解</li>
</ol>
<h2 id="1-4-最大切分乘积问题"><a href="#1-4-最大切分乘积问题" class="headerlink" title="1.4 最大切分乘积问题"></a>1.4 最大切分乘积问题</h2><p>例题：给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少</p>
<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_140.png" alt="img_140.png"></li>
</ul>
<ol>
<li>假设我们将n切分为m个整数因子，其中第i个因子记为Ni，即<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_141.png" alt="img_141.png"></li>
</ul>
</li>
<li>本题的目标是求得所有整数因子的最大乘积，即：<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_142.png" alt="img_142.png"></li>
</ul>
</li>
<li>我们需要思考的是：切分数量m应该多大，每个Ni应该是多小</li>
</ol>
<h3 id="1-4-1-贪心策略确定"><a href="#1-4-1-贪心策略确定" class="headerlink" title="1.4.1 贪心策略确定"></a>1.4.1 贪心策略确定</h3><ol>
<li>根据经验，两个整数的乘积往往比它们的加和更大。假设从n中分出一个因子2，则它们的乘积为2(n-2)。我们将该乘积与n作比较<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_143.png" alt="img_143.png"></li>
<li>当n&gt;&#x3D;4时，切分出一个2后乘积会变大，这说明“大于等于4的整数都应该被切分”</li>
</ul>
</li>
<li>贪心策略I：如果切分方案中包含&gt;&#x3D;4的因子，那么它就应该被继续切分。最终的切分方案只应出现1，2，3这三种因子<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_144.png" alt="img_144.png"></li>
<li>接下来考虑哪个因子是最优的。在1，2，3这三个因子中，显然1是最差的，因为 1*(n-1)&lt;n恒成立，即切分出1反而会导致乘积减小</li>
</ul>
</li>
<li>贪心策略II：在切分方案中，最多只应存在两个2.因为三个2总是可以替换为两个3，从而获得更大的乘积</li>
<li>综上所述：可推理出以下贪心策略：<ul>
<li>输入整数n，从其不断地切分出因子3，直至余数为0，1，2</li>
<li>当余数为0时，代表n是3的倍数，因此不做任何处理</li>
<li>当余数为2时，不继续划分，保留</li>
<li>当余数为1时，由于 2<em>2&gt;3</em>1，因此应将最后一个3替换为2</li>
</ul>
</li>
</ol>
<h3 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h3><ol>
<li>无须通过循环来切分整数，可以利用向下整除运算得到3的个数a，用取模运算得到余数b，此时有<code>n=3*a+b</code></li>
<li>对于n&lt;&#x3D;3的边界情况，必须拆分出一个1，乘积为<code>1*(n-1)</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> a=n/<span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//当余数为1时，3*1转化为2*2</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(b==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//当余数为2时，不做处理</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//当余数为0时，不做处理</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度取决于编程语言的幂运算的实现方法。</li>
<li>变量a和b使用常数大小的额外空间，因此空间复杂度为O(1)</li>
</ol>
<h3 id="1-4-3-正确性证明"><a href="#1-4-3-正确性证明" class="headerlink" title="1.4.3 正确性证明"></a>1.4.3 正确性证明</h3><p>使用反证法，只分析n&gt;&#x3D;3的情况</p>
<ol>
<li>所有因子&lt;&#x3D;3：假设最优切分方案中存在&gt;&#x3D;4的因子x，那么一定可以将其继续划分为2(x-2)，从而获得更大的乘积。这与假设矛盾</li>
<li>切分方案不包括1：假设最优切分方案中存在一个因子1，那么它一定可以合并入另外一个因子中，以获得更大的乘积。这与假设矛盾</li>
<li>切分方案最多包含两个2:假设最优切分方案中包含三个2，那么一定可以替换为两个3，乘积更大。这与假设矛盾</li>
</ol>
<h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><ol>
<li>贪心算法通常用于解决最优化问题，其原理是在每个决策阶段都做出“局部最优决策”，以期获得全局最优解</li>
<li>贪心算法会迭代地做出一个又一个的贪心选择，每轮都将问题转换成一个规模更小的子问题，直到问题被解决</li>
<li>贪心算法不仅实现简单，还具有很高的解题效率。相比于动态规划，贪心算法的时间复杂度通常更低</li>
<li>在零钱兑换问题中，对于某些硬币组合，贪心算法可以保证找到最优解；对于另外一些硬币组合则不然，贪心算法可能找到很差的解</li>
<li>适合用贪心算法求解的问题具有量大性质：贪心选择性质和最优子结构。贪心选择性质代表贪心策略的有效性</li>
<li>对于某些复杂问题，贪心选择性质的证明并不简单。相对来说，证伪更加容易，例如零钱兑换问题</li>
<li>求解贪心问题主要分为三步：问题分析，确定贪心策略，正确性证明。其中，确定贪心策略是核心步骤，正确性证明往往是难点</li>
<li>分数背包是在0-1背包的基础上，允许选择物品的一部分，因此可使用贪心算法求解。贪心策略的正确性可以使用反证法来证明</li>
<li>最大容量问题可使用穷举法求解，时间复杂度为O(n^2)。通过设计贪心策略，每轮向内移动短板，可将时间复杂度优化至O(n)</li>
<li>在最大切分乘积问题中，我们先后推理出两个贪心策略：&gt;&#x3D;4的整数都应该继续切分，最优切分因子为3。代码中包含幂运算，时间复杂度取决于幂运算的实现方法，通常为O(1)或O(log n)</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io">chaojiwudidashuaige</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/">https://chaojiwudidashuaige492.github.io/2024/05/23/算法入门学习笔记/class13/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaojiwudidashuaige492.github.io" target="_blank">超级无敌大帅哥</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法入门学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/" title="12动态规划"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">12动态规划</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/" title="03栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">03栈与队列</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/" title="01数据的结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">01数据的结构</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">02数组与链表</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/" title="05二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">05二叉树</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">10分治算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/" title="11回溯算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">11回溯算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chaojiwudidashuaige</div><div class="author-info__description">Plan first,Then code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chaojiwudidashuaige492" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaojiwudidashuaige492@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">1.1 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.1.1 贪心算法的优点和局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.1.2 贪心算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.1.3 贪心算法解题步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">1.1.4 贪心算法典型例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 分数背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%A1%AE%E5%AE%9A"><span class="toc-text">1.2.1 贪心策略确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%A3%B0%E6%98%8E"><span class="toc-text">1.2.3 正确性声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-text">1.3 最大容量问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%A1%AE%E5%AE%9A"><span class="toc-text">1.3.1 贪心策略确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-text">1.3.3 正确性证明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-text">1.4 最大切分乘积问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%A1%AE%E5%AE%9A"><span class="toc-text">1.4.1 贪心策略确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.4.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-text">1.4.3 正确性证明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.5 小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/t/" title="t">t</a><time datetime="2024-05-23T10:28:39.000Z" title="发表于 2024-05-23 18:28:39">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/" title="01Git概念">01Git概念</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/" title="02GitHubDesktop">02GitHubDesktop</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/" title="03IDEA集成GitHub">03IDEA集成GitHub</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/" title="05Git命令">05Git命令</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By chaojiwudidashuaige</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>