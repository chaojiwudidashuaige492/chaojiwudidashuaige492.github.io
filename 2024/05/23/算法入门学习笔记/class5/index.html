<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>05二叉树 | 超级无敌大帅哥</title><meta name="author" content="chaojiwudidashuaige"><meta name="copyright" content="chaojiwudidashuaige"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树二叉树 二叉树是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。 与链表类似，二叉树的基本单元是节点，每个节点包含值,左子节点引用,右子节点引用 每个节点都有两个引用，分别指向“左子节点”和“右子节点”，该节点被称为 这两个子节点的“父节点” 当给定一个二叉树的节点时，我们将 该节点的左子节点及其以下节点形成的树称为 该节点的“左子树”。同理可得 该节点的">
<meta property="og:type" content="article">
<meta property="og:title" content="05二叉树">
<meta property="og:url" content="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/index.html">
<meta property="og:site_name" content="超级无敌大帅哥">
<meta property="og:description" content="树二叉树 二叉树是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。 与链表类似，二叉树的基本单元是节点，每个节点包含值,左子节点引用,右子节点引用 每个节点都有两个引用，分别指向“左子节点”和“右子节点”，该节点被称为 这两个子节点的“父节点” 当给定一个二叉树的节点时，我们将 该节点的左子节点及其以下节点形成的树称为 该节点的“左子树”。同理可得 该节点的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-23T11:55:27.599Z">
<meta property="article:author" content="chaojiwudidashuaige">
<meta property="article:tag" content="算法入门学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chaojiwudidashuaige","link":"链接: ","source":"来源: 超级无敌大帅哥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '05二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 19:55:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="超级无敌大帅哥"><span class="site-name">超级无敌大帅哥</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">05二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T11:55:27.599Z" title="更新于 2024-05-23 19:55:27">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="05二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li>二叉树是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。</li>
<li>与链表类似，二叉树的基本单元是节点，每个节点包含<code>值,左子节点引用,右子节点引用</code></li>
<li>每个节点都有两个引用，分别指向“左子节点”和“右子节点”，该节点被称为 这两个子节点的“父节点”<ul>
<li>当给定一个二叉树的节点时，我们将 该节点的左子节点及其以下节点形成的树称为 该节点的“左子树”。同理可得 该节点的“右子树”</li>
</ul>
</li>
<li>二叉树中，除 叶节点(终端节点)外，其他所有节点都包含 子节点和非空子树</li>
</ol>
<h3 id="二叉树常见术语"><a href="#二叉树常见术语" class="headerlink" title="二叉树常见术语"></a>二叉树常见术语</h3><ol>
<li>根节点<code>root node</code>：位于二叉树顶层的节点，没有父节点</li>
<li>叶节点<code>leaf node</code>：没有子节点的节点，其两个指针均指向<code>null</code></li>
<li>边<code>edge</code>：连接两个节点的线段(节点引用)</li>
<li>节点所在的层<code>level</code>：从顶到底递增，根节点所在层为1</li>
<li>节点的度<code>degree</code>：节点的子节点的数量，在二叉树中，度的取值范围为{0,1,2}</li>
<li>二叉树的高度<code>height</code>：从根节点到最远叶节点所经过的边的数量</li>
<li>节点的深度<code>depth</code>：从根节点到该节点所经过边的数量(和上面比叫深度)</li>
<li>节点的高度<code>height</code>：从距离该节点最远的叶节点到该节点所经过的边的数量(和下面比叫高度)</li>
</ol>
<h4 id="注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要-1"><a href="#注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要-1" class="headerlink" title="注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要+1"></a>注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要+1</h4><h3 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h3><ol>
<li>初始化二叉树<ul>
<li>和链表类似，先初始化节点，然后构建引用</li>
</ul>
</li>
<li>插入与删除节点<ul>
<li>和链表类似，在二叉树中插入与删除节点可以通过修改引用来实现。</li>
</ul>
</li>
</ol>
<h4 id="注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作"><a href="#注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作" class="headerlink" title="注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作"></a>注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作</h4><h3 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h3><ol>
<li>完美二叉树&#x2F;满二叉树<code>perfect binary tree</code>：<ul>
<li>完美二叉树所有层的节点都被完全填满。即 叶节点的度为0，其余所有节点的度为2</li>
<li>若树的高度为h，则节点总数为 2^(h+1)-1。呈现标准的指数级关系</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-10.png" alt="Alt text"></li>
</ul>
</li>
<li>完全二叉树<code>complete binary tree</code>：<ul>
<li>完全二叉树只有最底层的节点未被填满，且最底层节点尽量靠左填充</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-11.png" alt="Alt text"></li>
</ul>
</li>
<li>完满二叉树<code>full binary tree</code>：<ul>
<li>完满二叉树除了叶节点之外，其余所有节点都有两个子节点(除了叶节点之外的节点的 子节点都是满的full)</li>
<li>即所有节点的度都为0或2</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-12.png" alt="Alt text"></li>
</ul>
</li>
<li>平衡二叉树<code>balanced binary tree</code>：<ul>
<li>平衡二叉树中 任意节点的左子树和右子树的高度之差的绝对值 不超过1</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-13.png" alt="Alt text"></li>
</ul>
</li>
</ol>
<h3 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h3><ol>
<li>当二叉树的每层节点都被填满时，达到“完美二叉树”</li>
<li>而当所有节点都偏向一侧时，二叉树退化为链表</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-14.png" alt="Alt text"></li>
<li>在最佳结构和最差结构下，二叉树的“叶节点数量”，“节点总数”，“高度”等达到极大值或极小值<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-15.png" alt="Alt text"></li>
</ul>
</li>
</ol>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ol>
<li>从物理结构的角度来看，树是一种基于链表的数据结构，因此其“遍历方式”是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现</li>
<li>二叉树常见的遍历方式包括”层序遍历”，“前序遍历”，“中序遍历”和“后序遍历”</li>
</ol>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol>
<li>层序遍历从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点</li>
<li>层序遍历本质上属于“广度优先遍历”，也称“广度优先搜索”，它体现了一种“一圈一圈向外扩展”的逐层遍历方式(先遍历完一圈，再遍历下一圈)</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelTraversal</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    Queue&lt;BinaryNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">BinaryNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(poll.val);</span><br><span class="line">        <span class="keyword">if</span>(poll.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(poll.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(poll.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol>
<li>时间复杂度O(n)：所有节点被访问一次，使用O(n)时间，其中n为节点数量</li>
<li>空间复杂度O(n)：在最差情况下，即满二叉树时，在即将遍历最底层时，队列中最多同时存在(n+1)&#x2F;2个节点(全是叶节点)，占用O(n)空间</li>
</ol>
<h3 id="前序，中序，后序遍历"><a href="#前序，中序，后序遍历" class="headerlink" title="前序，中序，后序遍历"></a>前序，中序，后序遍历</h3><ol>
<li>前序，中序和后序遍历都属于“深度优先遍历”，也称“深度优先搜索”，它体现了一种“先走到尽头，再回溯继续”的遍历方式</li>
<li>深度优先遍历就像是 绕着整棵二叉树的外围“走”一圈。在每个节点都会遇到三个位置，分别对应前序遍历，中序遍历和后序遍历<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-16.png" alt="Alt text"></li>
<li><pre><code class="java">//围绕二叉树走一圈算法：
public static void dfs(BinaryNode root)&#123;
    if(root==null)&#123;
      return ;
    &#125;
    dfs(root.left);
    dfs(root.right);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 代码实现(都基于走一圈dfs算法)</span><br><span class="line">1. 前序遍历</span><br><span class="line">```java</span><br><span class="line">public static void preOrder(BinaryNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>中序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-16.jpg" alt="Alt text"></li>
<li>沿着路线，前序，中序，后序遍历的“点位”决定了它们的“语句”相对于<code>dfs(left),dfs(right)</code>的位置</li>
</ol>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol>
<li>时间复杂度:O(n),所有节点被访问一次，使用O(n)时间</li>
<li>空间复杂度:O(n)，在最差情况下，即树退化为链表时，递归深度达到n，系统占用O(n)栈帧空间</li>
</ol>
<h2 id="二叉树数组表示"><a href="#二叉树数组表示" class="headerlink" title="二叉树数组表示"></a>二叉树数组表示</h2><h3 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h3><ol>
<li>给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引</li>
<li>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<code>若某节点的索引为i，则该节点的左子节点索引为2i+1，右子节点索引为2i+2</code><ul>
<li>理解：假定索引为i的节点位于的层还有x个节点。那么下一层(子节点所处的层)共有<code>i+x+1+1</code>(索引从0开始)个节点，减去<code>2x</code>个节点，即为“右子节点”所处的位置。所以“右子节点”的索引为<code>i+x+(i+x+2-2x)=2i+2</code>，由此得“左子节点”的索引为<code>2i+1</code></li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-20.png" alt="Alt text"></li>
<li>映射公式的角色相当于 节点中的引用。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的子节点</li>
</ol>
<h3 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h3><ol>
<li>完美二叉树是一个特例，在二叉树的中间层通常存在许多<code>null</code>。由于层序遍历序列并不包含这些<code>null</code>，因此我们无法仅凭该序列来推测<code>null</code>的数量和分布位置(即一个序列无法唯一表示一个二叉树)</li>
<li>这意味着存在多种二叉树结构都符合该层序遍历序列</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-21.png" alt="Alt text"></li>
<li>为了解决此问题，我们可以考虑“在层序遍历序列中显式地写出所有<code>null</code>”。这样处理后，层序遍历序列就可以唯一表示二叉树</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-22.png" alt="Alt text"></li>
</ol>
<h4 id="完全二叉树非常适合使用数组来表示。"><a href="#完全二叉树非常适合使用数组来表示。" class="headerlink" title="完全二叉树非常适合使用数组来表示。"></a>完全二叉树非常适合使用数组来表示。</h4><ol>
<li>根据完全二叉树的定义，<code>null</code>只出现在最底层且靠右的位置，因此所有<code>null</code>一定出现在层序遍历序列的末尾</li>
<li>这意味着使用数组表示完全二叉树时，可以省略存储所有<code>null</code></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-23.png" alt="Alt text"></li>
</ol>
<h3 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h3><ol>
<li>二叉树的数组表示主要有以下优点<ul>
<li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快</li>
<li>不需要存储指针，比较节省空间</li>
<li>允许随机访问节点<code>O(1)</code></li>
</ul>
</li>
<li>数组表示存在一些局限性<ul>
<li>数组存储需要连续内存空间，因此不适合存储数据量过大的树</li>
<li>增删节点需要通过数组插入与删除操作实现，效率较低</li>
<li>当二叉树中存在大量<code>null</code>时，数组中包含的节点数据比重较低，空间利用率较低</li>
</ul>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ol>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-24.png" alt="Alt text"></li>
<li>如图所示，<code>二叉搜索树 binary search tree</code>满足以下条件<ul>
<li>对于根节点，左子树中所有节点的值&lt;根节点的值&lt;右子树中所有节点的值</li>
<li>任意节点的左，右子树也是二叉搜索树，即同样满足条件1</li>
</ul>
</li>
</ol>
<h3 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h3><ol>
<li>将二叉搜索树封装为一个类<code>BinarySearchTree</code>，并声明一个成员变量<code>root</code>，指向树的根节点</li>
</ol>
<h4 id="1-查找节点"><a href="#1-查找节点" class="headerlink" title="1.查找节点"></a>1.查找节点</h4><ol>
<li>给定目标节点值<code>num</code>，可以根据二叉搜索树的性质来查找。</li>
<li>声明一个节点<code>cur</code>，从二叉搜索树的根节点<code>root</code>出发，“循环比较”节点值<code>cur.val</code>和<code>num</code>之间的大小关系<ul>
<li>若<code>cur.val&lt;num</code>：说明目标节点在cur的右子树中，因此执行<code>cur=cur.right</code></li>
<li>若<code>cur.val==num</code>：说明找到目标节点，跳出循环并返回该节点</li>
<li>若<code>cur.val&gt;num</code>：说明目标节点在cur的左子树中，因此执行<code>cur=cur.left</code></li>
</ul>
</li>
<li>二叉搜索树的查找操作与“二分查找算法”的工作原理一致，都是每轮排除一半情况(排除一个子树)。循环次数最多为二叉树的高度。当二叉树平衡时，使用<code>O(logn)</code>的时间<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BinarySearchNode <span class="title function_">searchNode</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="comment">//循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">for</span>(;cur!=<span class="literal">null</span>;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&gt;num)&#123;</span><br><span class="line">            <span class="comment">//目标节点在cur的左子树</span></span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&lt;num) &#123;</span><br><span class="line">            <span class="comment">//目标节点在cur的右子树</span></span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点就是cur</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2.插入节点"></a>2.插入节点</h4><ol>
<li>给定一个待插入元素<code>num</code>，为了保持”左子树&lt;根节点&lt;右子树”的性质，插入操作流程如图所示</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-25.png" alt="Alt text"><ul>
<li>查找插入位置：与查找操作类似，从根节点出发，根据当前节点值和<code>num</code>的大小关系循环向下搜索，知道“越过叶节点”(遍历至null)时跳出循环</li>
<li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>null</code>的位置</li>
</ul>
</li>
<li>在代码实现中，需要注意以下两点<ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回</li>
<li>为了实现插入节点，我们需要借助节点<code>pre</code>保存上一回循环的节点。这样在遍历至<code>null</code>时，我们可以获取到其父节点，从而完成节点插入操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchNode pre=<span class="literal">null</span>;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;num)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&gt;num) &#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre.val&lt;num)&#123;</span><br><span class="line">        pre.right=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        pre.left=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>与查找节点相同，插入节点使用<code>O(logn)</code>时间</li>
</ol>
<h4 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.删除节点"></a>3.删除节点</h4><ol>
<li>先在二叉树中查找到目标节点，再将其删除。</li>
<li>与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树&lt;根节点&lt;右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量(度)，分0，1，2三种情况，执行对应的删除节点操作<ul>
<li>当待删除节点的度为0时，表示该节点是叶节点，可以直接删除<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-26.png" alt="Alt text"></li>
</ul>
</li>
<li>当待删除节点的度为1时，将待删除节点替换为其子节点即可<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-27.png" alt="Alt text"></li>
</ul>
</li>
</ul>
</li>
<li>当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树&lt;根节点&lt;右子树”的性质，因此这个节点可以是<code>右子树的最小节点或左子树的最大节点</code><ul>
<li>删除操作流程：<ul>
<li>找到待删除节点在“中序遍历序列”中的 上一个节点&#x2F;下一个节点(对应 左子树的最大节点&#x2F;右子树的最小节点)，记为tmp</li>
<li>用tmp的值覆盖 待删除节点的值，并在二叉搜索树中递归删除节点tmp(tmp的度为0或1，对应上文的删除方法)</li>
</ul>
</li>
<li>示意图：<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-28.png" alt="Alt text"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-29.png" alt="Alt text"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-30.png" alt="Alt text"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-31.png" alt="Alt text"></li>
</ul>
</li>
</ul>
</li>
<li>删除节点操同样使用<code>O(logn)</code>时间，其中查找待删除节点需要<code>O(logn)</code>时间，获取中序遍历后继节点需要<code>O(logn)</code>时间(实际上是找右树最左端节点)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//空树</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchNode pre=<span class="literal">null</span>;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;<span class="comment">//查找</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;num)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&gt;num) &#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;<span class="comment">//没找到</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到了--&gt;删除</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left==<span class="literal">null</span>||cur.right==<span class="literal">null</span>)&#123;<span class="comment">//degree=0or1，为什么要把它们放在一起--&gt;处理方法相同</span></span><br><span class="line">        <span class="comment">//cur的子节点(null或节点)</span></span><br><span class="line">        BinarySearchNode child=cur.left==<span class="literal">null</span>?cur.right:cur.left;<span class="comment">//如果cur.left为空，那么直接返回right</span></span><br><span class="line">        <span class="comment">//因为处理degree为0和1的方法相同，所以可以直接使用right。如果cur.left不为空，那么直接返回cur.left</span></span><br><span class="line">        <span class="keyword">if</span>(cur==root)&#123;<span class="comment">//如果删除根节点，那么pre就为null,所以需要额外写一个方法</span></span><br><span class="line">            root=child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==pre.left)&#123;</span><br><span class="line">                pre.left=child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right=child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//degree为2</span></span><br><span class="line">        <span class="comment">//中序遍历cur的下一个节点(右子树的最左端)</span></span><br><span class="line">        BinarySearchNode tmp=cur.right;<span class="comment">//定位右子树</span></span><br><span class="line">        <span class="keyword">while</span>(tmp.left!=<span class="literal">null</span>)&#123;<span class="comment">//遍历查找右子树最左节点</span></span><br><span class="line">            tmp=tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remove(tmp.val);<span class="comment">//删除节点(递归删除)</span></span><br><span class="line">        cur.val=tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/loading.gif" data-original="/images/AlgoGettingStart/IMG_0047.jpg" alt="Alt text"></li>
</ol>
<h4 id="4-中序遍历-有序"><a href="#4-中序遍历-有序" class="headerlink" title="4.中序遍历(有序)"></a>4.中序遍历(有序)</h4><ol>
<li>二叉树的中序遍历遵循“左–&gt;根–&gt;右”的遍历顺序，而二叉搜索树满足“左子节点&lt;根节点&lt;右子节点”的大小关系</li>
<li>这意味着 “二叉搜索树的中序遍历序列是升序的”</li>
<li>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需<code>O(n)</code>时间，无须进行额外的排序操作，非常高效</li>
</ol>
<h3 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h3><ol>
<li>二叉搜索树增删改查的时间复杂度都是<code>O(logn)</code>。只有在高频添加，低频查找删除数据的场景下，数组比二叉搜索树的效率更高<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-32.png" alt="Alt text"></li>
</ul>
</li>
<li>在理想情况下，二叉搜索树是“平衡”的，这样就可以在”logn”轮循环内查找任意节点</li>
<li>然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为链表。这时各种操作的时间复杂度也会退化为O(n)<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-33.png" alt="Alt text"></li>
</ul>
</li>
</ol>
<h3 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h3><ol>
<li>用作系统中的“多级索引”，实现高效的查找，插入，删除操作</li>
<li>作为某些搜索算法的底层数据结构</li>
<li>用于存储数据流，以保持其有序状态</li>
</ol>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ol>
<li>在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从<code>O(logn)</code>劣化至<code>O(n)</code><ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-34.png" alt="Alt text"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-35.png" alt="Alt text"></li>
</ul>
</li>
<li>AVL树确保在持续添加和删除节点后，AVL树不会退化，从而使得各种操作的时间复杂度保持在<code>O(logn)</code>级别。</li>
<li>在需要频繁进行增删改查操作的场景中，AVL树能始终保持高效的数据操作性能，具有很好的应用价值</li>
<li>在不改变中序遍历序列的情况下，改变树的结构</li>
<li>局部改变:都是以某个节点作为根节点，研究该节点延伸出的树</li>
</ol>
<h3 id="AVL树常见术语"><a href="#AVL树常见术语" class="headerlink" title="AVL树常见术语"></a>AVL树常见术语</h3><ol>
<li>AVL树既是平衡二叉树，又是二叉搜索树。同时满足这两类二叉树的所有性质，因此是一种 “平衡二叉搜索树<code>balanced binary search tree</code>”</li>
</ol>
<h4 id="节点高度"><a href="#节点高度" class="headerlink" title="节点高度"></a>节点高度</h4><ol>
<li>由于AVL树的相关操作需要获取节点高度，因此我们需要为节点类添加<code>height</code>属性</li>
<li>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的边的数量。需要特别注意的是，叶节点的高度为0，而空节点的高度为-1。</li>
<li>创建两个工具方法，分别用于获取和更新节点的高度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node==<span class="literal">null</span>?-<span class="number">1</span>: node.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    node.height=Math.max(getHeight(node.left),getHeight(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="节点平衡因子"><a href="#节点平衡因子" class="headerlink" title="节点平衡因子"></a>节点平衡因子</h4><ol>
<li>节点的<code>平衡因子 balance factor</code>定义为“节点左子树的高度减去右子树的高度”</li>
<li>同时规定空节点的平衡因子为0</li>
<li>将获取节点平衡因子的功能封装成方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBalancedFactor</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left)-getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设平衡因子为f，则一棵AVL树的任意节点的平衡因子都满足<code>-1&lt;f&lt;1</code></li>
</ol>
<h3 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a>AVL树旋转</h3><ol>
<li>AVL树的特点在于“旋转操作”，它能够在“不影响二叉树的中序遍历序列的前提下”，使失衡节点重新恢复平衡</li>
<li>旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”</li>
<li>将平衡因子的绝对值&gt;1的节点称为“失衡节点”</li>
<li>根据“节点失衡情况”不同，旋转操作分为四种：右旋，左旋，先右旋后左旋，先左旋后右旋</li>
</ol>
<h4 id="1-右旋"><a href="#1-右旋" class="headerlink" title="1.右旋"></a>1.右旋</h4><h5 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h5><ol>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-36.png" alt="Alt text"><ul>
<li>从底至顶看，二叉树中首个失衡节点是“节点三”。</li>
<li>关注以该失衡节点为根节点的子树</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-37.png" alt="Alt text"><ul>
<li>将该节点记为node，其左子节点记为child</li>
</ul>
</li>
<li>执行右旋操作，完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-38.png" alt="Alt text"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-39.png" alt="Alt text"></li>
</ul>
</li>
</ol>
<h5 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h5><p>当节点child有右子节点(记为grand_child)时，需要在右旋中添加一步，将grand_child作为node的左子节点(因为它大于node小于child)<br><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-40.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">rightRotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.right;</span><br><span class="line">    <span class="comment">//以child为原点，将node向右旋转</span></span><br><span class="line">    child.right=node;</span><br><span class="line">    node.left=grandChild;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">//返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-左旋"><a href="#2-左旋" class="headerlink" title="2.左旋"></a>2.左旋</h4><ol>
<li>相应的，如果考虑上述失衡二叉树的镜像，则需要执行“左旋”操作<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-41.png" alt="Alt text"></li>
</ul>
</li>
<li>同理，当节点child有左子节点(记为grandChild)时，需要将grandChild作为node的右子节点(grandChild小于child大于node)<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-42.png" alt="Alt text"></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">leftRotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">child</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.left;</span><br><span class="line">    <span class="comment">//围绕child向左旋转</span></span><br><span class="line">    child.left=node;</span><br><span class="line">    node.right=grandChild;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">//返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-先右旋后左旋"><a href="#3-先右旋后左旋" class="headerlink" title="3.先右旋后左旋"></a>3.先右旋后左旋</h4><p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-43.png" alt="Alt text"></p>
<ul>
<li>对于图中的失衡节点，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对child执行“左旋”，再对node执行“右旋”</li>
</ul>
<h4 id="4-先左旋后右旋"><a href="#4-先左旋后右旋" class="headerlink" title="4.先左旋后右旋"></a>4.先左旋后右旋</h4><p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-44.png" alt="Alt text"></p>
<ul>
<li>对于上述失衡二叉树的镜像情况，需要先对child进行右旋，再对node进行左旋</li>
</ul>
<h4 id="旋转的选择"><a href="#旋转的选择" class="headerlink" title="旋转的选择"></a>旋转的选择</h4><ol>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-45.png" alt="Alt text"></li>
<li>通过判断失衡节点的平衡因子以及 较高一侧子节点的平衡因子的正负号，来确定失衡节点属于哪种情况<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/image-46.png" alt="Alt text"></li>
</ul>
</li>
<li>为了便于使用，将旋转操作封装成一个函数。有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">rotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balancedFactor</span> <span class="operator">=</span> getBalancedFactor(node);</span><br><span class="line">    <span class="keyword">if</span>(balancedFactor&gt;<span class="number">1</span>)&#123;<span class="comment">//左偏</span></span><br><span class="line">        <span class="keyword">if</span>(getBalancedFactor(node.left)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.left=leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(balancedFactor&lt;-<span class="number">1</span>)&#123;<span class="comment">//右偏</span></span><br><span class="line">        <span class="keyword">if</span>(getBalancedFactor(node.right)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.right=rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVL树常用操作"><a href="#AVL树常用操作" class="headerlink" title="AVL树常用操作"></a>AVL树常用操作</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol>
<li>AVL树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在AVL树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。</li>
<li>因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    root=insertHelper(root,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以根节点作为遍历的起始节点</span></span><br><span class="line"><span class="comment">/*辅助方法便于递归调用*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">insertHelper</span><span class="params">(BalancedBinarySearchNode node,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BalancedBinarySearchNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;node.val)&#123;<span class="comment">//查找并排序</span></span><br><span class="line">        node.left=insertHelper(node,val);<span class="comment">//递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val&gt;node.val) &#123;</span><br><span class="line">        node.right=insertHelper(node,val);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node);<span class="comment">//递归更新高度</span></span><br><span class="line">    <span class="comment">/*旋转，从下到上检查失衡并旋转*/</span></span><br><span class="line">    rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//一边递归找到添加的位置，一边递归更新路径上的节点高度，还从底向上进行旋转(“递归”)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>类似的，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    root=removeHelper(root,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">removeHelper</span><span class="params">(BalancedBinarySearchNode node,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归查找并删除</span></span><br><span class="line">    <span class="keyword">if</span>(val&lt; node.val)&#123;</span><br><span class="line">        node.left=removeHelper(node.left,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val&gt; node.val) &#123;</span><br><span class="line">        node.right=removeHelper(node.right,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//找到了，进行删除</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span>||node.right==<span class="literal">null</span>)&#123;<span class="comment">//degree=0/1</span></span><br><span class="line">            BalancedBinarySearchNode child=node.left==<span class="literal">null</span>?node.right:node.left;</span><br><span class="line">            <span class="keyword">if</span>(child==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node=child;<span class="comment">//放到后面再返回，因为还要执行一些操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//degree=2</span></span><br><span class="line">            BalancedBinarySearchNode tmpNode=node.right;</span><br><span class="line">            <span class="keyword">while</span>(tmpNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tmpNode=tmpNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right=removeHelper(node.right,tmpNode.val);</span><br><span class="line">            node.val=tmpNode.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node);<span class="comment">//递归更新节点高度</span></span><br><span class="line">    node=rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>AVL树的节点查找操作与二叉搜索树一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    BalancedBinarySearchNode tmp=root;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; tmp.val) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; tmp.val) &#123;</span><br><span class="line">            tmp = tmp.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVL树典型应用"><a href="#AVL树典型应用" class="headerlink" title="AVL树典型应用"></a>AVL树典型应用</h3><ol>
<li>组织和存储大型数据，适用于高频查找，低频增删的场景</li>
<li>用于构建数据库中的索引系统</li>
<li>红黑树也是一种常见的平衡二叉搜索树。相较于AVL树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io">chaojiwudidashuaige</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/">https://chaojiwudidashuaige492.github.io/2024/05/23/算法入门学习笔记/class5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaojiwudidashuaige492.github.io" target="_blank">超级无敌大帅哥</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法入门学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">02数组与链表</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">10分治算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/" title="03栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">03栈与队列</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/" title="01数据的结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">01数据的结构</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">02数组与链表</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">10分治算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/" title="11回溯算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">11回溯算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/" title="04哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">04哈希表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chaojiwudidashuaige</div><div class="author-info__description">Plan first,Then code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chaojiwudidashuaige492" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaojiwudidashuaige492@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-text">二叉树常见术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E9%80%9A%E5%B8%B8%E5%B0%86%E2%80%9C%E9%AB%98%E5%BA%A6%E2%80%9D%E5%92%8C%E2%80%9C%E6%B7%B1%E5%BA%A6%E2%80%9D%E5%AE%9A%E4%B9%89%E4%B8%BA%E2%80%9C%E7%BB%8F%E8%BF%87%E7%9A%84%E8%BE%B9%E7%9A%84%E6%95%B0%E9%87%8F%E2%80%9D%EF%BC%8C%E4%BD%86%E6%9C%89%E4%BA%9B%E6%97%B6%E5%80%99%E5%8F%AF%E8%83%BD%E5%B0%86%E5%85%B6%E5%AE%9A%E4%B9%89%E4%B8%BA%E2%80%9C%E7%BB%8F%E8%BF%87%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F%E2%80%9D%E3%80%82%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E9%AB%98%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E9%83%BD%E9%9C%80%E8%A6%81-1"><span class="toc-text">注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要+1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉树的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%94%B9%E5%8F%98%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8E%9F%E6%9C%89%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%8C%E8%80%8C%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E9%80%9A%E5%B8%B8%E6%84%8F%E5%91%B3%E7%9D%80%E5%88%A0%E9%99%A4%E8%AF%A5%E8%8A%82%E7%82%B9%E5%8F%8A%E5%85%B6%E6%89%80%E6%9C%89%E5%AD%90%E6%A0%91%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%EF%BC%8C%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%98%AF%E7%94%B1%E4%B8%80%E5%A5%97%E6%93%8D%E4%BD%9C%E9%85%8D%E5%90%88%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%8C%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见二叉树类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%80%E5%8C%96"><span class="toc-text">二叉树的退化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序，中序，后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">二叉树数组表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">表示完美二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E4%BB%BB%E6%84%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">表示任意二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E8%A1%A8%E7%A4%BA%E3%80%82"><span class="toc-text">完全二叉树非常适合使用数组来表示。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">优点与局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">1.查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-text">2.插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">3.删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%9C%89%E5%BA%8F"><span class="toc-text">4.中序遍历(有序)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-text">二叉搜索树的效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="toc-text">二叉搜索树常见应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-text">AVL树常见术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%AB%98%E5%BA%A6"><span class="toc-text">节点高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="toc-text">节点平衡因子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%E6%97%8B%E8%BD%AC"><span class="toc-text">AVL树旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%B3%E6%97%8B"><span class="toc-text">1.右旋</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A"><span class="toc-text">案例一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A"><span class="toc-text">案例二：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A6%E6%97%8B"><span class="toc-text">2.左旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%88%E5%8F%B3%E6%97%8B%E5%90%8E%E5%B7%A6%E6%97%8B"><span class="toc-text">3.先右旋后左旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%88%E5%B7%A6%E6%97%8B%E5%90%8E%E5%8F%B3%E6%97%8B"><span class="toc-text">4.先左旋后右旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">旋转的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">AVL树常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-text">查找节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-text">AVL树典型应用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/t/" title="t">t</a><time datetime="2024-05-23T10:28:39.000Z" title="发表于 2024-05-23 18:28:39">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/" title="01Git概念">01Git概念</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/" title="02GitHubDesktop">02GitHubDesktop</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/" title="03IDEA集成GitHub">03IDEA集成GitHub</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/" title="05Git命令">05Git命令</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By chaojiwudidashuaige</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>