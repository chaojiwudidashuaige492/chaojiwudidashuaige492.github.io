<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>09排序算法 | 超级无敌大帅哥</title><meta name="author" content="chaojiwudidashuaige"><meta name="copyright" content="chaojiwudidashuaige"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序1.1 排序算法 排序算法sorting algorithm用于对一组数据按照“特定顺序”进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效的查找，分析和处理  排序算法中的数据类型可以是整数，浮点数，字符或字符串等。排序的判断规则可根据需求设定，如数字大小，字符ASCII码顺序或自定义规则(comparator)    1.1.1 评价维度 运行效率：我们期望排序算法的时间复杂度">
<meta property="og:type" content="article">
<meta property="og:title" content="09排序算法">
<meta property="og:url" content="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class9/index.html">
<meta property="og:site_name" content="超级无敌大帅哥">
<meta property="og:description" content="排序1.1 排序算法 排序算法sorting algorithm用于对一组数据按照“特定顺序”进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效的查找，分析和处理  排序算法中的数据类型可以是整数，浮点数，字符或字符串等。排序的判断规则可根据需求设定，如数字大小，字符ASCII码顺序或自定义规则(comparator)    1.1.1 评价维度 运行效率：我们期望排序算法的时间复杂度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-23T11:55:27.587Z">
<meta property="article:author" content="chaojiwudidashuaige">
<meta property="article:tag" content="算法入门学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chaojiwudidashuaige","link":"链接: ","source":"来源: 超级无敌大帅哥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '09排序算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 19:55:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="超级无敌大帅哥"><span class="site-name">超级无敌大帅哥</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">09排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T11:55:27.587Z" title="更新于 2024-05-23 19:55:27">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="09排序算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1-1-排序算法"><a href="#1-1-排序算法" class="headerlink" title="1.1 排序算法"></a>1.1 排序算法</h2><ol>
<li>排序算法<code>sorting algorithm</code>用于对一组数据按照“特定顺序”进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效的查找，分析和处理</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_44.png" alt="img_44.png"><ul>
<li>排序算法中的数据类型可以是整数，浮点数，字符或字符串等。排序的判断规则可根据需求设定，如数字大小，字符ASCII码顺序或自定义规则(<code>comparator</code>)</li>
</ul>
</li>
</ol>
<h3 id="1-1-1-评价维度"><a href="#1-1-1-评价维度" class="headerlink" title="1.1.1 评价维度"></a>1.1.1 评价维度</h3><ol>
<li>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少(时间复杂度中的常数项变小)。对于大数据量的情况，运行效率显得尤为重要</li>
<li>就地性：顾名思义，“原地排序”通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快</li>
<li>稳定性：“稳定排序”在完成排序后，“相等元素”在数组中的“相对顺序”不发生改变<ul>
<li>稳定排序是多极排序场景的必要条件(你的排序不能破坏别人排序的成果)</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_45.png" alt="img_45.png"></li>
</ul>
</li>
<li>自适应性：“自适应排序”的时间复杂度会受输入数据的影响，即最佳时间复杂度，最差时间复杂度，平均时间复杂度并不完全相等<ul>
<li>自适应性需要根据具体情况来评估。</li>
<li>如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性</li>
<li>如果最佳时间复杂度优于平均时间复杂度，说明排序算法在某些数据下性能可能优化，因此被视为正面属性</li>
</ul>
</li>
<li>是否基于比较：“基于比较的排序”依赖比较运算符(&lt;,&#x3D;,&gt;)来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为O(nlogn)。而“非比较排序”不使用比较运算符，时间复杂度可达O(n)，但其通用性相对较差</li>
</ol>
<h3 id="1-1-2-理想排序算法"><a href="#1-1-2-理想排序算法" class="headerlink" title="1.1.2 理想排序算法"></a>1.1.2 理想排序算法</h3><ol>
<li>运行快，原地，稳定，正向自适应，通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，“需要根据具体的数据特点和问题需求来决定”</li>
</ol>
<h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><ol>
<li>选择排序<code>selection sort</code>的工作原理非常简单:开启一个循环，每轮从“未排序区间”选择最小的元素，将其放到已排序区间的末尾</li>
<li>设数组的长度为n，选择排序的算法流程如下：<ul>
<li>1.初始状态下，所有元素未排序，即未排序(索引)区间为[0,n-1]</li>
<li>2.选取区间[0,n-1]中的最小元素，将其与索引0处的元素交换。完成后，数组前1个元素已排序</li>
<li>3.选取区间[1,n-1]中的最小元素，将其与索引1处的元素交换。完成后，数组前2个元素已排序</li>
<li>4.以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序</li>
<li>5.仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外循环，等待排序的索引位置为i，只用对前n-1个元素进行排序</span></span><br><span class="line">      <span class="type">int</span> minIndex=i;<span class="comment">//记录最小索引</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt; nums.length;j++)&#123;<span class="comment">//在未排序区间[i,n-1]中寻找最小元素</span></span><br><span class="line">         minIndex=nums[j]&lt;nums[minIndex]?j:minIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,minIndex);<span class="comment">//交换元素</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="1-2-1-算法特性"><a href="#1-2-1-算法特性" class="headerlink" title="1.2.1 算法特性"></a>1.2.1 算法特性</h3><ol>
<li>时间复杂度为<code>O(n^2)</code>，非自适应排序：外循环一共包括n-1轮，第一轮的未排序区间长度为n，最后一轮的未排序区间长度为2，求和为 (n-1)(n+2)&#x2F;2即O(n^2)</li>
<li>空间复杂度为<code>O(1)</code>，原地排序：指针i和指针j使用常数大小的额外空间</li>
<li>非稳定排序：如图所示<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_46.png" alt="img_46.png"></li>
</ul>
</li>
</ol>
<h2 id="1-3-冒泡排序"><a href="#1-3-冒泡排序" class="headerlink" title="1.3 冒泡排序"></a>1.3 冒泡排序</h2><ol>
<li>冒泡排序<code>bubble sort</code>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序</li>
<li>冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素&gt;右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端<ul>
<li>第i轮，将第i大(小)的元素放在倒数第i个位置</li>
</ul>
</li>
<li>图示：<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_47.png" alt="img_47.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_48.png" alt="img_48.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_49.png" alt="img_49.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_50.png" alt="img_50.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_51.png" alt="img_51.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_52.png" alt="img_52.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_53.png" alt="img_53.png"></li>
</ul>
</li>
</ol>
<h3 id="1-3-1-算法流程"><a href="#1-3-1-算法流程" class="headerlink" title="1.3.1 算法流程"></a>1.3.1 算法流程</h3><p>设数组的长度为n，冒泡排序的步骤为：</p>
<ul>
<li>1.首先，对n个元素执行“冒泡”，将数组的最大元素交换至正确位置</li>
<li>2.接下来，对剩余n-1个元素执行“冒泡”，将第二大元素交换至正确位置</li>
<li>3.以此类推，经过n-1轮“冒泡”后，前n-1大的元素都被交换至正确位置</li>
<li>4.仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_54.png" alt="img_54.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> length= nums.length;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;<span class="comment">//只需要进行n-1次排序</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-<span class="number">1</span>-i;j++)&#123;<span class="comment">//每轮都在未排序区间,通过相邻元素的比较和交换,将最大的元素移动到右端</span></span><br><span class="line">         <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-2-效率优化"><a href="#1-3-2-效率优化" class="headerlink" title="1.3.2 效率优化"></a>1.3.2 效率优化</h3><ol>
<li>如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。</li>
<li>因此，我们可以增加一个<code>标志位flag</code>来监测这种情况，一旦出现就立即返回</li>
<li>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为<code>O(n^2)</code>。但当输入数组完全有序时，可达到最佳时间复杂度O(n)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSortWithFlag</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> length= nums.length;</span><br><span class="line">   <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">            flag=<span class="literal">false</span>;<span class="comment">//只要执行一次swap那么flag就为false不会导致循环终止</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-3-算法特性"><a href="#1-3-3-算法特性" class="headerlink" title="1.3.3 算法特性"></a>1.3.3 算法特性</h3><ol>
<li>时间复杂度<code>O(n^2)</code>，自适应排序：各轮“冒泡”遍历的数组长度依次为n-1,n-2,…,2,1。总和为 (n-1)n&#x2F;2。在引入flag优化后，最佳时间复杂度可达到<code>O(n)</code></li>
<li>空间复杂度<code>O(1)</code>，原地排序：指针i和指针j使用常数大小的额外空间</li>
<li>稳定排序：由于在“冒泡”中遇到相等元素不交换</li>
</ol>
<h2 id="1-4-插入排序"><a href="#1-4-插入排序" class="headerlink" title="1.4 插入排序"></a>1.4 插入排序</h2><ol>
<li>插入排序<code>insertion sort</code>是一种简单的排序算法，它的工作原理与“手动整理一副牌”的过程非常相似</li>
<li>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置</li>
<li>设基准元素为base，我们需要将 从目标索引到base之间的所有元素[targetIndex,base)向右移动一位，然后将base赋值给目标索引<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_55.png" alt="img_55.png"></li>
</ul>
</li>
</ol>
<h3 id="1-4-1-算法流程"><a href="#1-4-1-算法流程" class="headerlink" title="1.4.1 算法流程"></a>1.4.1 算法流程</h3><p>插入排序的整体流程如下：</p>
<ul>
<li>1.初始状态下，数组的第1个元素已完成排序</li>
<li>2.选取数组的第2个元素作为base，将其插入到正确位置后，“数组的前2个元素已排序”</li>
<li>3.选取数组的第3个元素作为base，将其插入到正确位置后，“数组的前3个元素已排序”</li>
<li>4.以此类推，在最后一轮中，选取最后一个元素作为base，将其插入到正确位置后，“所有元素均已排序”<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> base=<span class="number">1</span>;base&lt; nums.length;base++)&#123;<span class="comment">//base从第2个元素开始直到第n个,已排序区间为[0,base)</span></span><br><span class="line">      <span class="type">int</span> tmp=nums[base];<span class="comment">//临时变量存储base的值</span></span><br><span class="line">      <span class="type">int</span> index=base-<span class="number">1</span>;<span class="comment">//从base-1开始向前查找第一个小于base的元素(它的下一个即为base应该插入的位置)</span></span><br><span class="line">      <span class="keyword">while</span> (index&gt;=<span class="number">0</span>&amp;&amp;nums[index]&gt;nums[base])&#123;</span><br><span class="line">         nums[index+<span class="number">1</span>]=nums[index];<span class="comment">//位于插入位置之前的元素不需要向后移动</span></span><br><span class="line">         index--;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[index+<span class="number">1</span>]=tmp;<span class="comment">//index的下一个位置才为base应该插入的位置</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-2-算法特性"><a href="#1-4-2-算法特性" class="headerlink" title="1.4.2 算法特性"></a>1.4.2 算法特性</h3><ol>
<li>时间复杂度为<code>O(n^2)</code>，自适应排序：在最差情况下，每次插入操作分别需要循环n-1,n-1…2,1次，求和得到(n-1)n&#x2F;2，因此时间复杂度为<code>O(n^2)</code>。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度O(n)</li>
<li>空间复杂度为<code>O(1)</code>，原地排序：指针i和j使用常数大小的额外空间</li>
<li>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序</li>
</ol>
<h3 id="1-4-3-插入排序的优势"><a href="#1-4-3-插入排序的优势" class="headerlink" title="1.4.3 插入排序的优势"></a>1.4.3 插入排序的优势</h3><ol>
<li>插入排序的时间复杂度为<code>O(n^2)</code>，而我们即将学习的快速排序的时间复杂度为<code>O(nlogn)</code>。尽管插入排序的时间复杂度更高，但在数据量较小的情况下，插入排序通常更快<ul>
<li>这个结论与线性查找和二分查找的的适用情况的结论类似。快速排序这类O(nlogn)的算法属于基于分治策略的排序算法，往往包含更多“单元计算操作”。而在数据量较小时，n^2和nlogn的数值比较接近，且复杂度不占主导地位，每轮中的单元操作数量起到决定性作用</li>
</ul>
</li>
<li>实际上，许多编程语言(例如Java)的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序</li>
<li>虽然冒泡排序，选择排序和插入排序的时间复杂度都为<code>O(n^2)</code>，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因<ul>
<li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及3个单元操作；插入排序基于元素赋值实现，仅需1个单元操作。因此，冒泡排序的计算开销通常比插入排序更高</li>
<li>选择排序在任何情况下的时间复杂度都为<code>O(n^2)</code>。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</li>
<li>选择排序不稳定，无法应用于多级排序</li>
</ul>
</li>
</ol>
<h2 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h2><ol>
<li>快速排序<code>quick sort</code>是一种基于“分治策略”的排序算法，运行高效，应用广泛</li>
<li>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧(流程如下)<ul>
<li>1.选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端</li>
<li>2.设置一个循环，在每轮中使用i(j)分别寻找“第一个”比基准数大(小)的元素，然后交换这两个元素</li>
<li>3.循环执行步骤2，直到i和j相遇为止，最后将基准数交换至两个子数组的分界线</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_56.png" alt="img_56.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_57.png" alt="img_57.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_58.png" alt="img_58.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_59.png" alt="img_59.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_60.png" alt="img_60.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_61.png" alt="img_61.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_62.png" alt="img_62.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_63.png" alt="img_63.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_64.png" alt="img_64.png"></li>
</ul>
</li>
<li>哨兵划分完成后，原数组被划分成三个部分：左子数组，右子数组，基准数。且满足“左子数组任意元素&lt;&#x3D;基准数&lt;&#x3D;右子数组任意元素”。</li>
<li>因此，我们接下来只需对这两个子数组进行排序</li>
<li>哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;<span class="comment">//left和right是为了满足在递归中被调用的</span></span><br><span class="line">    <span class="comment">//以nums[left]为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] &gt;= nums[left]) &#123;</span><br><span class="line">            j--;<span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;<span class="comment">//以最左端为基准数时必须要先从右向左查找</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">            i++;<span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, i);<span class="comment">//将基准数交换至两个子数组的分界线</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-5-1-算法流程"><a href="#1-5-1-算法流程" class="headerlink" title="1.5.1 算法流程"></a>1.5.1 算法流程</h3><p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_65.png" alt="img_65.png"></p>
<ul>
<li>1.首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组</li>
<li>2.然后，对左子数组和右子数组分别递归执行”哨兵划分”</li>
<li>3.持续递归，直至子数组长度为1时终止，从而完成整个数组的排序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="comment">//子数组长度为1时终止递归</span></span><br><span class="line">   <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//哨兵划分</span></span><br><span class="line">   <span class="type">int</span> pivot=partition(nums, left, right);</span><br><span class="line">   <span class="comment">//递归左子数组，右子数组</span></span><br><span class="line">   quickSort(nums,left,pivot-<span class="number">1</span>);</span><br><span class="line">   quickSort(nums,pivot+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-2-算法特性"><a href="#1-5-2-算法特性" class="headerlink" title="1.5.2 算法特性"></a>1.5.2 算法特性</h3><ol>
<li>时间复杂度为<code>O(nlogn)</code>，自适应排序：在平均情况下，哨兵划分的“递归层次为logn”每层中的总循环数为n，总体使用<code>O(nlogn)</code>时间。<ul>
<li>在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为1和n-1的两个子数组，此时递归层数达到n，(平均)每层中的循环数为(n+1)n&#x2F;2,总体使用<code>O(n^2)</code>时间</li>
</ul>
</li>
<li>空间复杂度为<code>O(n)</code>,原地排序：在输入数组完全倒序的情况下，达到最差递归深度n，使用<code>O(n)</code>栈帧空间。排序操作是在原数组上进行的，未借助额外数组</li>
<li>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。例如[4,4,3,5]–&gt;[3,4,4,5]。相同元素4的相对顺序发生了改变</li>
</ol>
<h3 id="1-5-3-快速排序为什么快"><a href="#1-5-3-快速排序为什么快" class="headerlink" title="1.5.3 快速排序为什么快"></a>1.5.3 快速排序为什么快</h3><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因</p>
<ul>
<li>出现最差情况的概率很低：虽然快速排序的最差时间复杂度为<code>O(n^2)</code>，并没有归并排序稳定，但在绝大多数情况下，快速排序能在<code>O(nlogn)</code>的时间复杂度下运行</li>
<li>缓存使用效率：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性</li>
<li>复杂度的常数系数小：在上述三种算法中，快速排序的比较，赋值，交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似</li>
</ul>
<h3 id="1-5-4-基准数优化"><a href="#1-5-4-基准数优化" class="headerlink" title="1.5.4 基准数优化"></a>1.5.4 基准数优化</h3><ol>
<li>快速排序在某些输入下的时间效率可能降低。<ul>
<li>举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为n-1，右子数组长度为0。如此递归下去，每轮哨兵划分后都有一个子数组的长度为1，分治策略失效。快速排序退化为“冒泡排序”的近似形式</li>
</ul>
</li>
<li>为了尽量避免这种情况发生，我们可以“优化哨兵划分中的基准数的选取策略”。<ul>
<li>例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意</li>
</ul>
</li>
<li>需要注意的是，编程语言通常生成的都是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化</li>
<li>为了进一步改进，我们可以在数组中选取三个候选元素(通常为数组的首，尾，中点元素)，并将这三个候选元素的中位数(第二大)作为基准数。这样一来，基准数“既不太小，也不太大”的概率将大幅提升。<ul>
<li>当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至O(n)的概率大大降低<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">medianThree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;<span class="comment">//找到三个数中的中位数并返回索引</span></span><br><span class="line">   <span class="type">int</span> l=nums[left];</span><br><span class="line">   <span class="type">int</span> m=nums[mid];</span><br><span class="line">   <span class="type">int</span> r=nums[right];</span><br><span class="line">   <span class="keyword">if</span>((m&gt;=l&amp;&amp;r&gt;=m)||(m&lt;=l&amp;&amp;r&lt;=m))&#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基准数优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partitionPro</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="type">int</span> med=medianThree(nums,left,(left+right)/<span class="number">2</span>,right);<span class="comment">//选取三个候选元素的中位数</span></span><br><span class="line">   swap(nums,left,med);<span class="comment">//将中位数交换至数组最左端</span></span><br><span class="line">   <span class="type">int</span> i=left;</span><br><span class="line">   <span class="type">int</span> j=right;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;<span class="comment">//以nums[left]作为基准数</span></span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[j]&gt;=nums[left])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]&lt;=nums[left])&#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,j);</span><br><span class="line">   &#125;</span><br><span class="line">   swap(nums,i,left);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="1-5-5-尾递归优化"><a href="#1-5-5-尾递归优化" class="headerlink" title="1.5.5 尾递归优化"></a>1.5.5 尾递归优化</h3><ol>
<li>在某些输入下，快速排序可能占用空间较多。以完全有序的输入数组为例，设递归中的子数组长度为m，每轮哨兵划分操作都将产生长度为1的左子数组和长度为m-1的右子数组，这意味着每一层递归调用减少的问题规模非常小(只减少一个元素)，递归树的高度会达到n-1，此时需要使用O(n)大小的栈帧空间</li>
<li>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较这两个子数组的长度，仅对较短的子数组进行递归(将层的深度(递归)转化为单层的广度(循环))<ul>
<li>由于较短子数组的长度不会超过n&#x2F;2，因此这种方法能确保递归深度不超过logn，从而将最差空间复杂度优化至<code>O(logn)</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=left;<span class="type">int</span> j=right;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[j]&gt;=nums[left])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]&lt;=nums[left])&#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,j);</span><br><span class="line">   &#125;</span><br><span class="line">   swap(nums,left,i);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSortPro</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(right&gt;left)&#123;<span class="comment">//子数组长度为1时终止(递归终止条件)</span></span><br><span class="line">      <span class="type">int</span> i=partition(nums, left, right);<span class="comment">//每轮循环/递归都要更新基准数</span></span><br><span class="line">      <span class="keyword">if</span>(i-left&gt;right-i)&#123;<span class="comment">//寻找较小的子数组</span></span><br><span class="line">         quickSortPro(nums,i,right);<span class="comment">//递归较小数组</span></span><br><span class="line">         right=i-<span class="number">1</span>;<span class="comment">//更新边界 进循环</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         quickSortPro(nums,left,i);</span><br><span class="line">         left=i+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="1-6-归并排序"><a href="#1-6-归并排序" class="headerlink" title="1.6 归并排序"></a>1.6 归并排序</h2><ol>
<li>归并排序<code>merge sort</code>是一种基于“分治策略”的排序算法，包含“划分”和“合并”阶段<ul>
<li>划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题</li>
<li>合并阶段：当子数组长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_66.png" alt="img_66.png"></li>
</ul>
</li>
</ol>
<h3 id="1-6-1-算法流程"><a href="#1-6-1-算法流程" class="headerlink" title="1.6.1 算法流程"></a>1.6.1 算法流程</h3><ol>
<li>“划分阶段”从顶至底递归地将数组“从中点”切分为两个子数组<ul>
<li>1.计算数组中点<code>mid</code>，递归划分左子数组(区间<code>[left,mid]</code>)和右子数组(区间<code>[mid+1,right]</code>)</li>
<li>2.递归执行步骤1，直至子数组区间长度为1时终止</li>
</ul>
</li>
<li>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为1的子数组开始合并，合并阶段中的每个子数组都是有序的<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_67.png" alt="img_67.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_68.png" alt="img_68.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_69.png" alt="img_69.png"></li>
</ul>
</li>
<li>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的<ul>
<li>后序遍历：先递归左子树，再递归右子树，最后处理根节点</li>
<li>归并排序：先递归左子数组，再递归右子数组，最后处理合并<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="comment">//左子数组区间为[left,mid],右子数组区间为[mid+1,right]</span></span><br><span class="line">   <span class="comment">//创建一个临时数组tmp，用于存放合并后的结果</span></span><br><span class="line">   <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始化左子数组和右子数组的起始索引</span></span><br><span class="line">   <span class="type">int</span> i=left;</span><br><span class="line">   <span class="type">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">//当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<span class="comment">//双指针法</span></span><br><span class="line">      <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">         tmp[k++]=nums[i++];</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         tmp[k++]=nums[j++];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//因为每一个子数组都是局部有序的，经过上面的排序后多于的数组元素即为最大的数组元素，直接放到数组后面就可以了</span></span><br><span class="line">   <span class="comment">//将剩余元素复制到临时数组中</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">      tmp[k++]=nums[i++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">      tmp[k++]=nums[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将临时数组中的元素复制回原数组的对应区间</span></span><br><span class="line">   <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;tmp.length;k++)&#123;</span><br><span class="line">      nums[left+k]=tmp[k];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">      <span class="keyword">return</span>;<span class="comment">//终止递归的情况</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//划分阶段</span></span><br><span class="line">   <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//计算中点</span></span><br><span class="line">   mergeSort(nums, left, mid);<span class="comment">//递归左子数组</span></span><br><span class="line">   mergeSort(nums,mid+<span class="number">1</span>,right);<span class="comment">//递归右子数组</span></span><br><span class="line">   <span class="comment">//合并阶段</span></span><br><span class="line">   merge(nums,left,mid,right);<span class="comment">//合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="1-6-2-算法特性"><a href="#1-6-2-算法特性" class="headerlink" title="1.6.2 算法特性"></a>1.6.2 算法特性</h3><ol>
<li>时间复杂度为<code>O(nlogn)</code>，非自适应排序：划分产生高度为log n的递归树，每层合并的总操作数量为n，因此总体时间复杂度为<code>O(nlogn)</code></li>
<li>空间复杂度<code>O(n)</code>，非原地排序：递归深度为logn，使用<code>O(logn)</code>大小的栈帧空间。合并操作需要借助辅助数组实现，使用<code>O(n)</code>大小的额外空间</li>
<li>稳定排序：在合并过程中，相等元素的次序保持不变(合并操作时两个子数组都是朝一个方向线性遍历的)</li>
</ol>
<h3 id="1-6-3-链表排序"><a href="#1-6-3-链表排序" class="headerlink" title="1.6.3 链表排序"></a>1.6.3 链表排序</h3><ol>
<li>对于链表，归并排序相较于其他排序算法具有显著优势，可以将链表排序任务的空间复杂度优化至<code>O(1)</code><ul>
<li>划分阶段：可以使用“迭代”替代“递归”来实现链表划分工作，从而省区递归使用的栈帧空间</li>
<li>合并阶段：在链表中，节点增删操作仅需改变引用即可实现，因此合并阶段(将两个短有序链表合并为一个长有序链表)无须创建额外链表<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h2><ol>
<li>堆排序<code>heap sort</code>是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序<ul>
<li>1.输入数组并建立小顶堆，此时最小元素位于堆顶</li>
<li>2.不断执行出堆操作，依次记录出堆元素，即可得到从小到大的序列</li>
</ul>
</li>
<li>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式</li>
</ol>
<h3 id="1-7-1-算法流程"><a href="#1-7-1-算法流程" class="headerlink" title="1.7.1 算法流程"></a>1.7.1 算法流程</h3><ol>
<li>设数组的长度为n</li>
</ol>
<ul>
<li><ol>
<li>输入数组并建立大顶堆。完成后，最大元素位于堆顶</li>
</ol>
</li>
<li><ol start="2">
<li>将堆顶元素(第一个元素)与堆底元素(最后一个元素)交换。完成交换后，堆的长度减1，已排序元素数量加1<ul>
<li>类似与出堆操作，但是没有真正的删除该元素而是移动索引位置</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>从堆顶元素开始，从顶到底执行堆化操作(sift down)。完成堆化后，堆的性质得到修复</li>
</ol>
</li>
<li><ol start="4">
<li>循环执行第2步和第3步。循环n-1轮后，即可完成数组排序<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_70.png" alt="img_70.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_71.png" alt="img_71.png"></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_72.png" alt="img_72.png"></li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化“siftDown()”函数。值的注意的是，由于堆的有效长度会随着提取最大元素而减小，因此我们需要给“siftDown()”函数添加一个长度参数n，用于指定堆的当前有效长度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//初始化堆</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//((nums.length-1)-1)/2</span></span><br><span class="line">      siftDown(nums, nums.length, i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//有效长度(迭代有效长度)</span></span><br><span class="line">      swap(nums,<span class="number">0</span>,i-<span class="number">1</span>);<span class="comment">//首和有效区间的尾交换，即0和有效长度-1</span></span><br><span class="line">      siftDown(nums,i-<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//向下堆化，此时有效长度已经-1了，因为已经“出去一个”</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] heap,<span class="type">int</span> n,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">//找到最大节点</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">      <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (leftIndex &lt; n &amp;&amp; heap[leftIndex] &gt; heap[max]) &#123;</span><br><span class="line">         max = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rightIndex &lt; n &amp;&amp; heap[rightIndex] &gt; heap[max]) &#123;</span><br><span class="line">         max = rightIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右子节点的索引越界或是i即为最大</span></span><br><span class="line">      <span class="keyword">if</span> (max == i) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换</span></span><br><span class="line">      swap(heap,max,i);</span><br><span class="line">      <span class="comment">//迭代向下堆化</span></span><br><span class="line">      i=max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-7-2-算法特性"><a href="#1-7-2-算法特性" class="headerlink" title="1.7.2 算法特性"></a>1.7.2 算法特性</h3><ol>
<li>时间复杂度为<code>O(nlogn)</code>，非自适应排序：建堆操作使用O(n)时间。从堆中提取最大元素的时间复杂度为<code>O(logn)</code>(堆化)，共循环n-1轮</li>
<li>空间复杂度为<code>O(1)</code>，原地排序：几个指针变量使用O(1)空间。元素交换和堆化操作都是在原数组上进行的</li>
<li>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化</li>
</ol>
<h2 id="1-8-桶排序"><a href="#1-8-桶排序" class="headerlink" title="1.8 桶排序"></a>1.8 桶排序</h2><ol>
<li>前面几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越<code>O(nlogn)</code>。</li>
<li>接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶</li>
<li>桶排序<code>bucket sort</code>是“分治策略”的一个典型应用。它通过“设置一些具有大小顺序的桶”，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有元素合并</li>
</ol>
<h3 id="1-8-1-算法流程"><a href="#1-8-1-算法流程" class="headerlink" title="1.8.1 算法流程"></a>1.8.1 算法流程</h3><p>考虑一个长度为n的数组，其元素是范围[0,1)内的浮点数</p>
<ul>
<li><ol>
<li>初始化k个桶，将n个元素分配到k个桶中</li>
</ol>
</li>
<li><ol start="2">
<li>对每个桶分别执行排序(使用内置函数或其他排序算法)</li>
</ol>
</li>
<li><ol start="3">
<li>按照桶从小到大的顺序合并结果</li>
</ol>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_73.png" alt="img_73.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">double</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//建桶</span></span><br><span class="line">   <span class="type">int</span> k= nums.length/<span class="number">2</span>;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Double&gt;&gt; arrayLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">      arrayLists.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//把值放进不同的桶中</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">double</span> num : nums) &#123;</span><br><span class="line">      <span class="type">int</span> index=(<span class="type">int</span>)num*k;<span class="comment">//将值映射成桶的索引</span></span><br><span class="line">      arrayLists.get(index).add(num);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对每个桶进行排序</span></span><br><span class="line">   <span class="keyword">for</span> (ArrayList&lt;Double&gt; arrayList : arrayLists) &#123;</span><br><span class="line">      Collections.sort(arrayList);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历所有桶，合并结果</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (ArrayList&lt;Double&gt; arrayList : arrayLists) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Double v : arrayList) &#123;</span><br><span class="line">         nums[i++]=v;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-8-2-算法特性"><a href="#1-8-2-算法特性" class="headerlink" title="1.8.2 算法特性"></a>1.8.2 算法特性</h3><p>桶排序适用于处理体量很大的数据。例如，输入数据包含100万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成1000个桶，然后分别对每个桶进行排序，最后将结果合并</p>
<ul>
<li>时间复杂度为<code>O(n+k)</code>:假设元素在各个桶内平均分布，那么每个桶内的元素数量为 n&#x2F;k。假设排序单个桶使用O(n&#x2F;k log n&#x2F;k)的时间，则排序所有桶使用O(nlog n&#x2F;k)时间。当桶数量k比较大时，时间复杂度则趋向于<code>O(n)</code>。合并结果时需要遍历所有桶和元素，花费<code>O(n+k)</code>时间</li>
<li>自适应排序：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用O(n^2)时间</li>
<li>空间复杂度为<code>O(n+k)</code>，非原地排序：需要借助k的桶和n个元素的额外空间</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定</li>
</ul>
<h3 id="1-8-3-如何实现平均分配"><a href="#1-8-3-如何实现平均分配" class="headerlink" title="1.8.3 如何实现平均分配"></a>1.8.3 如何实现平均分配</h3><ol>
<li>桶排序的时间复杂度理论上可以达到O(n)，关键在于“将元素均匀分配到各个桶中”，因为实际数据往往不是均匀分布的。</li>
<li>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到3个桶中。分配完毕后，再将元素较多的桶继续划分为3个桶，直至所有桶中的元素数量大致相等</li>
<li>这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。</li>
<li>不一定要每轮将数据划分成3个桶，具体划分方式可根据数据特点灵活选择<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_74.png" alt="img_74.png"></li>
</ul>
</li>
<li>如果我们提前知道元素值的概率分布，则“可以根据数据概率分布设置每个桶的分界线”</li>
<li>数据分布不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_75.png" alt="img_75.png"></li>
</ul>
</li>
</ol>
<h2 id="1-9-计数排序"><a href="#1-9-计数排序" class="headerlink" title="1.9 计数排序"></a>1.9 计数排序</h2><ol>
<li>计数排序<code>counting sort</code>通过统计元素数量来实现排序，通常应用于整数数组</li>
<li>类似于 稀疏数组</li>
</ol>
<h3 id="1-9-1-简单实现"><a href="#1-9-1-简单实现" class="headerlink" title="1.9.1 简单实现"></a>1.9.1 简单实现</h3><p>先来看一个简单的例子。给定一个长度为n的数组nums，其中的元素都是“非负整数”，计数排序的整体流程为：</p>
<ul>
<li><ol>
<li>遍历数组，找出其中的最大数字，记为m，然后创建一个长度为m+1的辅助数组counter</li>
</ol>
</li>
<li><ol start="2">
<li>借助counter统计nums中各数字的出现次数，其中counter[num]对应数字num的出现次数。统计方法很简单，只需遍历nums，每轮将counter[num]+1即可</li>
</ol>
</li>
<li><ol start="3">
<li>由于counter的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，遍历counter，根据各数字出现次数从小到大填入nums即可</li>
</ol>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_76.png" alt="img_76.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] : max;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      counter[nums[i]]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt; counter.length;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;counter[i];j++)&#123;</span><br><span class="line">         nums[k++]=i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
计数排序与桶排序之间的联系：</li>
<li>从桶排序的角度看，我们可以将计数排序中的计数数组counter的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例</li>
</ul>
<h3 id="1-9-2-完整实现"><a href="#1-9-2-完整实现" class="headerlink" title="1.9.2 完整实现"></a>1.9.2 完整实现</h3><ol>
<li>如果输入数据是对象，而不是整型数据，那么上述步骤就失效了。<ul>
<li>假设输入数据是商品对象，我们想按照商品价格(类的成员变量)对商品进行排序，而上述算法只能给出价格的排序结果，而不能得到商品的排序结果</li>
</ul>
</li>
<li>得到原数据的排序结果—&gt;首先计算counter的“前缀和”<ul>
<li>索引i处的前缀和<code>perfix[i]</code>等于 数组前i个元素只和</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_77.png" alt="img_77.png"></li>
</ul>
</li>
<li>前缀和具有明确的意义，<code>prefix[num]-1</code>代表元素num在结果数组res中最后一次出现的索引<ul>
<li>这个信息非常关键，因为它告诉我们“各个元素应该出现在结果数组的哪个位置”</li>
</ul>
</li>
<li>接下来，我们倒叙遍历原数据nums的每个元素num，在每轮迭代中执行以下两步<ul>
<li><ol>
<li>将num填入数组res索引<code>prefix[num]-1</code>处</li>
</ol>
</li>
<li><ol start="2">
<li>令前缀和<code>prefix[num]</code>减小1，从而得到下次防止num的索引</li>
</ol>
</li>
</ul>
</li>
<li>遍历完成后，数组res中就是排序好的结果，最后使用res覆盖原数组nums即可<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSortPro</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//假定输入一个商品数组 ItemArray</span></span><br><span class="line">   <span class="comment">//由此得到其成员变量价格 的数组 PriceArray</span></span><br><span class="line">   <span class="comment">//对PriceArray中的元素进行计数排序得到prefix--&gt;元素插入位置</span></span><br><span class="line">   <span class="comment">//再遍历ItemArray得到 满足价格排序的 商品数组 且是稳定排序</span></span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] : max;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//得到counter数组</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      counter[nums[i]]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//得到prefix数组</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; counter.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      counter[i+<span class="number">1</span>]+=counter[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建存储结果的数组res</span></span><br><span class="line">   <span class="comment">//Item[] res;</span></span><br><span class="line">   <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">   <span class="comment">//关键步骤</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="type">int</span> num=nums[i];</span><br><span class="line">      <span class="comment">//res[counter[num]-1]=ItemArray[i]</span></span><br><span class="line">      res[counter[num]-<span class="number">1</span>]=nums[i];<span class="comment">//counter[num]得到该数据对应的prefix</span></span><br><span class="line">      counter[num]-=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用结果数组res覆盖原数组nums</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      nums[i]=res[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-9-3-算法特性"><a href="#1-9-3-算法特性" class="headerlink" title="1.9.3 算法特性"></a>1.9.3 算法特性</h3><ol>
<li>时间复杂度为<code>O(n+m)</code>：涉及遍历nums和counter，都使用线性时间</li>
<li>空间复杂度为<code>O(n+m)</code>，非原地排序：借助了长度分别为n和m的数组res和counter</li>
<li>稳定排序：由于向res中填充元素的顺序是“从右向左”的，因此倒序遍历nums可以避免改变相等元素之间的相对位置，从而实现稳定排序。<ul>
<li>实际上，正序遍历nums也可以得到正确的排序结果，但结果是非稳定的</li>
</ul>
</li>
</ol>
<h3 id="1-9-4-局限性"><a href="#1-9-4-局限性" class="headerlink" title="1.9.4 局限性"></a>1.9.4 局限性</h3><ol>
<li>计数排序只适用于非负整数。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。<ul>
<li>例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将所有数字转换为正数，排序完成后再转换回去</li>
</ul>
</li>
<li>计数排序适用于数据量大但数据范围较小的情况(n&gt;&gt;m)。<ul>
<li>例如，在上述示例中m不能太大，否则会占用过多空间。而当n&lt;&lt;m时，计数排序使用O(m)时间，可能比O(nlogn)的排序算法还要慢</li>
</ul>
</li>
</ol>
<h2 id="1-10-基数排序"><a href="#1-10-基数排序" class="headerlink" title="1.10 基数排序"></a>1.10 基数排序</h2><ol>
<li>上一节介绍了计数排序，它适用于数据量n较大但数据范围m较小的情况。<ul>
<li>假设我们需要对n&#x3D;10^6个学号进行排序，而学号是一个8位数字，这意味着数据范围m&#x3D;10^8非常大，使用计数排序需要分配大量内存空间</li>
<li>而基数排序可以避免这种情况</li>
</ul>
</li>
<li>基数排序<code>radix sort</code>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果</li>
</ol>
<h3 id="1-10-1-算法流程"><a href="#1-10-1-算法流程" class="headerlink" title="1.10.1 算法流程"></a>1.10.1 算法流程</h3><ol>
<li>以学号数据为例，假设数字的最低位是第1位，最高位是第8位。基数排序的流程如下<ul>
<li><ol>
<li>初始化位数k&#x3D;1</li>
</ol>
</li>
<li><ol start="2">
<li>对学号的第k位执行“计数排序”。完成后，数据会根据第k位从小到大排序</li>
</ol>
</li>
<li><ol start="3">
<li>将k增加1，然后返回步骤2，继续迭代，直到所有位都排序完成后结束<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素num的第k位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digit</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> exp)</span>&#123;</span><br><span class="line">   <span class="comment">//传入exp而非k可以避免重复执行昂贵的次方运算</span></span><br><span class="line">   <span class="keyword">return</span> (num/exp)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对元素num的第k为排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSortForDigit</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> exp)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//十进制最多就10个数</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> digit=digit(nums[i], exp);</span><br><span class="line">      counter[digit]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//得到prefix</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; counter.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      counter[i+<span class="number">1</span>]+=counter[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="type">int</span> digit=digit(nums[i], exp);</span><br><span class="line">      res[counter[digit]-<span class="number">1</span>]=nums[i];</span><br><span class="line">      counter[digit]--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      nums[i]=res[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] :max ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> exp=<span class="number">1</span>;exp&lt;=max;exp*=<span class="number">10</span>)&#123;</span><br><span class="line">      countingSortForDigit(nums,exp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li>为什么从最低位开始排序<ul>
<li>在连续的排序轮次中，后一轮的排序会覆盖前一轮排序的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位</li>
</ul>
</li>
</ol>
<h3 id="1-10-2-算法特性"><a href="#1-10-2-算法特性" class="headerlink" title="1.10.2 算法特性"></a>1.10.2 算法特性</h3><ol>
<li>相较于计数排序，基数排序适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位数不能过大<ul>
<li>例如，浮点数不适合使用基数排序，因为其位数k过大，可能导致时间复杂度O(nk)&gt;&gt;O(n^2)</li>
</ul>
</li>
<li>时间复杂度为<code>O(nk)</code>：设数据量为n，数据为d进制，最大位数为k，则对某一位执行计数排序时使用<code>O(n+d)</code>时间(遍历nums和counter)，排序所有k位使用<code>O((n+d)k)</code>时间<ul>
<li>通常情况下，d和k都相对较小，时间复杂度趋向O(n)</li>
</ul>
</li>
<li>空间复杂度为<code>O(n+d)</code>,非原地排序：与计数排序相同，基数排序需要借助长度为n和d的数组res和counter</li>
<li>稳定排序：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果</li>
</ol>
<h2 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h2><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ol>
<li>冒泡排序通过交换相邻元素来实现排序。通过添加一个flag来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到O(n)</li>
<li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为O(n^2)，但由于单元操作相对较少，因此在“小数据量”的排序任务中非常受欢迎</li>
<li>快速排序基于“哨兵划分”操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至O(n^2)。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到O(logn)</li>
<li>归并排序包括划分和合并两个阶段，典型的体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为O(n)；然而排序链表的空间复杂度可以优化至O(1)</li>
<li>桶排序包含三个步骤：数据分桶，桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配</li>
<li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并要求数据能够转换为正整数</li>
<li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_78.png" alt="img_78.png"></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io">chaojiwudidashuaige</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class9/">https://chaojiwudidashuaige492.github.io/2024/05/23/算法入门学习笔记/class9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaojiwudidashuaige492.github.io" target="_blank">超级无敌大帅哥</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法入门学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/" title="04哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">04哈希表</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class8/" title="08搜索/查找算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">08搜索/查找算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/" title="03栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">03栈与队列</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/" title="01数据的结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">01数据的结构</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">02数组与链表</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/" title="05二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">05二叉树</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">10分治算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/" title="11回溯算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">11回溯算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chaojiwudidashuaige</div><div class="author-info__description">Plan first,Then code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chaojiwudidashuaige492" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaojiwudidashuaige492@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">1.1 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E8%AF%84%E4%BB%B7%E7%BB%B4%E5%BA%A6"><span class="toc-text">1.1.1 评价维度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E7%90%86%E6%83%B3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">1.1.2 理想排序算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">1.2 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.2.1 算法特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">1.3 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.3.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-text">1.3.2 效率优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.3.3 算法特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">1.4 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.4.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.4.2 算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1.4.3 插入排序的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1.5 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.5.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.5.2 算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">1.5.3 快速排序为什么快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-%E5%9F%BA%E5%87%86%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">1.5.4 基准数优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96"><span class="toc-text">1.5.5 尾递归优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">1.6 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.6.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.6.2 算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">1.6.3 链表排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">1.7 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.7.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.7.2 算法特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">1.8 桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.8.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.8.2 算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D"><span class="toc-text">1.8.3 如何实现平均分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">1.9 计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-1-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.9.1 简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-2-%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.9.2 完整实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-3-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.9.3 算法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-4-%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.9.4 局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">1.10 基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">1.10.1 算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-2-%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-text">1.10.2 算法特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.11 小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-text">重点回顾</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/t/" title="t">t</a><time datetime="2024-05-23T10:28:39.000Z" title="发表于 2024-05-23 18:28:39">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/" title="01Git概念">01Git概念</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/" title="02GitHubDesktop">02GitHubDesktop</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/" title="03IDEA集成GitHub">03IDEA集成GitHub</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/" title="05Git命令">05Git命令</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By chaojiwudidashuaige</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>