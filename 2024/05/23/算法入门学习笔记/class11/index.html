<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>11回溯算法 | 超级无敌大帅哥</title><meta name="author" content="chaojiwudidashuaige"><meta name="copyright" content="chaojiwudidashuaige"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="回溯1.1 回溯算法 回溯算法backtracking algorithm是一种通过穷举来解决问题的方法。 回溯算法的核心思想是：从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到了解或者尝试了所有可能的选择都无法找到解为止 回溯算法通常采用“深度优先搜索”来遍历解空间。 在“二叉树”章节中，提到前序，中序，后序遍历都属于深度优先搜索。   利用前序遍历构造一个回溯">
<meta property="og:type" content="article">
<meta property="og:title" content="11回溯算法">
<meta property="og:url" content="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/index.html">
<meta property="og:site_name" content="超级无敌大帅哥">
<meta property="og:description" content="回溯1.1 回溯算法 回溯算法backtracking algorithm是一种通过穷举来解决问题的方法。 回溯算法的核心思想是：从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到了解或者尝试了所有可能的选择都无法找到解为止 回溯算法通常采用“深度优先搜索”来遍历解空间。 在“二叉树”章节中，提到前序，中序，后序遍历都属于深度优先搜索。   利用前序遍历构造一个回溯">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-23T11:55:27.588Z">
<meta property="article:author" content="chaojiwudidashuaige">
<meta property="article:tag" content="算法入门学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaojiwudidashuaige492.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chaojiwudidashuaige","link":"链接: ","source":"来源: 超级无敌大帅哥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '11回溯算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 19:55:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="超级无敌大帅哥"><span class="site-name">超级无敌大帅哥</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">11回溯算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T11:55:27.588Z" title="更新于 2024-05-23 19:55:27">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="11回溯算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="1-1-回溯算法"><a href="#1-1-回溯算法" class="headerlink" title="1.1 回溯算法"></a>1.1 回溯算法</h2><ol>
<li>回溯算法<code>backtracking algorithm</code>是一种通过穷举来解决问题的方法。</li>
<li>回溯算法的核心思想是：从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到了解或者尝试了所有可能的选择都无法找到解为止</li>
<li>回溯算法通常采用“深度优先搜索”来遍历解空间。<ul>
<li>在“二叉树”章节中，提到前序，中序，后序遍历都属于深度优先搜索。</li>
</ul>
</li>
<li>利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理<ul>
<li>例题1：给定一个二叉树，搜索并记录所有值为7的节点，返回节点列表</li>
<li>对于该题，通过前序遍历这棵树，并判断当前节点的值是否为7，如果是则将该节点的值加入结果列表res之中</li>
<li><pre><code class="java">//示例代码
/* 前序遍历：例题一 */
public static void preOrder(TreeNode root) &#123;
    if (root == null) &#123;
        return;
    &#125;
    if (root.val == 7) &#123;
    // 记录解
        res.add(root);
    &#125;
    preOrder(root.left);
    preOrder(root.right);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    - ![img_91.png](/images/AlgoGettingStart/img_91.png)</span><br><span class="line">### 1.1.1 尝试与回退</span><br><span class="line">1. 之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。</span><br><span class="line">    - 当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择</span><br><span class="line">2. 对于上面的例题，访问每个节点都代表一次“尝试”，而越过叶节点或返回父节点的return则表示“回退”</span><br><span class="line">3. 值的说明的是：“回退并不仅仅包括函数返回”</span><br><span class="line">4. 例题2:在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径</span><br><span class="line">   - 在例题1代码的基础上，需要添加一个列表path记录访问过的节点的路径。当访问到值为7的节点时，则复制path并添加进结果列表res。遍历完成后，res中保存的就是所有的解</span><br><span class="line">   - ```java</span><br><span class="line">     public static void preOrder(TreeNode root)&#123;</span><br><span class="line">         if(root==null)&#123;</span><br><span class="line">             return ;</span><br><span class="line">         &#125;</span><br><span class="line">         path.add(root);</span><br><span class="line">         if(root.val==7)&#123;</span><br><span class="line">             res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">         &#125;</span><br><span class="line">         preOrder(root.left);</span><br><span class="line">         preOrder(root.right);  </span><br><span class="line">         //回退</span><br><span class="line">         path.remove(path.size()-1);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>在每次“尝试”中，我们通过将当前节点添加进path来记录路径；而在“回退”前，我们需要将该节点从path中弹出，以恢复本次尝试之前的状态</li>
</ol>
<h3 id="1-1-2-剪枝"><a href="#1-1-2-剪枝" class="headerlink" title="1.1.2 剪枝"></a>1.1.2 剪枝</h3><ol>
<li>复杂的回溯问题通常包含一个或多个约束条件，<em><strong>约束条件通常可用于“剪枝”</strong></em></li>
<li>例题3:在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3的节点<ul>
<li>为了满足以上“约束条件”，我们需要添加“剪枝操作”：在搜索过程中，若遇到值为3的节点，则提前返回，不再继续搜索</li>
<li><pre><code class="java">public static void preOrder(TreeNode root)&#123;
    //剪枝
    if(root==null||root.val==3)&#123;
        return ;
    &#125;
    path.add(root);
    if(root.val==7)&#123;
        res.add(new ArrayList&lt;&gt;(path));
    &#125;
    preOrder(root.left);
    preOrder(root.right);
    path.remove(path.size()-1);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. “剪枝”是一个非常形象的名词。即在搜索过程中，我们“剪掉”了不满足约束条件的搜索分支，避免许多无意义的尝试，从而提高了搜索效率</span><br><span class="line">   - ![img_92.png](/images/AlgoGettingStart/img_92.png)</span><br><span class="line">### 1.1.3 框架代码</span><br><span class="line">1. 尝试将回溯的“尝试，回退，剪枝”的主体框架提炼出来，提高代码的通用性</span><br><span class="line">```java</span><br><span class="line">//示例代码</span><br><span class="line">//state表示问题的当前状态，choices表示当前状态下可以做出的选择</span><br><span class="line">public static void backTrack(State state, List&lt;Choice&gt; choices,List&lt;State&gt; res) &#123;</span><br><span class="line">    //判断是否为解</span><br><span class="line">   if(isSolution(state))&#123;</span><br><span class="line">       //记录解</span><br><span class="line">      recordSolution(state,res);</span><br><span class="line">      //不再继续搜索(看情况而定)</span><br><span class="line">      return ;</span><br><span class="line">   &#125;</span><br><span class="line">   //遍历所有选择</span><br><span class="line">   for(Choice choice:choices)&#123;</span><br><span class="line">       //剪枝：判断选择是否合法</span><br><span class="line">      if(isValid(state,choice))&#123;</span><br><span class="line">          //尝试：做出选择，更新状态</span><br><span class="line">         makeChoice(state,choice);</span><br><span class="line">         backTrack(state,choices,res);</span><br><span class="line">         //回退：撤销选择，恢复到之前的状态</span><br><span class="line">         undoChoice(state,choice);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>基于框架代码来解决例题三。状态state为节点遍历路径，选择choice为当前节点的左子节点和右子节点，结果res是路径列表<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSolution</span><span class="params">(List&lt;BNode&gt; state)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> !state.isEmpty()&amp;&amp;state.get(state.size()-<span class="number">1</span>).val==<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordSolution</span><span class="params">(List&lt;BNode&gt; state,List&lt;List&lt;BNode&gt;&gt; res)</span>&#123;</span><br><span class="line">   res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(BNode choice)</span>&#123;</span><br><span class="line">   <span class="comment">//“剪枝”</span></span><br><span class="line">   <span class="keyword">if</span>(choice.val==<span class="number">3</span>||choice==<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undoChoice</span><span class="params">(List&lt;BNode&gt; state)</span>&#123;</span><br><span class="line">   state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">completeChoice</span><span class="params">(List&lt;BNode&gt; state,BNode choice)</span>&#123;<span class="comment">//完成选择</span></span><br><span class="line">   state.add(choice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;BNode&gt; state,List&lt;BNode&gt; choices,List&lt;List&lt;BNode&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isSolution(state))&#123;</span><br><span class="line">      recordSolution(state,res);</span><br><span class="line">      <span class="comment">//这里不return，因为还要继续向下遍历</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (BNode choice : choices) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isValid(choice))&#123;<span class="comment">//判断选择是否满足约束条件</span></span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         completeChoice(state,choice);<span class="comment">//makeChoice，完成选择，更新状态</span></span><br><span class="line">         backTrack(state, Arrays.asList(choice.left,choice.right),res);<span class="comment">//尝试</span></span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         undoChoice(state);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>许多回溯问题可以在该框架下解决。我们只需根据具体问题来定义“state”和“choices”，并实现框架中的各个方法即可</li>
</ol>
<h3 id="1-1-4-常用术语"><a href="#1-1-4-常用术语" class="headerlink" title="1.1.4 常用术语"></a>1.1.4 常用术语</h3><p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_93.png" alt="img_93.png"></p>
<h3 id="1-1-5-优点与局限性"><a href="#1-1-5-优点与局限性" class="headerlink" title="1.1.5 优点与局限性"></a>1.1.5 优点与局限性</h3><ol>
<li>回溯算法本质上是一种“深度优先搜索”算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，且在合理的剪枝下，具有很高的效率</li>
<li>然而，在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受<ul>
<li>时间：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶</li>
<li>空间：在递归调用中需要保存当前的状态(例如路径，用于剪枝的辅助变量等)，当深度很大时，空间需求可能会变得很大</li>
</ul>
</li>
<li>即便如此，回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案。<ul>
<li>对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。</li>
<li>在这种情况下，关键是如何优化效率，常见的效率优化方法有两种<ul>
<li>剪枝：避免搜索那些肯定不会产生解的路径，从而节省时间和空间</li>
<li>启发式搜索：在搜索过程中引入一些策略或估计值，从而优先搜索最有可能产生有效解的路径</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-1-6-回溯典型例题"><a href="#1-1-6-回溯典型例题" class="headerlink" title="1.1.6 回溯典型例题"></a>1.1.6 回溯典型例题</h3><p>回溯算法可用于解决许多 搜索问题，约束满足问题和组合优化问题</p>
<ol>
<li>搜索问题：这类问题的目标是 找到满足特定条件的解决方案<ul>
<li>全排列问题：给定一个集合，求出其所有可能的排列组合</li>
<li>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集</li>
</ul>
</li>
<li>约束满足问题：这类问题的目标是 找到满足所有约束条件的解<ul>
<li>n皇后：在n*n的棋盘上放置n个皇后，使得它们互不攻击</li>
<li>数独：在9<em>9的网格中填入数字1~9，使得每行，每列和每3</em>3子网格中的数字不重复</li>
<li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</li>
</ul>
</li>
<li>组合优化问题：这类问题的目标是 在一个组合空间中找到满足某些条件的最优解<ul>
<li>0-1背包问题：给定一组物品和一个背包，每个物品具有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大</li>
<li>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径</li>
<li>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之前都有边相连</li>
</ul>
</li>
<li>请注意：对于许多组合优化问题，回溯不是最优解决方案<ul>
<li>0-1背包问题通常使用动态规划解决，以达到更高的时间效率</li>
<li>旅行商是一个著名的NP-Hard问题，常用解法有遗传算法和蚁群算法等</li>
<li>最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决</li>
</ul>
</li>
</ol>
<h2 id="1-2-全排列问题"><a href="#1-2-全排列问题" class="headerlink" title="1.2 全排列问题"></a>1.2 全排列问题</h2><ol>
<li>全排列问题是回溯算法的一个典型应用，它的定义是：<em><strong>在给定一个集合(如一个数组或字符串)的情况下，找出其中元素的所有可能的排列</strong></em></li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_95.png" alt="img_95.png"></li>
</ol>
<h3 id="1-2-1-无相等元素的情况"><a href="#1-2-1-无相等元素的情况" class="headerlink" title="1.2.1 无相等元素的情况"></a>1.2.1 无相等元素的情况</h3><p>例题：输入一个整数数组，其中不包含重复元素，返回所有可能的排列</p>
<ol>
<li>从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果<ul>
<li>假设输入数组为[1,2,3]，如果我们先选择1，再选择3，最后选择2，则获得排列[1,3,2]。</li>
<li>回退表示撤销一个选择，之后继续尝试其他选择</li>
</ul>
</li>
<li>从回溯代码的角度看，候选集合choices是输入数组中的所有元素，状态state是直至目前已被选择的元素。<ul>
<li>请注意，每个元素只允许被选择一次，因此state中的所有元素都应该是唯一的</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_96.png" alt="img_96.png"></li>
</ol>
<h4 id="1-2-1-1-重复选择剪枝"><a href="#1-2-1-1-重复选择剪枝" class="headerlink" title="1.2.1.1 重复选择剪枝"></a>1.2.1.1 重复选择剪枝</h4><ol>
<li>为了实现每个元素只被选择一次，我们考虑引入一个布尔型数组selected，其中<code>selected[i]</code>表示<code>choices[i]</code>是否已被选择，并基于它实现以下剪枝操作<ul>
<li>在做出选择choices[i]后，我们就讲selected[i]赋值为true，代表它已被选择</li>
<li>遍历选择列表choices时，跳过所有已被选择的节点，即剪枝</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_97.png" alt="img_97.png"></li>
<li>如图所示，该剪枝操作将搜索空间大小从O(n^n)减小至O(n!)</li>
</ul>
</li>
</ol>
<h4 id="1-2-1-2-代码实现"><a href="#1-2-1-2-代码实现" class="headerlink" title="1.2.1.2 代码实现"></a>1.2.1.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),nums,<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length],res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state.size()==choices.length)&#123;<span class="comment">//长度相等</span></span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> choice=choices[i];</span><br><span class="line">      <span class="keyword">if</span>(!selected[i])&#123;<span class="comment">//没被选择,剪枝</span></span><br><span class="line">         selected[i]=<span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         state.add(choice);</span><br><span class="line">         backTrack(state,choices,selected,res);</span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         selected[i]=<span class="literal">false</span>;</span><br><span class="line">         state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-考虑相等元素的情况"><a href="#1-2-2-考虑相等元素的情况" class="headerlink" title="1.2.2 考虑相等元素的情况"></a>1.2.2 考虑相等元素的情况</h3><p>例题：输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列</p>
<ol>
<li>假设输入数组为[1,1,2]。上述方法生成的排列有一半是重复的<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_98.png" alt="img_98.png"></li>
</ul>
</li>
<li>如何去除重复的排列：最直接的，考虑借助一个哈希表，直接对排列结果进行去重。然而这样做不够优雅，因为生成重复排列的搜索分支没有必要，应当提前识别并剪枝，这样可以进一步提升算法效率</li>
</ol>
<h4 id="1-2-2-1-相等元素剪枝"><a href="#1-2-2-1-相等元素剪枝" class="headerlink" title="1.2.2.1 相等元素剪枝"></a>1.2.2.1 相等元素剪枝</h4><ol>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_99.png" alt="img_99.png"><ul>
<li>在第一轮中，选择1或1是等价的，在这两个选择之下生成的所有排列都是重复的。因此应该把其中一个1剪枝</li>
<li>在第一轮选择2之后，第二轮选择中的1和1也会产生重复分支，因此也应将第二轮的1剪枝</li>
</ul>
</li>
<li>从本质上看，我们的目标是在某一轮选择中，保证多个相等的元素仅被选择一次</li>
</ol>
<h4 id="1-2-2-2-代码实现"><a href="#1-2-2-2-代码实现" class="headerlink" title="1.2.2.2 代码实现"></a>1.2.2.2 代码实现</h4><p>在上一题的代码基础上，我们考虑在每一轮选择中开启一个哈希表duplicated(重复的)，用于记录该轮中已经尝试过的元素，并将重复元素剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),nums,<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length],res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state.size()==choices.length)&#123;<span class="comment">//长度相等</span></span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   HashSet&lt;Integer&gt; duplicated = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> choice=choices[i];</span><br><span class="line">      <span class="keyword">if</span>(!selected[i]&amp;&amp;!duplicated.contains(choice))&#123;<span class="comment">//没被选择,剪枝</span></span><br><span class="line">         selected[i]=<span class="literal">true</span>;</span><br><span class="line">         duplicated.add(choice);</span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         state.add(choice);</span><br><span class="line">         backTrack(state,choices,selected,res);</span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         selected[i]=<span class="literal">false</span>;</span><br><span class="line">         state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>时间复杂度为<code>O(n!n)</code>：假设元素两两之间互不相同，则n个元素共有n!中排列(阶乘)；在记录结果时，需要复制长度为n的列表，需要O(n)的时间，因此时间复杂度为O(n!n)</li>
<li>空间复杂度为<code>O(n^2)</code>：最大递归深度为n，使用O(n)栈帧空间。selected使用O(n)空间。同一时刻最多共有n个duplicated，使用O(n^2)空间</li>
</ol>
<h4 id="1-2-2-3-两种剪枝对比"><a href="#1-2-2-3-两种剪枝对比" class="headerlink" title="1.2.2.3 两种剪枝对比"></a>1.2.2.3 两种剪枝对比</h4><p>虽然，selected和duplicated都用于剪枝，但两者的目标不同</p>
<ul>
<li>重复选择剪枝：整个搜索过程中只有一个selected。它记录的是当前状态中包含哪些元素，其作用是避免某个元素在state中重复出现<ul>
<li>作用在纵向的递归路线上进行剪枝</li>
</ul>
</li>
<li>相等元素剪枝：每轮选择(每个调用的backtrack方法)都包含一个duplicated。它记录的是在本轮遍历(for循环)中哪些元素已被选择过，其作用是保证相等元素只被选择过一次<ul>
<li>作用在横向的迭代路线上进行剪枝</li>
</ul>
</li>
</ul>
<p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_100.png" alt="img_100.png"></p>
<h2 id="1-3-子集和问题"><a href="#1-3-子集和问题" class="headerlink" title="1.3 子集和问题"></a>1.3 子集和问题</h2><h3 id="1-3-1-无重复元素的情况"><a href="#1-3-1-无重复元素的情况" class="headerlink" title="1.3.1 无重复元素的情况"></a>1.3.1 无重复元素的情况</h3><p>例题1:给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复的组合</p>
<ul>
<li>例如，输入集合{3,4,5}和目标整数9，解为{3,3,3},{4,5}。需要注意以下两点<ul>
<li>输入集合中的元素可以被无限次重复选取</li>
<li>子集不区分元素顺序，比如{4,5}和{5,4}是同一个子集</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-1-参考全排列解法"><a href="#1-3-1-1-参考全排列解法" class="headerlink" title="1.3.1.1 参考全排列解法"></a>1.3.1.1 参考全排列解法</h4><ol>
<li>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于target时，就将子集记录至结果列表</li>
<li>而与全排列不同的是，本题集合中的元素可以被无限次选取，因此无须借助selected布尔列表来记录元素是否已被选择<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">//子集和等于target时，记录解</span></span><br><span class="line">    <span class="keyword">if</span>(total==target)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">        <span class="comment">//剪枝，如果total+choice&gt;target，直接continue</span></span><br><span class="line">       <span class="keyword">if</span>(total+choices[i]&gt;target)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尝试</span></span><br><span class="line">       state.add(choices[i]);</span><br><span class="line">       backTrack(state,target,total+choices[i],choices,res);</span><br><span class="line">       <span class="comment">//回退</span></span><br><span class="line">       state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">    backTrack(state,target,total,nums,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>向以上代码输入数组[3,4,5]和目标元素9，输出结果为[3,3,3],[4,5],[5,4]。虽然成功找出了所有和为9的子集，但其中存在重复的子集[4,5]和[5,4]<ul>
<li>这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_101.png" alt="img_101.png"></li>
<li>先选4后选5 和 先选5后选4 是不同的分支，但对应同一个子集</li>
</ul>
</li>
<li>为了去除重复子集，一种直接的思路是对结果列表进行去重。但是这个方法效率很低，有两方面原因<ul>
<li>当数组元素较多，尤其是target较大时，搜索过程会产生大量的重复子集</li>
<li>比较子集(数组)的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同</li>
</ul>
</li>
</ol>
<h4 id="1-3-1-2-重复子集剪枝"><a href="#1-3-1-2-重复子集剪枝" class="headerlink" title="1.3.1.2 重复子集剪枝"></a>1.3.1.2 重复子集剪枝</h4><ol>
<li>考虑在搜索过程中通过剪枝进行去重。</li>
<li>重复子集是在 以不同顺序选择数组元素时产生的<ul>
<li>当第一轮和第二轮分别选择3和4时，会生成包含这两个元素的所有子集，记为[3,4..]</li>
<li>之后，当第一轮选择4时，则第二轮应该跳过3，因为该选择产生的子集[4,3…]和第1步中生成的子集完全重复</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_102.png" alt="img_102.png"></li>
<li>总结来看，给定输入数组[x1,x2,x3,x4…,xn]，搜索过程中的选择序列为[Xi1,Xi2,….Xin]，则该选择序列需要满足<code>i1&lt;=i2&lt;=...&lt;=in</code>(递归纵向而言的)</li>
</ol>
<h4 id="1-3-1-3-代码实现"><a href="#1-3-1-3-代码实现" class="headerlink" title="1.3.1.3 代码实现"></a>1.3.1.3 代码实现</h4><ol>
<li>为了实现该剪枝，初始化变量start，用于指示遍历起始点。当做出选择Xi后，设定下一轮从索引i开始遍历。<ul>
<li>这样做就可以让选择序列满足i1&lt;&#x3D;i2&lt;&#x3D;…&lt;&#x3D;im,从而保证子集唯一</li>
</ul>
</li>
<li>除此之外，还对代码进行了以下两项优化<ul>
<li>在开启搜索前，现将数据nums排序。在遍历所有选择时，当子集和超过target时直接结束循环，因为后面的元素更大，其子集和一定超过taget</li>
<li>省区元素和 变量total，通过在target上执行剑法来统计元素和，当target等于0时记录解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state,<span class="type">int</span> target,<span class="type">int</span> start,<span class="type">int</span>[] choices,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt; choices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target-choices[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//“尝试”</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        backTrack(state,target-choices[i],i,choices,res);</span><br><span class="line">        <span class="comment">//“回退”</span></span><br><span class="line">       state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backTrack(state,target,start,nums,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_103.png" alt="img_103.png"></li>
</ul>
</li>
</ol>
<h3 id="1-3-2-考虑重复元素的情况"><a href="#1-3-2-考虑重复元素的情况" class="headerlink" title="1.3.2 考虑重复元素的情况"></a>1.3.2 考虑重复元素的情况</h3><p>问题：给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组可能“包含重复元素”，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合</p>
<ol>
<li>相比于上题，本题的输入数组可能包含重复元素，这引入了新的问题。例如，给定数组[4,4,5]和目标元素9，则现有代码的输出结果为[4,5]和[4,5]，出现了重复子集</li>
<li>造成这种重复的原因是相等元素在某轮中被多次选择<ul>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_104.png" alt="img_104.png"></li>
</ul>
</li>
</ol>
<h4 id="1-3-2-1-相等元素剪枝"><a href="#1-3-2-1-相等元素剪枝" class="headerlink" title="1.3.2.1 相等元素剪枝"></a>1.3.2.1 相等元素剪枝</h4><ol>
<li>为解决此问题，我们需要限制相等元素在每一轮中只能被选择一次。实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。<ul>
<li>这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过了，因此直接跳过当前元素(剪枝)</li>
</ul>
</li>
<li>与此同时，本题规定每个数组元素只能被选择一次。幸运的是，我们也可以利用变量start来满足该约束：当做出选择Xi后，设定下一轮从索引i+1开始向后遍历。这样可以避免重复选择元素</li>
</ol>
<h4 id="1-3-2-2-代码实现"><a href="#1-3-2-2-代码实现" class="headerlink" title="1.3.2.2 代码实现"></a>1.3.2.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      state.add(choices[i]);</span><br><span class="line">      backTrack(state, target - choices[i], i + <span class="number">1</span>, choices, res);</span><br><span class="line">      state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumII</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   Arrays.sort(nums);</span><br><span class="line">   backTrack(state,target,start,nums,res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_105.png" alt="img_105.png"></p>
<h2 id="1-4-N皇后问题"><a href="#1-4-N皇后问题" class="headerlink" title="1.4 N皇后问题"></a>1.4 N皇后问题</h2><p>问题：根据国际象棋的规则，皇后可以攻击与其处于同一行，一列或一条斜线上的棋子。给定n个皇后和一个n*n大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案</p>
<ol>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_106.png" alt="img_106.png"><ul>
<li>从回溯算法的角度看，n*n大小的棋盘共有n^2个格子，给出了所有的选择choices。</li>
<li>在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘状态就是state</li>
</ul>
</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_107.png" alt="img_107.png"><ul>
<li>本题的三个约束条件：多个皇后不能在同一行，同一列，同一条对角线上。</li>
<li>对角线分为主对角线和辅对角线两种</li>
</ul>
</li>
</ol>
<h3 id="1-4-1-逐行放置策略"><a href="#1-4-1-逐行放置策略" class="headerlink" title="1.4.1 逐行放置策略"></a>1.4.1 逐行放置策略</h3><ol>
<li>皇后的数量和棋盘的行数都为n，因此我们容易得到一个推论：棋盘每行都允许且只允许放置一个皇后</li>
<li>也就是说，可以采取逐行放置策略：从第一行开始，在每行放置一个皇后，直至最后一行结束</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_108.png" alt="img_108.png"></li>
<li>从本质上看，逐行放置策略起到了剪枝的作用，它避免了同一行出现多个皇后的所有搜索分治</li>
</ol>
<h3 id="1-4-2-列与对角线剪枝"><a href="#1-4-2-列与对角线剪枝" class="headerlink" title="1.4.2 列与对角线剪枝"></a>1.4.2 列与对角线剪枝</h3><ol>
<li>为了满足列约束，可以利用一个长度为n的布尔型数组cols记录每一列是否有皇后。在每次决定放置前，我们通过cols将已有皇后的列进行剪枝，并在回溯中动态更新cols的状态</li>
<li>对角线上所有格子的row-col为恒定值，辅对角线上所有鸽子的row+col是恒定值</li>
<li>因此可以借助布尔型数组diags1和diags2记录主对角线和辅对角线上是否有皇后</li>
<li><img src="/img/loading.gif" data-original="/images/AlgoGettingStart/img_109.png" alt="img_109.png"></li>
</ol>
<h3 id="1-4-3-代码实现"><a href="#1-4-3-代码实现" class="headerlink" title="1.4.3 代码实现"></a>1.4.3 代码实现</h3><p>n维方阵中row-col的范围是[-n+1,n-1]，row+col的范围是[0,2n-2]，所以主对角线和辅对角线的数量都为2n-1，即数组diags1和diags2的长度都为2n-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   List&lt;List&lt;List&lt;String&gt;&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;List&lt;String&gt;&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      ArrayList&lt;String&gt; col = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">         col.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      state.add(col);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">   <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">   <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">   backTrack(<span class="number">0</span>,n,state,res,cols,diags1,diags2);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state,</span></span><br><span class="line"><span class="params">                             List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,<span class="type">boolean</span>[] cols,<span class="type">boolean</span>[] diags1,<span class="type">boolean</span>[] diags2)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">      List&lt;List&lt;String&gt;&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (List&lt;String&gt; strings : state) &#123;</span><br><span class="line">         tmp.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(strings));</span><br><span class="line">      &#125;</span><br><span class="line">      res.add(tmp);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">      <span class="type">int</span> diag1=row-col+n-<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> diag2=row+col;</span><br><span class="line">      <span class="keyword">if</span>(!(cols[col]||diags1[diag1]||diags2[diag2]))&#123;</span><br><span class="line">         state.get(row).set(col,<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">         cols[col]=diags1[diag1]=diags2[diag2]=<span class="literal">true</span>;</span><br><span class="line">         backTrack(row+<span class="number">1</span>,n,state,res,cols,diags1,diags2);</span><br><span class="line">         cols[col]=diags1[diag1]=diags2[diag2]=<span class="literal">false</span>;</span><br><span class="line">         state.get(row).set(col,<span class="string">&quot;#&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>逐行放置n次，考虑列约束则从第一行到最后一行分别有n,n-1,…,2,1个选择，使用O(n!)时间。当记录解时，需要复制矩阵并添加进res，复制操作使用O(n^2)时间。因此，总体时间复杂度为<code>O(n^2n!)</code><ul>
<li>实际上，根据对角线约束的剪枝也能够大幅缩小搜索空间，因而搜索效率往往优于以上时间复杂度</li>
</ul>
</li>
<li>数据state使用O(n^2)空间，数据cols,diags1,diags2皆使用<code>O(n)</code>空间。最大递归深度为n，使用O(n)栈帧空间。因此空间复杂度为O(n^2)</li>
</ol>
<h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><ol>
<li>回溯算法本质是穷举法，通过对解空间进行深度优先遍历来寻找符合条件的解。在搜索过程中，遇到满足条件的解则记录，直至找到所有解或遍历完成后结束</li>
<li>回溯算法的搜索过程包括尝试和回退两个部分。它通过深度优先搜索来尝试各种选择，当遇到不满足约束条件的情况时，则撤销上一步的选择，退回到之前的状态，并继续尝试其他选择。尝试与回退是两个 方向相反的操作</li>
<li>回溯问题通常包含多个约束条件，它们可用于实现剪枝操作。剪枝可以提前结束不必要的搜索分支，大幅提升搜索效率</li>
<li>回溯算法主要可用于解决搜索问题和约束满足问题。组合优化问题虽然可以用回溯算法解决，但往往存在效率更高或效果更好的解法</li>
<li>全排列问题旨在搜索给定集合元素的所有可能的排列。借助一个数组来记录每个元素是否被选择,剪掉重复选择同一元素的搜索分支，确保每个元素只被选择一次</li>
<li>在全排列问题中，如果集合中存在重复元素，则最终结果会出现重复排列。需要约束相等元素在每轮中只能被选择一次，这通常借助一个哈希表来实现</li>
<li>子集和问题的目标是在给定集合中找到和为目标值的所有子集。集合不区分元素顺序，而搜索过程会输出所有顺序的结果，产生重复子集。我们在回溯前将数据进行排序，并设置一个变量来指示每一轮遍历的起始点，从而将产生重复子集的搜索分支进行剪枝</li>
<li>对于子集和问题，数组中的相等元素会产生重复集合。我们利用数组已排序的前置条件，通过判断相邻元素是否相等实现剪枝，从而确保相等元素在每轮中只能被选中一次</li>
<li>n皇后问题旨在寻找将n个皇后放置到n*n尺寸棋盘上的方案，要求所有皇后两两之间无法攻击对方。该问题的约束条件有 行约束，列约束，主对角线和辅对角线约束。为满足行约束，我们采用按行放置的策略，保证每行只放置一个皇后</li>
<li>列约束和对角线约束的处理方式类似。对于列约束，我们利用一个数组来记录每一列是否有皇后，从而指示选中的格子是否合法。对于对角线约束，我们借助两个数组来分别记录该对角线上是否存在皇后，难点在于找处在同一主(副)对角线上的格子满足的索引规律</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io">chaojiwudidashuaige</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaojiwudidashuaige492.github.io/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/">https://chaojiwudidashuaige492.github.io/2024/05/23/算法入门学习笔记/class11/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaojiwudidashuaige492.github.io" target="_blank">超级无敌大帅哥</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法入门学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">10分治算法</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/" title="04哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">04哈希表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/" title="03栈与队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">03栈与队列</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/" title="01数据的结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">01数据的结构</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/" title="02数组与链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">02数组与链表</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/" title="05二叉树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">05二叉树</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/" title="10分治算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">10分治算法</div></div></a></div><div><a href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/" title="04哈希表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">04哈希表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chaojiwudidashuaige</div><div class="author-info__description">Plan first,Then code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chaojiwudidashuaige492" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaojiwudidashuaige492@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">1.1 回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E5%89%AA%E6%9E%9D"><span class="toc-text">1.1.2 剪枝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-text">1.1.4 常用术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-%E4%BC%98%E7%82%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.1.5 优点与局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-%E5%9B%9E%E6%BA%AF%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">1.1.6 回溯典型例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 全排列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%97%A0%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.2.1 无相等元素的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-1-%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%89%AA%E6%9E%9D"><span class="toc-text">1.2.1.1 重复选择剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.1.2 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E8%80%83%E8%99%91%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.2.2 考虑相等元素的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-1-%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E5%89%AA%E6%9E%9D"><span class="toc-text">1.2.2.1 相等元素剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.2.2 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-3-%E4%B8%A4%E7%A7%8D%E5%89%AA%E6%9E%9D%E5%AF%B9%E6%AF%94"><span class="toc-text">1.2.2.3 两种剪枝对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-text">1.3 子集和问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.3.1 无重复元素的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-1-%E5%8F%82%E8%80%83%E5%85%A8%E6%8E%92%E5%88%97%E8%A7%A3%E6%B3%95"><span class="toc-text">1.3.1.1 参考全排列解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-2-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%9B%86%E5%89%AA%E6%9E%9D"><span class="toc-text">1.3.1.2 重复子集剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.1.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E8%80%83%E8%99%91%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1.3.2 考虑重复元素的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-%E7%9B%B8%E7%AD%89%E5%85%83%E7%B4%A0%E5%89%AA%E6%9E%9D"><span class="toc-text">1.3.2.1 相等元素剪枝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.2.2 代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-text">1.4 N皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E9%80%90%E8%A1%8C%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="toc-text">1.4.1 逐行放置策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%88%97%E4%B8%8E%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%89%AA%E6%9E%9D"><span class="toc-text">1.4.2 列与对角线剪枝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.4.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.5 小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/t/" title="t">t</a><time datetime="2024-05-23T10:28:39.000Z" title="发表于 2024-05-23 18:28:39">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/" title="01Git概念">01Git概念</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/" title="02GitHubDesktop">02GitHubDesktop</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/" title="03IDEA集成GitHub">03IDEA集成GitHub</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/" title="05Git命令">05Git命令</a><time datetime="2024-05-22T16:00:00.000Z" title="发表于 2024-05-23 00:00:00">2024-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By chaojiwudidashuaige</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>