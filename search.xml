<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>t</title>
      <link href="/2024/05/23/t/"/>
      <url>/2024/05/23/t/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01Git概念</title>
      <link href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01Git%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-版本控制"><a href="#1-1-版本控制" class="headerlink" title="1.1 版本控制"></a>1.1 版本控制</h1><blockquote><p>软件版本</p></blockquote><ul><li>例如 JDK:1.8,17,20;MySQL:5.7,8.0;IDEA:2022,2023</li></ul><blockquote><p>文件版本</p></blockquote><ul><li>保存并区分重要的历史记录</li><li>恢复数据</li></ul><h1 id="1-2-版本控制软件的基础功能"><a href="#1-2-版本控制软件的基础功能" class="headerlink" title="1.2 版本控制软件的基础功能"></a>1.2 版本控制软件的基础功能</h1><ol><li>保存和管理文件<ul><li><img src="/images/GitLearning/Git01/git1_1.png" alt="git1_1"></li></ul></li><li>提供客户端工具进行文件的访问(不允许直接进入底层操作)<ul><li>操作都被封装到工具提供的服务中</li><li><img src="/images/GitLearning/Git01/git1_2.png" alt="git1_2"></li></ul></li><li>提供不同版本文件之间的“比对”功能<ul><li>便于确定需要回溯的版本</li><li><img src="/images/GitLearning/Git01/git1_3.png" alt="git1_3"></li></ul></li></ol><h1 id="1-3-版本控制软件"><a href="#1-3-版本控制软件" class="headerlink" title="1.3 版本控制软件"></a>1.3 版本控制软件</h1><h2 id="1-3-1-集中式版本控制软件"><a href="#1-3-1-集中式版本控制软件" class="headerlink" title="1.3.1 集中式版本控制软件"></a>1.3.1 集中式版本控制软件</h2><p><img src="/images/GitLearning/Git01/git1_4.png" alt="git1_4"></p><blockquote><p>集中式版本控制软件面临的问题</p></blockquote><ul><li><p>并发带来的文件冲突问题</p></li><li><p>中央服务器一旦出现故障，带来的影响和损失很大</p></li><li><p><img src="/images/GitLearning/Git01/git1_5.png" alt="git1_5"></p></li><li><p>解决方法1：给文件上锁(即同一时间只能有一个人修改目标文件)–&gt;开发效率低</p></li><li><p>解决方法2：允许多人同时操作，但是约束每个人只能修改目标文件的某一特定部分。最后提交时再做合并</p></li></ul><h2 id="1-3-2-分布式版本控制软件"><a href="#1-3-2-分布式版本控制软件" class="headerlink" title="1.3.2 分布式版本控制软件"></a>1.3.2 分布式版本控制软件</h2><blockquote><p>把中央资源库全部拷贝到本地</p></blockquote><ul><li><p><img src="/images/GitLearning/Git01/git1_6.png" alt="git1_6"></p></li><li><ol><li>需要在本地搭建一个和中央服务器一样的资源库–&gt;占用本地资源</li><li>存在本地和中央服务器之间大量的数据同步—&gt;依赖网络连接</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02GitHubDesktop</title>
      <link href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/"/>
      <url>/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02GitHubDesktop/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-仓库操作"><a href="#2-1-仓库操作" class="headerlink" title="2.1 仓库操作"></a>2.1 仓库操作</h1><blockquote><p>在本地创建仓库</p></blockquote><ul><li><p><img src="/images/GitLearning/Git02/git2_1.png" alt="git2_1"></p></li><li><p>Name：仓库名</p></li><li><p>Description：描述</p></li><li><p>Local Path：本地存储路径</p></li><li><p>Initialize this repository with a README：初始化仓库时附带README文件</p></li></ul><h1 id="2-2-文件操作"><a href="#2-2-文件操作" class="headerlink" title="2.2 文件操作"></a>2.2 文件操作</h1><blockquote><p>本地磁盘中的文件和本地仓库的文件是不同的</p></blockquote><blockquote><p>修改需要先提交到本地资源库，再上传到中央资源库</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_2.png" alt="git2_2"></li><li>通过比对文件，发现<code>Changes</code></li><li>通过提交(<code>commit</code>)，同步本地资源库和本地磁盘文件(<code>commit changes</code>)</li></ul><blockquote><p><code>History</code>记录了每次commit的Changes</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_3.png" alt="git2_3"></li></ul><blockquote><p>图中红框圈起来的即为<code>版本号</code>(由40个16进制数字组成)，也称为‘提交码“</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_4.png" alt="git2_4"></li></ul><h1 id="2-3-分支"><a href="#2-3-分支" class="headerlink" title="2.3 分支"></a>2.3 分支</h1><blockquote><p>多人协作</p></blockquote><h2 id="2-3-1-为什么需要分支"><a href="#2-3-1-为什么需要分支" class="headerlink" title="2.3.1 为什么需要分支"></a>2.3.1 为什么需要分支</h2><ul><li><p><img src="/images/GitLearning/Git02/git2_5.png" alt="git2_5"></p></li><li><ol><li>当多人协同开发时，多人同时进行提交，会导致“版本管理混乱”</li></ol></li><li><ol start="2"><li>并且如果在开发时需要操作同一个文件，还会遇到“文件冲突”</li></ol></li><li><ol start="3"><li>频繁的修改会导致版本信息过多，导致定位和比对文件的效率越来越低</li></ol></li></ul><blockquote><p>使用分支解决上述问题</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_6.png" alt="git2_6"></li><li>每个分支上都有一个副本，每个开发人员只向副本(资源库)提交，最后再将多个<code>分支副本</code>进行<code>合并</code></li></ul><h2 id="2-3-2-分支操作"><a href="#2-3-2-分支操作" class="headerlink" title="2.3.2 分支操作"></a>2.3.2 分支操作</h2><p><img src="/images/GitLearning/Git02/git2_7.png" alt="git2_7"></p><ul><li>wangwu：项目经理，管理主分支</li><li>Zhangsan,lisi：开发人员，向分支副本进行提交</li><li>最后合并到主分支</li></ul><blockquote><p>新建分支</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_8.png" alt="git2_8"></li></ul><blockquote><p>分支进行操作</p></blockquote><ul><li>不同分支之间进行的修改和提交都是互不干扰的，因为它们都是保存在本地的<code>分支副本</code></li></ul><blockquote><p>合并分支</p></blockquote><p>- </p><p><img src="/images/GitLearning/Git02/git2_9.png" alt="git2_9"></p><blockquote><p>合并后如何处理“文件冲突”</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_10.png" alt="git2_10"></li><li>在合并分支之前要求<code>手动解决冲突</code></li><li><img src="/images/GitLearning/Git02/git2_11.png" alt="git2_11"></li></ul><h1 id="2-4-标签"><a href="#2-4-标签" class="headerlink" title="2.4 标签"></a>2.4 标签</h1><ul><li>每一次的提交，都可以手动填写一些文字性的描述信息。</li><li>但如果进行合并操作，文字信息则是自动填充的，无法进行注释<ul><li><img src="/images/GitLearning/Git02/git2_12.png" alt="git2_12"></li></ul></li><li>此时就可以使用<code>标签Tag</code>来进行注释<ul><li><img src="/images/GitLearning/Git02/git2_13.png" alt="git2_13"></li></ul></li></ul><h1 id="2-5-远程仓库-GitHub"><a href="#2-5-远程仓库-GitHub" class="headerlink" title="2.5 远程仓库-GitHub"></a>2.5 远程仓库-GitHub</h1><blockquote><p>即中央服务器(资源库)</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_14.png" alt="git2_14"></li><li>从远程仓库克隆资源到本地</li><li><img src="/images/GitLearning/Git02/git2_15.png" alt="git2_15"></li><li>将本地资源推送到远程仓库</li></ul><h1 id="2-6-README"><a href="#2-6-README" class="headerlink" title="2.6 README"></a>2.6 README</h1><blockquote><p>描述文件(用于描述仓库存储的东西)</p></blockquote><h1 id="2-7-IGNORE"><a href="#2-7-IGNORE" class="headerlink" title="2.7 IGNORE"></a>2.7 IGNORE</h1><blockquote><p>在实际开发中，一些本地化的配置文件不需要同步到仓库中，此时可以配置IGNORE文件忽视某些后缀文件的Changes</p></blockquote><h1 id="2-8-文件图标和比对功能"><a href="#2-8-文件图标和比对功能" class="headerlink" title="2.8 文件图标和比对功能"></a>2.8 文件图标和比对功能</h1><blockquote><p>根据图标判断文件的变化情况</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_16.png" alt="git2_16"></li></ul><blockquote><p>比对功能</p></blockquote><ul><li><img src="/images/GitLearning/Git02/git2_17.png" alt="git2_17"></li><li><code>-</code>表示修改之前的</li><li><code>+</code>表示修改之后的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03IDEA集成GitHub</title>
      <link href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/"/>
      <url>/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03Git%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h1><p><img src="/images/GitLearning/Git03/git3_1.png" alt="git3_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05Git命令</title>
      <link href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-仓库操作"><a href="#5-1-仓库操作" class="headerlink" title="5.1 仓库操作"></a>5.1 仓库操作</h1><h2 id="5-1-1-创建仓库"><a href="#5-1-1-创建仓库" class="headerlink" title="5.1.1 创建仓库"></a>5.1.1 创建仓库</h2><h3 id="5-1-1-1-从远程仓库克隆"><a href="#5-1-1-1-从远程仓库克隆" class="headerlink" title="5.1.1.1 从远程仓库克隆"></a>5.1.1.1 从远程仓库克隆</h3><ol><li><code>git clone url</code>：本地的仓库名默认和远程仓库名保持一致<ul><li><code>git clone url rep_name</code>：手动指定本地的仓库名</li></ul></li></ol><h3 id="5-1-1-1-本地直接创建"><a href="#5-1-1-1-本地直接创建" class="headerlink" title="5.1.1.1 本地直接创建"></a>5.1.1.1 本地直接创建</h3><ol><li><code>git init</code>：在当前路径中创建仓库</li></ol><h2 id="5-1-2-配置仓库"><a href="#5-1-2-配置仓库" class="headerlink" title="5.1.2 配置仓库"></a>5.1.2 配置仓库</h2><ol><li>在目标仓库路径下</li></ol><ul><li><code>git config user.name your_name</code></li><li><code>git config user.email your_email</code><ul><li>user.name，user.email就是告诉其他人，你的这个提交是谁提的（叫什么名字），以及联系方式（email）</li></ul></li></ul><ol start="2"><li>全局配置:配置所有的仓库</li></ol><ul><li><code>git config --global user.name your_name</code></li><li><code>git config --global user.email your_email</code></li></ul><h1 id="5-2-文件操作"><a href="#5-2-文件操作" class="headerlink" title="5.2 文件操作"></a>5.2 文件操作</h1><ol><li><code>git status</code>：查看暂存区状态(暂存区有哪些文件，并进行比对)</li><li><code>git add file_name</code>：将工作区的文件加入到暂存区中</li><li><code>git rm --cached file_name</code>：将暂存区中的文件移出去</li><li><code>git commit -m &quot;message&quot;</code>：将通过比对发现不一致的文件，提交到本地资源库</li><li><code>git log</code>：显示提交日志</li></ol><h2 id="5-2-1-文件误删除"><a href="#5-2-1-文件误删除" class="headerlink" title="5.2.1 文件误删除"></a>5.2.1 文件误删除</h2><ol><li><p>从存储区把文件恢复到工作区:<code>git restore file_name</code></p><ul><li>删除没有被提交</li></ul></li><li><p>回退版本:<code>git reset --hard 版本号</code></p><ul><li>删除已经被提交</li><li>副作用是会丢失“回退目标版本”之后的所有版本</li><li><img src="/images/GitLearning/Git05/git5_1.png" alt="git5_1"></li></ul></li><li><p>还原版本:<code>git revert 目标版本的后一个版本的版本号</code></p><ul><li>删除已经被提交</li><li>不会导致版本丢失，而是会创建一个新的提交</li></ul></li></ol><h1 id="5-3-分支操作"><a href="#5-3-分支操作" class="headerlink" title="5.3 分支操作"></a>5.3 分支操作</h1><ol><li><p><code>git branch bname</code>：创建(bname)分支</p><ul><li>创建分支的前提是&#x3D;&#x3D;有提交&#x3D;&#x3D;(基于commit)</li></ul></li><li><p><code>git branch -v</code>：查看有多少分支</p></li><li><p><code>git checkout bname</code>：切换(bname)分支</p></li><li><p><code>git checkout -b bname</code>：创建(bname)分支并且切换</p></li><li><p><code>git branch -d bname</code>：删除(bname)分支</p></li></ol><h2 id="5-3-1-合并与冲突"><a href="#5-3-1-合并与冲突" class="headerlink" title="5.3.1 合并与冲突"></a>5.3.1 合并与冲突</h2><ol><li>合并分支，需要&#x3D;&#x3D;先切换到主分支&#x3D;&#x3D;，再将&#x3D;&#x3D;子分支合并到主分支上&#x3D;&#x3D;</li><li><code>git merge bname</code>：将bname分支合并到当前分支上</li><li>如果文件发生了&#x3D;&#x3D;冲突&#x3D;&#x3D;，此时需要打开&#x3D;&#x3D;主分支下对应的文件&#x3D;&#x3D;，并&#x3D;&#x3D;手动解决冲突&#x3D;&#x3D;，然后再提交修改后的冲突文件</li></ol><h1 id="5-4-标签"><a href="#5-4-标签" class="headerlink" title="5.4 标签"></a>5.4 标签</h1><blockquote><p>查看日志，发现版本号太难看懂干了什么，于是选择添加标签(注释)</p><p>标签不能重复(因为需要用来定位)</p><p>标签也可以理解为&#x3D;&#x3D;版本的别名&#x3D;&#x3D;</p></blockquote><ol><li><code>git log 版本号</code>：返回包括该版本在内的，该版本之前的日志</li><li><code>git tag</code>：查询所有的标签</li><li><code>git tag tag_value 版本号</code>：向某一版本增加一个标签</li><li><code>git log tag_value</code>：作用同上,可以使用标签来定位记录</li><li><code>git tag -d tag_value</code>：删除标签</li></ol><h1 id="5-5-远程仓库"><a href="#5-5-远程仓库" class="headerlink" title="5.5 远程仓库"></a>5.5 远程仓库</h1><ol><li><p><code>git push origin</code>：向远程仓库推送数据</p><ul><li>origin即为目标远程仓库</li></ul></li><li><p><code>git pull origin</code>：从远程仓库中拉取数据</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04Git版本号</title>
      <link href="/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04Git%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
      <url>/2024/05/23/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04Git%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h1><blockquote><p>版本号是由 git软件根据提交的内容，采用了特殊的加密算法<code>SHA-1</code>得到的40位16进制数字</p></blockquote><ul><li><p>可以用于“定位”仓库中的文件(2+38)</p><ul><li>前2位定位文件夹</li><li>后38位定位文件名</li></ul></li><li><p>版本号几乎不可能重复，防止版本号冲突</p></li></ul><h1 id="4-2-文件操作"><a href="#4-2-文件操作" class="headerlink" title="4.2 文件操作"></a>4.2 文件操作</h1><h2 id="4-2-1-初始化资源库"><a href="#4-2-1-初始化资源库" class="headerlink" title="4.2.1 初始化资源库"></a>4.2.1 初始化资源库</h2><p><img src="/images/GitLearning/Git04/git4_1.png" alt="git4_1"></p><ul><li><p>根据版本号查找文件<code>8f7d5c1a2c24177564644be13373f21da553c4e1</code></p><ul><li><img src="/images/GitLearning/Git04/git4_2.png" alt="git4_2"></li></ul></li><li><p><code>git cat-file -p +版本号</code>：查看文件</p><ul><li><img src="/images/GitLearning/Git04/git4_3.png" alt="git4_3"></li><li>由版本号得到“提交信息”</li><li>tree：<code>6f9509c88bed7080d496fc5e1d87a9315e30549d</code></li></ul></li><li><p>查看tree所指向的文件&#x3D;&#x3D;文件状态&#x3D;&#x3D;</p><ul><li><img src="/images/GitLearning/Git04/git4_4.png" alt="git4_4"></li><li>包含了我所需要的目标文件<code>.gitattributes</code>以及它的版本号</li><li><code>100</code>：普通文件</li><li><code>644</code>：文件权限</li><li><code>blob</code>：当前文件是一个普通的文件块对象</li></ul></li><li><p>查看tree中包含的文件(即目标文件)&#x3D;&#x3D;文件内容&#x3D;&#x3D;</p><ul><li><img src="/images/GitLearning/Git04/git4_5.png" alt="git4_5"></li><li>和GitHub Desktop显示的相同</li></ul></li></ul><h2 id="4-2-2-文件的添加"><a href="#4-2-2-文件的添加" class="headerlink" title="4.2.2 文件的添加"></a>4.2.2 文件的添加</h2><p><img src="/images/GitLearning/Git04/git4_6.png" alt="git4_6"></p><ul><li>根据版本号查找文件<code>db48392d52d1a480c3b36f063ec9389ca9db7b09</code><ul><li><img src="/images/GitLearning/Git04/git4_7.png" alt="git4_7"></li><li>得到了“提交信息”</li><li><code>parent</code>：&#x3D;&#x3D;指向了上一次提交的“提交信息”&#x3D;&#x3D;</li><li><code>tree</code>：d4f64b1d904ad5f20a1e9ab3409d1ddab50292c5</li></ul></li><li>查看tree指向的文件&#x3D;&#x3D;文件状态&#x3D;&#x3D;<ul><li><img src="/images/GitLearning/Git04/git4_8.png" alt="git4_8"></li><li>包含了“变化了的文件”和初始化的文件，以及他们版本号</li></ul></li><li>查看tree中包含的文件(目标文件)&#x3D;&#x3D;文件内容&#x3D;&#x3D;<ul><li><img src="/images/GitLearning/Git04/git4_9.png" alt="git4_9"></li><li>和GitHub Desktop中显示的相同</li></ul></li></ul><p><img src="/images/GitLearning/Git04/git4_10.png" alt="git4_10"></p><h2 id="4-2-3-文件的修改"><a href="#4-2-3-文件的修改" class="headerlink" title="4.2.3 文件的修改"></a>4.2.3 文件的修改</h2><p><img src="/images/GitLearning/Git04/git4_11.png" alt="git4_11"></p><ul><li>根据版本号查找文件<code>4a94ddd036eae37eb7e6eb9b7faf0acff9853dc1</code><ul><li><img src="/images/GitLearning/Git04/git4_12.png" alt="git4_12"></li><li>得到了提交信息</li><li><code>parent</code>：指向上一次提交信息</li><li><code>tree</code>：指向了文件的状态信息</li></ul></li><li>查看tree指向的文件&#x3D;&#x3D;文件状态&#x3D;&#x3D;<ul><li><img src="/images/GitLearning/Git04/git4_13.png" alt="git4_13"></li><li>包含了初始化文件和“被修改后的文件”(和之前不是同一个文件,版本号不同)<ul><li>和上面添加文件产生的<code>a.txt</code>不是同一个文件，因为版本号不相同</li></ul></li></ul></li><li>查看tree包含的文件&#x3D;&#x3D;文件内容&#x3D;&#x3D;<ul><li><img src="/images/GitLearning/Git04/git4_14.png" alt="git4_14"></li><li>和GitHub Desktop中显示的相同</li></ul></li></ul><p><img src="/images/GitLearning/Git04/git4_15.png" alt="git4_15"></p><h2 id="4-2-4-文件的删除"><a href="#4-2-4-文件的删除" class="headerlink" title="4.2.4 文件的删除"></a>4.2.4 文件的删除</h2><p><img src="/images/GitLearning/Git04/git4_16.png" alt="git4_16"></p><ul><li>根据版本号查找文件<code>67efac7d5aef8e54a4e47df08c81474aa61da4f0</code><ul><li><img src="/images/GitLearning/Git04/git4_17.png" alt="git4_17"></li><li><code>parent</code>：指向上一次的提交记录</li><li><code>tree</code>：指向文件的状态信息</li></ul></li><li>查看tree指向的文件<ul><li><img src="/images/GitLearning/Git04/git4_18.png" alt="git4_18"></li><li>只含有初始化文件</li></ul></li></ul><p><img src="/images/GitLearning/Git04/git4_19.png" alt="git4_19"></p><ul><li>即，删除某个文件表示为：文件状态不指向该文件</li><li>但本质上文件没有被删除，只是在&#x3D;&#x3D;当前版本下无法访问&#x3D;&#x3D;</li></ul><h1 id="4-3-分支操作"><a href="#4-3-分支操作" class="headerlink" title="4.3 分支操作"></a>4.3 分支操作</h1><blockquote><p>git软件怎么知道哪个提交信息(版本号)是最新的？？</p></blockquote><ul><li>在<code>.git</code>目录下有<code>HEAD</code>文件<ul><li><img src="/images/GitLearning/Git04/git4_20.png" alt="git4_20"></li></ul></li><li>根据应用找到<code>main</code>文件(分支)<ul><li><img src="/images/GitLearning/Git04/git4_21.png" alt="git4_21"></li><li>这个就是&#x3D;&#x3D;最新的版本号&#x3D;&#x3D;</li></ul></li></ul><p><img src="/images/GitLearning/Git04/git4_22.png" alt="git4_22"></p><blockquote><p>为什么不直接用HEAD指向最新的版本号？？</p></blockquote><h2 id="4-3-1-管理分支"><a href="#4-3-1-管理分支" class="headerlink" title="4.3.1 管理分支"></a>4.3.1 管理分支</h2><ol><li>新建user分支<ul><li>此时<code>refs/heads</code>目录下</li><li><img src="/images/GitLearning/Git04/git4_23.png" alt="git4_23"></li></ul></li><li>在user分支下新建文件并提交<ul><li>此时<code>refs/heads/user</code>指向最新的版本号</li><li>并且<code>HEAD</code>文件指向<code>refs/heads/user</code>，因为当前正处在<code>user</code>分支</li></ul></li></ol><p><img src="/images/GitLearning/Git04/git4_24.png" alt="git4_24"></p><ul><li>不同的分支可以&#x3D;&#x3D;独立的指向各自最新的版本&#x3D;&#x3D;</li><li>并且可以在不同的分支间进行切换</li></ul><h1 id="4-4-Git区域"><a href="#4-4-Git区域" class="headerlink" title="4.4 Git区域"></a>4.4 Git区域</h1><p><img src="/images/GitLearning/Git04/git4_25.png" alt="git4_25"></p><ul><li>工作区域：本地磁盘(文件夹)</li><li>存储区域：本地资源库</li><li>比对区域(暂存区)：将变化的文件从工作区域上传至比对区域区域，文件在这里和存储区域&#x3D;&#x3D;进行比对&#x3D;&#x3D;</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03栈与队列</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class3/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li>栈是一种遵循先入后出(FILO)逻辑的线性数据结构</li><li>类比于“弹夹”，先压进去的子弹后打出</li><li>把堆叠元素的顶部称为“栈顶”，底部称为“栈底”</li><li>将把元素添加到栈顶的操作叫做“入栈”，删除栈顶元素的操作叫做“出栈”</li></ol><h3 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h3><ol><li>push()：元素入栈，添加至栈顶</li><li>pop()：栈顶元素出栈</li><li>peek()：访问栈顶元素</li></ol><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>栈遵循先入后出的原则，因此我们只能在栈顶添加或删除元素</p><h4 id="基于链表的实现"><a href="#基于链表的实现" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h4><ol><li>将链表的头节点视为栈顶，尾节点视为栈底</li><li>对于入栈操作，只需将元素插入链表头部</li><li>对于出栈操作，只需将头节点从链表中删除即可</li></ol><h4 id="基于数组的实现"><a href="#基于数组的实现" class="headerlink" title="基于数组的实现"></a>基于数组的实现</h4><ol><li>将数组的尾部视为栈顶</li><li>对于入栈操作，只需将元素放在数组尾部</li><li>对于出栈操作，只需移动“索引指针”位置</li><li>由于入栈元素不确定，可以使用动态数组</li></ol><h3 id="两种实现对比"><a href="#两种实现对比" class="headerlink" title="两种实现对比"></a>两种实现对比</h3><ol><li>时间效率：<ul><li>基于数组实现的栈，在触发扩容时效率会降低。但由于扩容是低频操作，因此平均效率更高</li><li>基于链表实现的栈，可以提供更加稳定的效率表现</li></ul></li><li>空间效率：<ul><li>基于数组实现的栈，可能造成额外的空间浪费</li><li>基于链表实现的栈，每个元素占用的空间更大</li></ul></li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol><li>队列是一种遵循先入先出(FIFO)规则的线性数据结构</li><li>类比于排队，先到的先处理</li><li>将队列头部称为“队首”</li><li>将队列尾部称为“队尾”</li><li>将 把元素加入队尾的操作称为“入队”</li><li>将 把元素从队首删除的操作称为“出队”</li></ol><h3 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h3><ol><li>enqueue，元素入队，即讲元素添加至队尾</li><li>dequeue，队首元素出队</li><li>peek，访问队首元素</li></ol><h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><h4 id="基于链表的实现-1"><a href="#基于链表的实现-1" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h4><ol><li>将链表的头节点视为队首，尾节点视为队尾</li><li>规定队首仅可以删除节点，队尾仅可以添加节点</li></ol><h4 id="基于数组的实现-1"><a href="#基于数组的实现-1" class="headerlink" title="基于数组的实现"></a>基于数组的实现</h4><ol><li>通过索引规定存储队列数据的数组区间</li><li>定义front和rear表示队首和队尾</li><li>队首仅可以删除节点，队尾仅可以添加节点</li><li>通过<code>取模</code>构造环形数组，提高空间的利用率</li><li>还可以使用动态数组，进一步优化</li></ol><h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><p>双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作</p><h3 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h3><ol><li>offerLast：添加至队尾</li><li>offerFirst：添加至队首</li><li>pollFirst：队首元素出队</li><li>pollLast：队尾元素出队</li><li>peekFirst：访问队首元素</li><li>peekLast：访问队尾元素</li></ol><h3 id="双向队列实现"><a href="#双向队列实现" class="headerlink" title="双向队列实现"></a>双向队列实现</h3><ol><li>采用“双向链表”作为双向队列的底层数据结构(朝两个方向都能够一直延伸)</li><li>采用“环形数组+动态数组”作为双向队列的底层数据结构</li></ol><h3 id="双向队列的应用场景"><a href="#双向队列的应用场景" class="headerlink" title="双向队列的应用场景"></a>双向队列的应用场景</h3><p>双向队列兼具栈与队列的逻辑，因此它可以实现这两者的所有应用场景，同时提供更高的自由度</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01数据的结构</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h1><h2 id="一：数据结构分类"><a href="#一：数据结构分类" class="headerlink" title="一：数据结构分类"></a>一：数据结构分类</h2><p>从“逻辑结构”和“物理结构”两个维度进行分类</p><h3 id="逻辑结构：线性与非线性"><a href="#逻辑结构：线性与非线性" class="headerlink" title="逻辑结构：线性与非线性"></a>逻辑结构：线性与非线性</h3><ol><li>逻辑结构揭示了数据元素之间的逻辑关系</li><li>线性数据结构：数组，链表，栈，队列，哈希表</li><li>非线性数据结构：树，堆，图，哈希表(哈希冲突)<ul><li>树形结构：树，堆，哈希表–&gt;一对多</li><li>网状结构：图–&gt;多对多</li></ul></li></ol><h3 id="物理结构：连续与分散"><a href="#物理结构：连续与分散" class="headerlink" title="物理结构：连续与分散"></a>物理结构：连续与分散</h3><ol><li>物理结构反映了数据在计算机内存中的存储方式</li><li>连续空间存储：数组</li><li>分散空间存储：链表</li><li>所有数据结构都是基于数组，链表或二者的组合实现的</li><li>基于数组实现的数据结构也称“静态数据结构”，这意味着此类数据结构在初始化后长度不可变。</li><li>基于链表实现的数据结构也称“动态数据结构”，这意味着此类数据结构在初始化后，可以在程序运行过程中对其长度进行动态的改变</li></ol><h2 id="二：基本数据类型"><a href="#二：基本数据类型" class="headerlink" title="二：基本数据类型"></a>二：基本数据类型</h2><ol><li>基本数据类型是CPU可以直接进行运算的类型<ul><li>In Java：<code>byte,short,int,long,char,float,double,boolean</code>(8)</li></ul></li><li>基本数据类型以二进制的形式存储在计算机中</li><li><img src="/images/AlgoGettingStart/image.png" alt="Alt text"></li><li>数据类型提供了数据的“内容类型”，数据结构提供了数据的“组织方式”</li></ol><h2 id="三：数字编码"><a href="#三：数字编码" class="headerlink" title="三：数字编码"></a>三：数字编码</h2><h3 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h3><ol><li>原码：将数字的二进制表示 的最高位视为符号位，0表示正数，1表示负数</li><li>反码：正数的反码与其原码相同，负数的反码是 对其原码除符号位外的所有位 取反</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上<code>+1</code></li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol start="4"><li>数字是以“补码”的形式存储在计算机中的</li><li>反码和补码可用于直接计算，负数的原码不可以</li><li>数字0的原码和反码都存在<code>+0</code>和<code>-0</code>两种表示方式—&gt;引入<code>补码</code>—&gt;<code>+0</code>和<code>-0</code>补码相同</li><li>补码<code>1000 0000</code>是一个例外，它并没有对应的原码。规定这个特殊的补码<code>1000 0000</code>代表-128</li><li>计算机内部的硬件电路主要是基于加法运算设计的</li></ol><h3 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><ol><li><img src="/images/AlgoGettingStart/image-1.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-2.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-3.png" alt="Alt text"></li><li>因为float的表示方式包含指数位，导致其取值范围远大于int</li><li>副作用是牺牲了精度，float由于指数位的存在，float数值越大，相邻两个数字之间的差值就会趋向越大</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02数组与链表</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class2/</url>
      
        <content type="html"><![CDATA[<h1 id="数组与链表"><a href="#数组与链表" class="headerlink" title="数组与链表"></a>数组与链表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>索引本质上是内存地址偏移量。首个元素的地址偏移量是0，因此首个元素的索引为0是很合理的</li></ol><h2 id="数组VS链表"><a href="#数组VS链表" class="headerlink" title="数组VS链表"></a>数组VS链表</h2><p><img src="/images/AlgoGettingStart/image-4.png" alt="Alt text"></p><h2 id="列表：List"><a href="#列表：List" class="headerlink" title="列表：List"></a>列表：List</h2><ol><li>列表是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问，修改，添加，删除和遍历等操作，无须使用者考虑容量限制问题</li><li>列表可以基于链表或数组实现<ul><li>链表天然可以看作一个列表，其支持元素增删改查操作，并且可以灵活动态扩容</li><li>数组也支持元素增删改查，但由于其长度不可变，因此考虑使用 动态数组</li></ul></li></ol><h2 id="内存与缓存"><a href="#内存与缓存" class="headerlink" title="内存与缓存"></a>内存与缓存</h2><p>物理结构在很大程度上决定了程序对内存和缓存的使用效率，进而影响算法程序的整体性能</p><h3 id="计算机存储设备"><a href="#计算机存储设备" class="headerlink" title="计算机存储设备"></a>计算机存储设备</h3><ol><li>计算机中包括三种类型的存储设备：硬盘，内存，缓存</li><li><img src="/images/AlgoGettingStart/image-5.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-6.png" alt="Alt text"></li><li>硬盘用于长期存储大量数据，内存用于临时存储程序中正在处理的数据，而缓存则用于存储经常访问的数据和指令</li><li>在程序运行时，数据会从硬盘中被读取到内存中，供CPU计算使用。缓存可以看作CPU的一部分，它通过智能地从内存加载数据，给CPU提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖</li></ol><h3 id="数据结构的内存效率"><a href="#数据结构的内存效率" class="headerlink" title="数据结构的内存效率"></a>数据结构的内存效率</h3><ol><li>内存是有限的，且同一块内存不能被多个程序共享。<ul><li>链表单个元素所占的空间更大，但是更具灵活性</li><li>数组单个元素所占的空间更小，但是很容易导致空间的浪费</li></ul></li><li>随着反复申请与释放内存，空闲内存的碎片化程度会越来越高。<ul><li>随着链表元素的增删，内存更容易碎片化</li></ul></li></ol><h3 id="数据结构的缓存效率"><a href="#数据结构的缓存效率" class="headerlink" title="数据结构的缓存效率"></a>数据结构的缓存效率</h3><ol><li>缓存的容量有限，只能存储一小部分频繁访问的数据</li><li>将CPU从缓存中成功获取数据的比例称为“缓存命中率”，这个指标常用来衡量缓存效率</li><li>为了达到更可能高的效率，缓存会采取以下数据加载机制<ul><li>缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效</li><li>预取机制：处理器会尝试预测数据访问模式(例如顺序访问，固定步长跳跃访问等)，并根据特定模式将数据加载至缓存中，从而提高命中率</li><li>空间局部性：如果一个数据被访问，那么它附近的数据近期也会被访问。因此，缓存在加载某一个数据时，也会加载其附近的数据，以提高命中率</li><li>时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率</li></ul></li><li>数组和链表对缓存的利用效率是不同的，主要体现在：<ul><li>占用空间：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少</li><li>缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高</li><li>预取机制：数组比链表的数据访问模式更具有可预测性，即系统更容易猜出即将被加载的数据</li><li>空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问</li></ul></li><li>数组具有更高的缓存命中率，但并不意味着数组在所有情况下都优于链表</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05二叉树</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class5/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li>二叉树是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。</li><li>与链表类似，二叉树的基本单元是节点，每个节点包含<code>值,左子节点引用,右子节点引用</code></li><li>每个节点都有两个引用，分别指向“左子节点”和“右子节点”，该节点被称为 这两个子节点的“父节点”<ul><li>当给定一个二叉树的节点时，我们将 该节点的左子节点及其以下节点形成的树称为 该节点的“左子树”。同理可得 该节点的“右子树”</li></ul></li><li>二叉树中，除 叶节点(终端节点)外，其他所有节点都包含 子节点和非空子树</li></ol><h3 id="二叉树常见术语"><a href="#二叉树常见术语" class="headerlink" title="二叉树常见术语"></a>二叉树常见术语</h3><ol><li>根节点<code>root node</code>：位于二叉树顶层的节点，没有父节点</li><li>叶节点<code>leaf node</code>：没有子节点的节点，其两个指针均指向<code>null</code></li><li>边<code>edge</code>：连接两个节点的线段(节点引用)</li><li>节点所在的层<code>level</code>：从顶到底递增，根节点所在层为1</li><li>节点的度<code>degree</code>：节点的子节点的数量，在二叉树中，度的取值范围为{0,1,2}</li><li>二叉树的高度<code>height</code>：从根节点到最远叶节点所经过的边的数量</li><li>节点的深度<code>depth</code>：从根节点到该节点所经过边的数量(和上面比叫深度)</li><li>节点的高度<code>height</code>：从距离该节点最远的叶节点到该节点所经过的边的数量(和下面比叫高度)</li></ol><h4 id="注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要-1"><a href="#注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要-1" class="headerlink" title="注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要+1"></a>注意：通常将“高度”和“深度”定义为“经过的边的数量”，但有些时候可能将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要+1</h4><h3 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h3><ol><li>初始化二叉树<ul><li>和链表类似，先初始化节点，然后构建引用</li></ul></li><li>插入与删除节点<ul><li>和链表类似，在二叉树中插入与删除节点可以通过修改引用来实现。</li></ul></li></ol><h4 id="注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作"><a href="#注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作" class="headerlink" title="注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作"></a>注意：插入节点可能会改变二叉树原有的逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除是由一套操作配合完成的，以实现有实际意义的操作</h4><h3 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h3><ol><li>完美二叉树&#x2F;满二叉树<code>perfect binary tree</code>：<ul><li>完美二叉树所有层的节点都被完全填满。即 叶节点的度为0，其余所有节点的度为2</li><li>若树的高度为h，则节点总数为 2^(h+1)-1。呈现标准的指数级关系</li><li><img src="/images/AlgoGettingStart/image-10.png" alt="Alt text"></li></ul></li><li>完全二叉树<code>complete binary tree</code>：<ul><li>完全二叉树只有最底层的节点未被填满，且最底层节点尽量靠左填充</li><li><img src="/images/AlgoGettingStart/image-11.png" alt="Alt text"></li></ul></li><li>完满二叉树<code>full binary tree</code>：<ul><li>完满二叉树除了叶节点之外，其余所有节点都有两个子节点(除了叶节点之外的节点的 子节点都是满的full)</li><li>即所有节点的度都为0或2</li><li><img src="/images/AlgoGettingStart/image-12.png" alt="Alt text"></li></ul></li><li>平衡二叉树<code>balanced binary tree</code>：<ul><li>平衡二叉树中 任意节点的左子树和右子树的高度之差的绝对值 不超过1</li><li><img src="/images/AlgoGettingStart/image-13.png" alt="Alt text"></li></ul></li></ol><h3 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h3><ol><li>当二叉树的每层节点都被填满时，达到“完美二叉树”</li><li>而当所有节点都偏向一侧时，二叉树退化为链表</li><li><img src="/images/AlgoGettingStart/image-14.png" alt="Alt text"></li><li>在最佳结构和最差结构下，二叉树的“叶节点数量”，“节点总数”，“高度”等达到极大值或极小值<ul><li><img src="/images/AlgoGettingStart/image-15.png" alt="Alt text"></li></ul></li></ol><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ol><li>从物理结构的角度来看，树是一种基于链表的数据结构，因此其“遍历方式”是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现</li><li>二叉树常见的遍历方式包括”层序遍历”，“前序遍历”，“中序遍历”和“后序遍历”</li></ol><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ol><li>层序遍历从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点</li><li>层序遍历本质上属于“广度优先遍历”，也称“广度优先搜索”，它体现了一种“一圈一圈向外扩展”的逐层遍历方式(先遍历完一圈，再遍历下一圈)</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelTraversal</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    Queue&lt;BinaryNode&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">BinaryNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(poll.val);</span><br><span class="line">        <span class="keyword">if</span>(poll.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(poll.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(poll.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li>时间复杂度O(n)：所有节点被访问一次，使用O(n)时间，其中n为节点数量</li><li>空间复杂度O(n)：在最差情况下，即满二叉树时，在即将遍历最底层时，队列中最多同时存在(n+1)&#x2F;2个节点(全是叶节点)，占用O(n)空间</li></ol><h3 id="前序，中序，后序遍历"><a href="#前序，中序，后序遍历" class="headerlink" title="前序，中序，后序遍历"></a>前序，中序，后序遍历</h3><ol><li>前序，中序和后序遍历都属于“深度优先遍历”，也称“深度优先搜索”，它体现了一种“先走到尽头，再回溯继续”的遍历方式</li><li>深度优先遍历就像是 绕着整棵二叉树的外围“走”一圈。在每个节点都会遇到三个位置，分别对应前序遍历，中序遍历和后序遍历<ul><li><img src="/images/AlgoGettingStart/image-16.png" alt="Alt text"></li><li><pre><code class="java">//围绕二叉树走一圈算法：public static void dfs(BinaryNode root)&#123;    if(root==null)&#123;      return ;    &#125;    dfs(root.left);    dfs(root.right);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 代码实现(都基于走一圈dfs算法)</span><br><span class="line">1. 前序遍历</span><br><span class="line">```java</span><br><span class="line">public static void preOrder(BinaryNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>中序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>后序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(BinaryNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/AlgoGettingStart/image-16.jpg" alt="Alt text"></li><li>沿着路线，前序，中序，后序遍历的“点位”决定了它们的“语句”相对于<code>dfs(left),dfs(right)</code>的位置</li></ol><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol><li>时间复杂度:O(n),所有节点被访问一次，使用O(n)时间</li><li>空间复杂度:O(n)，在最差情况下，即树退化为链表时，递归深度达到n，系统占用O(n)栈帧空间</li></ol><h2 id="二叉树数组表示"><a href="#二叉树数组表示" class="headerlink" title="二叉树数组表示"></a>二叉树数组表示</h2><h3 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h3><ol><li>给定一棵完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引</li><li>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<code>若某节点的索引为i，则该节点的左子节点索引为2i+1，右子节点索引为2i+2</code><ul><li>理解：假定索引为i的节点位于的层还有x个节点。那么下一层(子节点所处的层)共有<code>i+x+1+1</code>(索引从0开始)个节点，减去<code>2x</code>个节点，即为“右子节点”所处的位置。所以“右子节点”的索引为<code>i+x+(i+x+2-2x)=2i+2</code>，由此得“左子节点”的索引为<code>2i+1</code></li></ul></li><li><img src="/images/AlgoGettingStart/image-20.png" alt="Alt text"></li><li>映射公式的角色相当于 节点中的引用。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的子节点</li></ol><h3 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h3><ol><li>完美二叉树是一个特例，在二叉树的中间层通常存在许多<code>null</code>。由于层序遍历序列并不包含这些<code>null</code>，因此我们无法仅凭该序列来推测<code>null</code>的数量和分布位置(即一个序列无法唯一表示一个二叉树)</li><li>这意味着存在多种二叉树结构都符合该层序遍历序列</li><li><img src="/images/AlgoGettingStart/image-21.png" alt="Alt text"></li><li>为了解决此问题，我们可以考虑“在层序遍历序列中显式地写出所有<code>null</code>”。这样处理后，层序遍历序列就可以唯一表示二叉树</li><li><img src="/images/AlgoGettingStart/image-22.png" alt="Alt text"></li></ol><h4 id="完全二叉树非常适合使用数组来表示。"><a href="#完全二叉树非常适合使用数组来表示。" class="headerlink" title="完全二叉树非常适合使用数组来表示。"></a>完全二叉树非常适合使用数组来表示。</h4><ol><li>根据完全二叉树的定义，<code>null</code>只出现在最底层且靠右的位置，因此所有<code>null</code>一定出现在层序遍历序列的末尾</li><li>这意味着使用数组表示完全二叉树时，可以省略存储所有<code>null</code></li><li><img src="/images/AlgoGettingStart/image-23.png" alt="Alt text"></li></ol><h3 id="优点与局限性"><a href="#优点与局限性" class="headerlink" title="优点与局限性"></a>优点与局限性</h3><ol><li>二叉树的数组表示主要有以下优点<ul><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快</li><li>不需要存储指针，比较节省空间</li><li>允许随机访问节点<code>O(1)</code></li></ul></li><li>数组表示存在一些局限性<ul><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树</li><li>增删节点需要通过数组插入与删除操作实现，效率较低</li><li>当二叉树中存在大量<code>null</code>时，数组中包含的节点数据比重较低，空间利用率较低</li></ul></li></ol><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ol><li><img src="/images/AlgoGettingStart/image-24.png" alt="Alt text"></li><li>如图所示，<code>二叉搜索树 binary search tree</code>满足以下条件<ul><li>对于根节点，左子树中所有节点的值&lt;根节点的值&lt;右子树中所有节点的值</li><li>任意节点的左，右子树也是二叉搜索树，即同样满足条件1</li></ul></li></ol><h3 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h3><ol><li>将二叉搜索树封装为一个类<code>BinarySearchTree</code>，并声明一个成员变量<code>root</code>，指向树的根节点</li></ol><h4 id="1-查找节点"><a href="#1-查找节点" class="headerlink" title="1.查找节点"></a>1.查找节点</h4><ol><li>给定目标节点值<code>num</code>，可以根据二叉搜索树的性质来查找。</li><li>声明一个节点<code>cur</code>，从二叉搜索树的根节点<code>root</code>出发，“循环比较”节点值<code>cur.val</code>和<code>num</code>之间的大小关系<ul><li>若<code>cur.val&lt;num</code>：说明目标节点在cur的右子树中，因此执行<code>cur=cur.right</code></li><li>若<code>cur.val==num</code>：说明找到目标节点，跳出循环并返回该节点</li><li>若<code>cur.val&gt;num</code>：说明目标节点在cur的左子树中，因此执行<code>cur=cur.left</code></li></ul></li><li>二叉搜索树的查找操作与“二分查找算法”的工作原理一致，都是每轮排除一半情况(排除一个子树)。循环次数最多为二叉树的高度。当二叉树平衡时，使用<code>O(logn)</code>的时间<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BinarySearchNode <span class="title function_">searchNode</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="comment">//循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">for</span>(;cur!=<span class="literal">null</span>;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&gt;num)&#123;</span><br><span class="line">            <span class="comment">//目标节点在cur的左子树</span></span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&lt;num) &#123;</span><br><span class="line">            <span class="comment">//目标节点在cur的右子树</span></span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点就是cur</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-插入节点"><a href="#2-插入节点" class="headerlink" title="2.插入节点"></a>2.插入节点</h4><ol><li>给定一个待插入元素<code>num</code>，为了保持”左子树&lt;根节点&lt;右子树”的性质，插入操作流程如图所示</li><li><img src="/images/AlgoGettingStart/image-25.png" alt="Alt text"><ul><li>查找插入位置：与查找操作类似，从根节点出发，根据当前节点值和<code>num</code>的大小关系循环向下搜索，知道“越过叶节点”(遍历至null)时跳出循环</li><li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>null</code>的位置</li></ul></li><li>在代码实现中，需要注意以下两点<ul><li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回</li><li>为了实现插入节点，我们需要借助节点<code>pre</code>保存上一回循环的节点。这样在遍历至<code>null</code>时，我们可以获取到其父节点，从而完成节点插入操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchNode pre=<span class="literal">null</span>;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;num)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&gt;num) &#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre.val&lt;num)&#123;</span><br><span class="line">        pre.right=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        pre.left=<span class="keyword">new</span> <span class="title class_">BinarySearchNode</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>与查找节点相同，插入节点使用<code>O(logn)</code>时间</li></ol><h4 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="3.删除节点"></a>3.删除节点</h4><ol><li>先在二叉树中查找到目标节点，再将其删除。</li><li>与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树&lt;根节点&lt;右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量(度)，分0，1，2三种情况，执行对应的删除节点操作<ul><li>当待删除节点的度为0时，表示该节点是叶节点，可以直接删除<ul><li><img src="/images/AlgoGettingStart/image-26.png" alt="Alt text"></li></ul></li><li>当待删除节点的度为1时，将待删除节点替换为其子节点即可<ul><li><img src="/images/AlgoGettingStart/image-27.png" alt="Alt text"></li></ul></li></ul></li><li>当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树&lt;根节点&lt;右子树”的性质，因此这个节点可以是<code>右子树的最小节点或左子树的最大节点</code><ul><li>删除操作流程：<ul><li>找到待删除节点在“中序遍历序列”中的 上一个节点&#x2F;下一个节点(对应 左子树的最大节点&#x2F;右子树的最小节点)，记为tmp</li><li>用tmp的值覆盖 待删除节点的值，并在二叉搜索树中递归删除节点tmp(tmp的度为0或1，对应上文的删除方法)</li></ul></li><li>示意图：<ul><li><img src="/images/AlgoGettingStart/image-28.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-29.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-30.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-31.png" alt="Alt text"></li></ul></li></ul></li><li>删除节点操同样使用<code>O(logn)</code>时间，其中查找待删除节点需要<code>O(logn)</code>时间，获取中序遍历后继节点需要<code>O(logn)</code>时间(实际上是找右树最左端节点)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//空树</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchNode pre=<span class="literal">null</span>;</span><br><span class="line">    BinarySearchNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;<span class="comment">//查找</span></span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;num)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val&gt;num) &#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>)&#123;<span class="comment">//没找到</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到了--&gt;删除</span></span><br><span class="line">    <span class="keyword">if</span>(cur.left==<span class="literal">null</span>||cur.right==<span class="literal">null</span>)&#123;<span class="comment">//degree=0or1，为什么要把它们放在一起--&gt;处理方法相同</span></span><br><span class="line">        <span class="comment">//cur的子节点(null或节点)</span></span><br><span class="line">        BinarySearchNode child=cur.left==<span class="literal">null</span>?cur.right:cur.left;<span class="comment">//如果cur.left为空，那么直接返回right</span></span><br><span class="line">        <span class="comment">//因为处理degree为0和1的方法相同，所以可以直接使用right。如果cur.left不为空，那么直接返回cur.left</span></span><br><span class="line">        <span class="keyword">if</span>(cur==root)&#123;<span class="comment">//如果删除根节点，那么pre就为null,所以需要额外写一个方法</span></span><br><span class="line">            root=child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==pre.left)&#123;</span><br><span class="line">                pre.left=child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right=child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//degree为2</span></span><br><span class="line">        <span class="comment">//中序遍历cur的下一个节点(右子树的最左端)</span></span><br><span class="line">        BinarySearchNode tmp=cur.right;<span class="comment">//定位右子树</span></span><br><span class="line">        <span class="keyword">while</span>(tmp.left!=<span class="literal">null</span>)&#123;<span class="comment">//遍历查找右子树最左节点</span></span><br><span class="line">            tmp=tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remove(tmp.val);<span class="comment">//删除节点(递归删除)</span></span><br><span class="line">        cur.val=tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/AlgoGettingStart/IMG_0047.jpg" alt="Alt text"></li></ol><h4 id="4-中序遍历-有序"><a href="#4-中序遍历-有序" class="headerlink" title="4.中序遍历(有序)"></a>4.中序遍历(有序)</h4><ol><li>二叉树的中序遍历遵循“左–&gt;根–&gt;右”的遍历顺序，而二叉搜索树满足“左子节点&lt;根节点&lt;右子节点”的大小关系</li><li>这意味着 “二叉搜索树的中序遍历序列是升序的”</li><li>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需<code>O(n)</code>时间，无须进行额外的排序操作，非常高效</li></ol><h3 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h3><ol><li>二叉搜索树增删改查的时间复杂度都是<code>O(logn)</code>。只有在高频添加，低频查找删除数据的场景下，数组比二叉搜索树的效率更高<ul><li><img src="/images/AlgoGettingStart/image-32.png" alt="Alt text"></li></ul></li><li>在理想情况下，二叉搜索树是“平衡”的，这样就可以在”logn”轮循环内查找任意节点</li><li>然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为链表。这时各种操作的时间复杂度也会退化为O(n)<ul><li><img src="/images/AlgoGettingStart/image-33.png" alt="Alt text"></li></ul></li></ol><h3 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h3><ol><li>用作系统中的“多级索引”，实现高效的查找，插入，删除操作</li><li>作为某些搜索算法的底层数据结构</li><li>用于存储数据流，以保持其有序状态</li></ol><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ol><li>在多次插入和删除操作后，二叉搜索树可能退化为链表。在这种情况下，所有操作的时间复杂度将从<code>O(logn)</code>劣化至<code>O(n)</code><ul><li><img src="/images/AlgoGettingStart/image-34.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-35.png" alt="Alt text"></li></ul></li><li>AVL树确保在持续添加和删除节点后，AVL树不会退化，从而使得各种操作的时间复杂度保持在<code>O(logn)</code>级别。</li><li>在需要频繁进行增删改查操作的场景中，AVL树能始终保持高效的数据操作性能，具有很好的应用价值</li><li>在不改变中序遍历序列的情况下，改变树的结构</li><li>局部改变:都是以某个节点作为根节点，研究该节点延伸出的树</li></ol><h3 id="AVL树常见术语"><a href="#AVL树常见术语" class="headerlink" title="AVL树常见术语"></a>AVL树常见术语</h3><ol><li>AVL树既是平衡二叉树，又是二叉搜索树。同时满足这两类二叉树的所有性质，因此是一种 “平衡二叉搜索树<code>balanced binary search tree</code>”</li></ol><h4 id="节点高度"><a href="#节点高度" class="headerlink" title="节点高度"></a>节点高度</h4><ol><li>由于AVL树的相关操作需要获取节点高度，因此我们需要为节点类添加<code>height</code>属性</li><li>“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的边的数量。需要特别注意的是，叶节点的高度为0，而空节点的高度为-1。</li><li>创建两个工具方法，分别用于获取和更新节点的高度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node==<span class="literal">null</span>?-<span class="number">1</span>: node.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    node.height=Math.max(getHeight(node.left),getHeight(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="节点平衡因子"><a href="#节点平衡因子" class="headerlink" title="节点平衡因子"></a>节点平衡因子</h4><ol><li>节点的<code>平衡因子 balance factor</code>定义为“节点左子树的高度减去右子树的高度”</li><li>同时规定空节点的平衡因子为0</li><li>将获取节点平衡因子的功能封装成方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBalancedFactor</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left)-getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>设平衡因子为f，则一棵AVL树的任意节点的平衡因子都满足<code>-1&lt;f&lt;1</code></li></ol><h3 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a>AVL树旋转</h3><ol><li>AVL树的特点在于“旋转操作”，它能够在“不影响二叉树的中序遍历序列的前提下”，使失衡节点重新恢复平衡</li><li>旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”</li><li>将平衡因子的绝对值&gt;1的节点称为“失衡节点”</li><li>根据“节点失衡情况”不同，旋转操作分为四种：右旋，左旋，先右旋后左旋，先左旋后右旋</li></ol><h4 id="1-右旋"><a href="#1-右旋" class="headerlink" title="1.右旋"></a>1.右旋</h4><h5 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h5><ol><li><img src="/images/AlgoGettingStart/image-36.png" alt="Alt text"><ul><li>从底至顶看，二叉树中首个失衡节点是“节点三”。</li><li>关注以该失衡节点为根节点的子树</li></ul></li><li><img src="/images/AlgoGettingStart/image-37.png" alt="Alt text"><ul><li>将该节点记为node，其左子节点记为child</li></ul></li><li>执行右旋操作，完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质<ul><li><img src="/images/AlgoGettingStart/image-38.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-39.png" alt="Alt text"></li></ul></li></ol><h5 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h5><p>当节点child有右子节点(记为grand_child)时，需要在右旋中添加一步，将grand_child作为node的左子节点(因为它大于node小于child)<br><img src="/images/AlgoGettingStart/image-40.png" alt="Alt text"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">rightRotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.right;</span><br><span class="line">    <span class="comment">//以child为原点，将node向右旋转</span></span><br><span class="line">    child.right=node;</span><br><span class="line">    node.left=grandChild;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">//返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-左旋"><a href="#2-左旋" class="headerlink" title="2.左旋"></a>2.左旋</h4><ol><li>相应的，如果考虑上述失衡二叉树的镜像，则需要执行“左旋”操作<ul><li><img src="/images/AlgoGettingStart/image-41.png" alt="Alt text"></li></ul></li><li>同理，当节点child有左子节点(记为grandChild)时，需要将grandChild作为node的右子节点(grandChild小于child大于node)<ul><li><img src="/images/AlgoGettingStart/image-42.png" alt="Alt text"></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">leftRotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">child</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="type">BalancedBinarySearchNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.left;</span><br><span class="line">    <span class="comment">//围绕child向左旋转</span></span><br><span class="line">    child.left=node;</span><br><span class="line">    node.right=grandChild;</span><br><span class="line">    <span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">//返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-先右旋后左旋"><a href="#3-先右旋后左旋" class="headerlink" title="3.先右旋后左旋"></a>3.先右旋后左旋</h4><p><img src="/images/AlgoGettingStart/image-43.png" alt="Alt text"></p><ul><li>对于图中的失衡节点，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对child执行“左旋”，再对node执行“右旋”</li></ul><h4 id="4-先左旋后右旋"><a href="#4-先左旋后右旋" class="headerlink" title="4.先左旋后右旋"></a>4.先左旋后右旋</h4><p><img src="/images/AlgoGettingStart/image-44.png" alt="Alt text"></p><ul><li>对于上述失衡二叉树的镜像情况，需要先对child进行右旋，再对node进行左旋</li></ul><h4 id="旋转的选择"><a href="#旋转的选择" class="headerlink" title="旋转的选择"></a>旋转的选择</h4><ol><li><img src="/images/AlgoGettingStart/image-45.png" alt="Alt text"></li><li>通过判断失衡节点的平衡因子以及 较高一侧子节点的平衡因子的正负号，来确定失衡节点属于哪种情况<ul><li><img src="/images/AlgoGettingStart/image-46.png" alt="Alt text"></li></ul></li><li>为了便于使用，将旋转操作封装成一个函数。有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">rotate</span><span class="params">(BalancedBinarySearchNode node)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">balancedFactor</span> <span class="operator">=</span> getBalancedFactor(node);</span><br><span class="line">    <span class="keyword">if</span>(balancedFactor&gt;<span class="number">1</span>)&#123;<span class="comment">//左偏</span></span><br><span class="line">        <span class="keyword">if</span>(getBalancedFactor(node.left)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.left=leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(balancedFactor&lt;-<span class="number">1</span>)&#123;<span class="comment">//右偏</span></span><br><span class="line">        <span class="keyword">if</span>(getBalancedFactor(node.right)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.right=rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树常用操作"><a href="#AVL树常用操作" class="headerlink" title="AVL树常用操作"></a>AVL树常用操作</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li>AVL树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在AVL树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。</li><li>因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    root=insertHelper(root,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以根节点作为遍历的起始节点</span></span><br><span class="line"><span class="comment">/*辅助方法便于递归调用*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">insertHelper</span><span class="params">(BalancedBinarySearchNode node,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BalancedBinarySearchNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val&lt;node.val)&#123;<span class="comment">//查找并排序</span></span><br><span class="line">        node.left=insertHelper(node,val);<span class="comment">//递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val&gt;node.val) &#123;</span><br><span class="line">        node.right=insertHelper(node,val);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node);<span class="comment">//递归更新高度</span></span><br><span class="line">    <span class="comment">/*旋转，从下到上检查失衡并旋转*/</span></span><br><span class="line">    rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//一边递归找到添加的位置，一边递归更新路径上的节点高度，还从底向上进行旋转(“递归”)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>类似的，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    root=removeHelper(root,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">removeHelper</span><span class="params">(BalancedBinarySearchNode node,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归查找并删除</span></span><br><span class="line">    <span class="keyword">if</span>(val&lt; node.val)&#123;</span><br><span class="line">        node.left=removeHelper(node.left,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val&gt; node.val) &#123;</span><br><span class="line">        node.right=removeHelper(node.right,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//找到了，进行删除</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span>||node.right==<span class="literal">null</span>)&#123;<span class="comment">//degree=0/1</span></span><br><span class="line">            BalancedBinarySearchNode child=node.left==<span class="literal">null</span>?node.right:node.left;</span><br><span class="line">            <span class="keyword">if</span>(child==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node=child;<span class="comment">//放到后面再返回，因为还要执行一些操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//degree=2</span></span><br><span class="line">            BalancedBinarySearchNode tmpNode=node.right;</span><br><span class="line">            <span class="keyword">while</span>(tmpNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tmpNode=tmpNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right=removeHelper(node.right,tmpNode.val);</span><br><span class="line">            node.val=tmpNode.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node);<span class="comment">//递归更新节点高度</span></span><br><span class="line">    node=rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>AVL树的节点查找操作与二叉搜索树一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BalancedBinarySearchNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    BalancedBinarySearchNode tmp=root;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; tmp.val) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; tmp.val) &#123;</span><br><span class="line">            tmp = tmp.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树典型应用"><a href="#AVL树典型应用" class="headerlink" title="AVL树典型应用"></a>AVL树典型应用</h3><ol><li>组织和存储大型数据，适用于高频查找，低频增删的场景</li><li>用于构建数据库中的索引系统</li><li>红黑树也是一种常见的平衡二叉搜索树。相较于AVL树，红黑树的平衡条件更宽松，插入与删除节点所需的旋转操作更少，节点增删操作的平均效率更高</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分治算法</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class10/</url>
      
        <content type="html"><![CDATA[<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="1-1-分治算法"><a href="#1-1-分治算法" class="headerlink" title="1.1 分治算法"></a>1.1 分治算法</h2><ol><li>分治<code>divide and conquer</code>，全称“分而治之”，是一种非常重要且常见的算法策略。</li><li>分治通常通过递归实现，包括“分”和“治”两个步骤<ul><li>分(划分阶段):递归的将原问题分解为两个或多个子问题，直至达到最小子问题时终止</li><li>治(合并阶段):从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解</li></ul></li><li>“归并排序”是分治策略的典型应用之一<ul><li>分：递归的将原数组(原问题)划分为两个子数组(子问题)，直到子数组只剩一个元素(最小子问题)</li><li>治：从底至顶地将有序的子数组(子问题的解)进行合并，从而得到有序的原数组(原问题的解)</li><li><img src="/images/AlgoGettingStart/img_79.png" alt="img_79.png"></li></ul></li></ol><h3 id="1-1-1-如何判断分治问题"><a href="#1-1-1-如何判断分治问题" class="headerlink" title="1.1.1 如何判断分治问题"></a>1.1.1 如何判断分治问题</h3><ol><li>一个问题是否适合使用分治解决，通常可以参考以下几个判断依据<ul><li><ol><li>问题可以分解：原问题可以分解为规模更小，类似的子问题，以及能够以相同方式递归地进行划分</li></ol></li><li><ol start="2"><li>子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决</li></ol></li><li><ol start="3"><li>子问题的解可以合并：原问题的解通过合并子问题的解得来</li></ol></li></ul></li><li>显然，归并排序满足以上三个判断依据<ul><li><ol><li>问题可以分解：递归地将数组(原问题)划分为两个子数组(子问题)</li></ol></li><li><ol start="2"><li>子问题是独立的：每个子数组都可以独立地进行排序(子问题可以独立进行求解)</li></ol></li><li><ol start="3"><li>子问题的解可以合并：两个有序子数组(子问题的解)可以合并为一个有序数组(原问题的解)</li></ol></li></ul></li></ol><h3 id="1-1-2-通过分治提升效率"><a href="#1-1-2-通过分治提升效率" class="headerlink" title="1.1.2 通过分治提升效率"></a>1.1.2 通过分治提升效率</h3><ol><li>分治不仅可以有效地解决算法问题，往往还可以提升算法效率。<ul><li>在排序算法中，快速排序，归并排序 相较于选择，冒泡，插入排序更快，就是因为它们应用了分治策略</li></ul></li><li>为什么分治可以提升算法效率？？？<ul><li>将大问题分解为多个子问题，解决子问题，将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高</li><li>可以从 操作数量和并行计算 两方面来讨论</li></ul></li></ol><h4 id="1-1-2-1-操作数量优化"><a href="#1-1-2-1-操作数量优化" class="headerlink" title="1.1.2.1 操作数量优化"></a>1.1.2.1 操作数量优化</h4><ol><li>冒泡排序为例，其处理一个长度为n的数组需要O(n^2)时间。按照下图<ul><li><img src="/images/AlgoGettingStart/img_80.png" alt="img_80.png"></li><li>这意味着当n&gt;4时，划分后的操作数更少，排序效率应该更高</li></ul></li><li>进一步想，如果将子数组不断地再从中点处划分为两个子数组，直至子数组只剩一个元素时停止划分。这种思路实际上就是归并排序，时间复杂度为O(nlogn)</li><li>如果我们多设置几个划分点，将原数组平均划分为k个子数组。这种情况与“桶排序”非常类似，适合排序海量数据，理论上时间复杂度可以达到O(n+k)</li></ol><h4 id="1-1-2-2-并行计算优化"><a href="#1-1-2-2-并行计算优化" class="headerlink" title="1.1.2.2 并行计算优化"></a>1.1.2.2 并行计算优化</h4><ol><li>分治生成的子问题是相互独立的，因此通常可以并行解决。也就是说，分治不仅可以降低算法的时间复杂度，还有利于操作系统的并行优化</li><li>并行优化在多核或多处理器环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体运行时间</li><li><img src="/images/AlgoGettingStart/img_81.png" alt="img_81.png"><ul><li>如上图所示的“桶排序”，将海量的数据平均划分到各个桶中，则所有桶的排序任务可分散到各个计算单元，完成后再合并结果</li></ul></li></ol><h2 id="1-2-分治搜索策略"><a href="#1-2-分治搜索策略" class="headerlink" title="1.2 分治搜索策略"></a>1.2 分治搜索策略</h2><ol><li>搜索算法分为两大类<ul><li><ol><li>暴力搜索：通过遍历数据结构实现，时间复杂度为<code>O(n)</code></li></ol></li><li><ol start="2"><li>自适应搜索：利用特有的数据组织形式或先验信息，时间复杂度可达到<code>O(logn)</code>甚至<code>O(1)</code></li></ol></li></ul></li><li>实际上，时间复杂度为<code>O(logn)</code>的搜索算法通常是基于分治策略实现的。例如二分查找和树<ul><li>二分查找的每一步都将问题(在数组中搜索目标元素)分解为一个小问题(在数组的一半中搜索目标元素)，这个过程一直持续到数组为空或找到目标元素为止</li><li>树是分治思想的代表，在二叉搜索树，AVL树，堆等数据结构中，各种操作的时间复杂度皆为O(logn)</li></ul></li><li>二分查找的分治策略如下<ul><li>问题可以分解：二分查找递归地将原问题(在数组中进行查找)分解为子问题(在数组的一半中进行查找)，这是通过比较中间元素和目标元素来实现的</li><li>子问题是独立的：在二分查找中，每轮只处理一个子问题，它不受其他子问题的影响</li><li>子问题的解无须合并：二分查找旨在查找一个特定元素，因此不需要将子问题的解进行合并。当子问题得到解决时，原问题也会同时得到解决</li></ul></li><li>分治能够提升搜索效率，本质上是因为暴力搜索每轮只能排除一个选项，而分治搜索每轮可以排除一半选项</li></ol><h3 id="1-2-1-基于分治实现的二分查找"><a href="#1-2-1-基于分治实现的二分查找" class="headerlink" title="1.2.1 基于分治实现的二分查找"></a>1.2.1 基于分治实现的二分查找</h3><ol><li>在之前的章节中，二分查找是基于迭代实现的。现在基于分治(递归)来实现它</li><li>从分治角度，我们将搜索区间[i,j]对应的子问题记为f(i,j)</li><li>以原问题<code>f(0,n-1)</code>为起始点，通过以下步骤进行二分查找<ul><li>计算搜索区间[i,j]的中点m，根据它排除一半的搜索区间</li><li>递归求解规模缩小一半的子问题，可能为f(i,m-1)或f(m+1,j)</li><li>循环第1步和第2步，直到找到target或区间为空时返回<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divideBinarySearchHelper</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> m=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">      <span class="keyword">return</span> divideBinarySearchHelper(nums, m+<span class="number">1</span>, right, target);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">      <span class="keyword">return</span> divideBinarySearchHelper(nums,left,m-<span class="number">1</span>,target);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divideBinarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> divideBinarySearchHelper(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>,target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-3-构建二叉树问题"><a href="#1-3-构建二叉树问题" class="headerlink" title="1.3 构建二叉树问题"></a>1.3 构建二叉树问题</h2><p>问题：给定一棵二叉树的前序遍历<code>preorder</code>和中序遍历<code>inorder</code>，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点</p><ul><li><img src="/images/AlgoGettingStart/img_82.png" alt="img_82.png"></li></ul><h3 id="1-3-1-判断是否为分治问题"><a href="#1-3-1-判断是否为分治问题" class="headerlink" title="1.3.1 判断是否为分治问题"></a>1.3.1 判断是否为分治问题</h3><p>原问题定义为从<code>preorder</code>和<code>inorder</code>构建二叉树，是一个典型的分治问题</p><ul><li>问题可以分解：从分治的角度切入，我们可以将原问题划分为两个子问题：构建左子树，构建右子树，加上一步操作：初始化根节点。而对于每棵子树(子问题)，我们仍可以复用以上划分方法，将其划分为更小的子树(子问题)，直至达到最小子问题(空子树)时终止</li><li>子问题是独立的：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需要关注中序遍历和前序遍历中与左子树对应的部分。右子树同理</li><li>子问题的解可以合并：一旦得到了左子树和右子树(子问题的解)，我们就可以将它们链接到根节点上，得到原问题的解</li></ul><h3 id="1-3-2-如何划分子树"><a href="#1-3-2-如何划分子树" class="headerlink" title="1.3.2 如何划分子树"></a>1.3.2 如何划分子树</h3><ol><li>根据以上分析，这道题可以使用分治来求解，但如何通过前序遍历<code>preorder</code>和中序遍历<code>inorder</code>来划分左子树和右子树呢？</li><li>根据定义，<code>preorder</code>和<code>inorder</code>都可以划分为三个部分<ul><li>前序遍历：<code>[根节点|左子树|右子树]</code>，例如上图的树对应[3|9|2 1 7]</li><li>中序遍历：<code>[左子树|根节点|右子树]</code>，例如上图的树对应[9|3|1 2 7]</li></ul></li><li>以上图数据为例，根据以下步骤得到划分结果<ul><li><ol><li>前序遍历的首元素3是根节点的值</li></ol></li><li><ol start="2"><li>查找根节点3在<code>inorder</code>中的索引，利用该索引可将<code>inorder</code>划分为&#96;[ 9 | 3 | 1 2 7]</li></ol></li><li><ol start="3"><li>根据<code>inorder</code>的划分结果，易得左子树和右子树的节点数量分别为1和3，从而可将<code>preorder</code>划分为<code>[ 3 | 9 | 2 1 7 ]</code></li></ol></li><li><img src="/images/AlgoGettingStart/img_83.png" alt="img_83.png"></li></ul></li></ol><h3 id="1-3-3-基于变量描述子树区间"><a href="#1-3-3-基于变量描述子树区间" class="headerlink" title="1.3.3 基于变量描述子树区间"></a>1.3.3 基于变量描述子树区间</h3><ol><li>根据以上划分方法，我们已经得到 根节点，左子树，右子树在preorder和inorder中的索引区间。而为了描述这些索引区间，我们需要借助几个指针变量<ul><li>将当前树的根节点在<code>preorder</code>中的索引记为i</li><li>将当前树的根节点在<code>inorder</code>中的索引记为m</li><li>将当前树在<code>inorder</code>中的索引区间记为<code>[l,r]</code></li></ul></li><li><img src="/images/AlgoGettingStart/img_84.png" alt="img_84.png"><ul><li>根据preorder中根节点的索引可以找到根节点，再到inorder序列中查询根节点值所在位置</li></ul></li><li><img src="/images/AlgoGettingStart/img_85.png" alt="img_85.png"></li></ol><h3 id="1-3-4-代码实现"><a href="#1-3-4-代码实现" class="headerlink" title="1.3.4 代码实现"></a>1.3.4 代码实现</h3><ol><li>为了提升查询m的效率，借助一个哈希表hmap来存储数组inorder中元素到索引的映射<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BNode <span class="title function_">buildBinaryTree</span><span class="params">(<span class="type">int</span>[] preOrder,<span class="type">int</span>[] inOrder)</span>&#123;</span><br><span class="line">   <span class="comment">//初始化哈希表，存储inorder元素到索引的映射</span></span><br><span class="line">   HashMap&lt;Integer, Integer&gt; hmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inOrder.length;i++)&#123;</span><br><span class="line">      hmap.put(inOrder[i],i);<span class="comment">//key是值，value是索引</span></span><br><span class="line">   &#125;</span><br><span class="line">   BNode root=buildBinaryTreeHelper(preOrder,<span class="number">0</span>,inOrder.length-<span class="number">1</span>,<span class="number">0</span>,hmap);</span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BNode <span class="title function_">buildBinaryTreeHelper</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> i, HashMap&lt;Integer,Integer&gt; hmap)</span>&#123;</span><br><span class="line">   <span class="comment">//子树区间为空时结束递归，表示null节点</span></span><br><span class="line">   <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//获得根节点的值</span></span><br><span class="line">   <span class="type">int</span> rootValue=preOrder[i];</span><br><span class="line">   <span class="comment">//根据值找到在inorder中的位置，依次划分inorder中左右子树所占数组的范围</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">in_rootIndex</span> <span class="operator">=</span> hmap.get(rootValue);</span><br><span class="line">   <span class="comment">//新建根节点</span></span><br><span class="line">   <span class="type">BNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BNode</span>(rootValue);</span><br><span class="line">   <span class="comment">//递归构建左右子树</span></span><br><span class="line">   node.left=buildBinaryTreeHelper(preOrder,  left, in_rootIndex-<span class="number">1</span>, i+<span class="number">1</span>, hmap);</span><br><span class="line">   node.right=buildBinaryTreeHelper(preOrder, in_rootIndex+<span class="number">1</span>, right, i+<span class="number">1</span>+(in_rootIndex-left), hmap);</span><br><span class="line">   <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>图示<ul><li><img src="/images/AlgoGettingStart/img_86.png" alt="img_86.png"></li><li><img src="/images/AlgoGettingStart/img_87.png" alt="img_87.png"></li><li><img src="/images/AlgoGettingStart/img_88.png" alt="img_88.png"></li></ul></li><li>设树的节点数量为n，初始化每一个节点(执行一个递归函数)使用O(1)时间。因此总体时间复杂度为O(n)</li><li>哈希表存储inorder元素到索引的映射，空间复杂度为O(n)。在最差情况下，即二叉树退化为链表时，递归深度达到n，使用O(n)的栈帧空间。因此总体空间复杂度为O(n)</li></ol><h2 id="1-4-汉诺塔问题"><a href="#1-4-汉诺塔问题" class="headerlink" title="1.4 汉诺塔问题"></a>1.4 汉诺塔问题</h2><ol><li>在归并排序和构建二叉树中，我们都是将原问题分解为两个规模为原问题一半的子问题。然而对于汉诺塔问题，我们采用不同的分解策略</li><li>问题：给定三根柱子，记为A,B和C。起始状态下，柱子A上套着n个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这n个圆盘移动到柱子C上，并保持它们的原有顺序不变。在移动圆盘过程中，需要遵守以下规则<ul><li>圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入</li><li>每次只能移动一个圆盘</li><li>小圆盘必须时刻位于大圆盘之上</li></ul></li><li>我们将规模为i的汉诺塔问题记作<code>f(i)</code>。例如f(3)代表将3个圆盘从A移动至C的汉诺塔问题</li></ol><h3 id="1-4-1-考虑基本情况"><a href="#1-4-1-考虑基本情况" class="headerlink" title="1.4.1 考虑基本情况"></a>1.4.1 考虑基本情况</h3><ol><li>对于<code>f(1)</code>，即当只有一个圆盘时，我们将它直接从A移动至C即可</li><li>对于<code>f(2)</code>，即当有两个圆盘时，由于要时刻满足小圆盘在大圆盘之上，因此需要借助B来完成移动<ul><li>先将上面的小圆盘从A移至B</li><li>再将大圆盘从A移至C</li><li>再将小圆盘从B移至C</li></ul></li><li>解决f(2)的过程可总结为：将两个圆盘借助B从A移至C。其中，C称为目标柱，B称为缓冲柱</li></ol><h3 id="1-4-2-子问题分解"><a href="#1-4-2-子问题分解" class="headerlink" title="1.4.2 子问题分解"></a>1.4.2 子问题分解</h3><ol><li>对于<code>f(3)</code>，即当有三个圆盘时。因为已知f(1)和f(2)的解，所以我们可以从分治角度思考。将A顶部的两个圆盘看作一个整体<ul><li>令B为目标柱，C为缓冲柱，将两个圆盘从A移至B</li><li>将A中剩余的一个圆盘从A直接移动至C</li><li>令C为目标柱，A为缓冲柱，将两个圆盘从B移至C</li></ul></li><li>从本质上看，我们将问题f(3)划分为两个子问题f(2)和一个子问题f(1)。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解可以合并</li><li>至此，可总结出汉诺塔问题的分治策略：将原问题f(n)划分为两个子问题f(n-1)和f(1)，并按照以下顺序解决这三个子问题<ul><li>将n-1个圆盘借助C从A移至B</li><li>将剩余1个圆盘从A直接移至C</li><li>将n-1个圆盘借助A从B移至C</li></ul></li><li>对于这两个子问题f(n-1)，可以通过相同的方式进行递归划分，直至达到最小子问题f(1)。而f(1)的解是已知的，只需一次移动操作即可<ul><li><img src="/images/AlgoGettingStart/img_89.png" alt="img_89.png"></li></ul></li></ol><h3 id="1-4-3-代码实现"><a href="#1-4-3-代码实现" class="headerlink" title="1.4.3 代码实现"></a>1.4.3 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(List&lt;Integer&gt; src,List&lt;Integer&gt; des)</span>&#123;</span><br><span class="line">   des.add(src.remove(src.size()-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanotaHelper</span><span class="params">(<span class="type">int</span> topi,List&lt;Integer&gt; src,List&lt;Integer&gt; buf,List&lt;Integer&gt; des)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(topi==<span class="number">1</span>)&#123;</span><br><span class="line">      move(src, des);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//子问题：将src顶部i-1个盘子通过des移动到buf</span></span><br><span class="line">   hanotaHelper(topi-<span class="number">1</span>,src,buf,des);</span><br><span class="line">   <span class="comment">//子问题：将src剩余的一个盘子直接移动到des</span></span><br><span class="line">   move(src, des);</span><br><span class="line">   <span class="comment">//子问题：将buf的i-1个盘子通过src移动到des</span></span><br><span class="line">   hanotaHelper(topi-<span class="number">1</span>,buf,src,des);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanota</span><span class="params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B,List&lt;Integer&gt; C)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=A.size();</span><br><span class="line">   hanotaHelper(n,A,B,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-复杂度分析"><a href="#1-4-4-复杂度分析" class="headerlink" title="1.4.4 复杂度分析"></a>1.4.4 复杂度分析</h3><ol><li>汉诺塔问题形成一个高度为n的递归树，每个节点代表一个子问题，对应开启一个hanotaHelper方法<ul><li><img src="/images/AlgoGettingStart/img_90.png" alt="img_90.png"></li></ul></li><li>时间复杂度为<code>O(2^n)</code></li><li>空间复杂度为<code>O(n)</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11回溯算法</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class11/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="1-1-回溯算法"><a href="#1-1-回溯算法" class="headerlink" title="1.1 回溯算法"></a>1.1 回溯算法</h2><ol><li>回溯算法<code>backtracking algorithm</code>是一种通过穷举来解决问题的方法。</li><li>回溯算法的核心思想是：从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到了解或者尝试了所有可能的选择都无法找到解为止</li><li>回溯算法通常采用“深度优先搜索”来遍历解空间。<ul><li>在“二叉树”章节中，提到前序，中序，后序遍历都属于深度优先搜索。</li></ul></li><li>利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理<ul><li>例题1：给定一个二叉树，搜索并记录所有值为7的节点，返回节点列表</li><li>对于该题，通过前序遍历这棵树，并判断当前节点的值是否为7，如果是则将该节点的值加入结果列表res之中</li><li><pre><code class="java">//示例代码/* 前序遍历：例题一 */public static void preOrder(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    if (root.val == 7) &#123;    // 记录解        res.add(root);    &#125;    preOrder(root.left);    preOrder(root.right);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    - ![img_91.png](/images/AlgoGettingStart/img_91.png)</span><br><span class="line">### 1.1.1 尝试与回退</span><br><span class="line">1. 之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。</span><br><span class="line">    - 当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择</span><br><span class="line">2. 对于上面的例题，访问每个节点都代表一次“尝试”，而越过叶节点或返回父节点的return则表示“回退”</span><br><span class="line">3. 值的说明的是：“回退并不仅仅包括函数返回”</span><br><span class="line">4. 例题2:在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径</span><br><span class="line">   - 在例题1代码的基础上，需要添加一个列表path记录访问过的节点的路径。当访问到值为7的节点时，则复制path并添加进结果列表res。遍历完成后，res中保存的就是所有的解</span><br><span class="line">   - ```java</span><br><span class="line">     public static void preOrder(TreeNode root)&#123;</span><br><span class="line">         if(root==null)&#123;</span><br><span class="line">             return ;</span><br><span class="line">         &#125;</span><br><span class="line">         path.add(root);</span><br><span class="line">         if(root.val==7)&#123;</span><br><span class="line">             res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">         &#125;</span><br><span class="line">         preOrder(root.left);</span><br><span class="line">         preOrder(root.right);  </span><br><span class="line">         //回退</span><br><span class="line">         path.remove(path.size()-1);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>在每次“尝试”中，我们通过将当前节点添加进path来记录路径；而在“回退”前，我们需要将该节点从path中弹出，以恢复本次尝试之前的状态</li></ol><h3 id="1-1-2-剪枝"><a href="#1-1-2-剪枝" class="headerlink" title="1.1.2 剪枝"></a>1.1.2 剪枝</h3><ol><li>复杂的回溯问题通常包含一个或多个约束条件，<em><strong>约束条件通常可用于“剪枝”</strong></em></li><li>例题3:在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3的节点<ul><li>为了满足以上“约束条件”，我们需要添加“剪枝操作”：在搜索过程中，若遇到值为3的节点，则提前返回，不再继续搜索</li><li><pre><code class="java">public static void preOrder(TreeNode root)&#123;    //剪枝    if(root==null||root.val==3)&#123;        return ;    &#125;    path.add(root);    if(root.val==7)&#123;        res.add(new ArrayList&lt;&gt;(path));    &#125;    preOrder(root.left);    preOrder(root.right);    path.remove(path.size()-1);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. “剪枝”是一个非常形象的名词。即在搜索过程中，我们“剪掉”了不满足约束条件的搜索分支，避免许多无意义的尝试，从而提高了搜索效率</span><br><span class="line">   - ![img_92.png](/images/AlgoGettingStart/img_92.png)</span><br><span class="line">### 1.1.3 框架代码</span><br><span class="line">1. 尝试将回溯的“尝试，回退，剪枝”的主体框架提炼出来，提高代码的通用性</span><br><span class="line">```java</span><br><span class="line">//示例代码</span><br><span class="line">//state表示问题的当前状态，choices表示当前状态下可以做出的选择</span><br><span class="line">public static void backTrack(State state, List&lt;Choice&gt; choices,List&lt;State&gt; res) &#123;</span><br><span class="line">    //判断是否为解</span><br><span class="line">   if(isSolution(state))&#123;</span><br><span class="line">       //记录解</span><br><span class="line">      recordSolution(state,res);</span><br><span class="line">      //不再继续搜索(看情况而定)</span><br><span class="line">      return ;</span><br><span class="line">   &#125;</span><br><span class="line">   //遍历所有选择</span><br><span class="line">   for(Choice choice:choices)&#123;</span><br><span class="line">       //剪枝：判断选择是否合法</span><br><span class="line">      if(isValid(state,choice))&#123;</span><br><span class="line">          //尝试：做出选择，更新状态</span><br><span class="line">         makeChoice(state,choice);</span><br><span class="line">         backTrack(state,choices,res);</span><br><span class="line">         //回退：撤销选择，恢复到之前的状态</span><br><span class="line">         undoChoice(state,choice);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>基于框架代码来解决例题三。状态state为节点遍历路径，选择choice为当前节点的左子节点和右子节点，结果res是路径列表<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSolution</span><span class="params">(List&lt;BNode&gt; state)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> !state.isEmpty()&amp;&amp;state.get(state.size()-<span class="number">1</span>).val==<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recordSolution</span><span class="params">(List&lt;BNode&gt; state,List&lt;List&lt;BNode&gt;&gt; res)</span>&#123;</span><br><span class="line">   res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(BNode choice)</span>&#123;</span><br><span class="line">   <span class="comment">//“剪枝”</span></span><br><span class="line">   <span class="keyword">if</span>(choice.val==<span class="number">3</span>||choice==<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undoChoice</span><span class="params">(List&lt;BNode&gt; state)</span>&#123;</span><br><span class="line">   state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">completeChoice</span><span class="params">(List&lt;BNode&gt; state,BNode choice)</span>&#123;<span class="comment">//完成选择</span></span><br><span class="line">   state.add(choice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;BNode&gt; state,List&lt;BNode&gt; choices,List&lt;List&lt;BNode&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isSolution(state))&#123;</span><br><span class="line">      recordSolution(state,res);</span><br><span class="line">      <span class="comment">//这里不return，因为还要继续向下遍历</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (BNode choice : choices) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isValid(choice))&#123;<span class="comment">//判断选择是否满足约束条件</span></span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         completeChoice(state,choice);<span class="comment">//makeChoice，完成选择，更新状态</span></span><br><span class="line">         backTrack(state, Arrays.asList(choice.left,choice.right),res);<span class="comment">//尝试</span></span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         undoChoice(state);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>许多回溯问题可以在该框架下解决。我们只需根据具体问题来定义“state”和“choices”，并实现框架中的各个方法即可</li></ol><h3 id="1-1-4-常用术语"><a href="#1-1-4-常用术语" class="headerlink" title="1.1.4 常用术语"></a>1.1.4 常用术语</h3><p><img src="/images/AlgoGettingStart/img_93.png" alt="img_93.png"></p><h3 id="1-1-5-优点与局限性"><a href="#1-1-5-优点与局限性" class="headerlink" title="1.1.5 优点与局限性"></a>1.1.5 优点与局限性</h3><ol><li>回溯算法本质上是一种“深度优先搜索”算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，且在合理的剪枝下，具有很高的效率</li><li>然而，在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受<ul><li>时间：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶</li><li>空间：在递归调用中需要保存当前的状态(例如路径，用于剪枝的辅助变量等)，当深度很大时，空间需求可能会变得很大</li></ul></li><li>即便如此，回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案。<ul><li>对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。</li><li>在这种情况下，关键是如何优化效率，常见的效率优化方法有两种<ul><li>剪枝：避免搜索那些肯定不会产生解的路径，从而节省时间和空间</li><li>启发式搜索：在搜索过程中引入一些策略或估计值，从而优先搜索最有可能产生有效解的路径</li></ul></li></ul></li></ol><h3 id="1-1-6-回溯典型例题"><a href="#1-1-6-回溯典型例题" class="headerlink" title="1.1.6 回溯典型例题"></a>1.1.6 回溯典型例题</h3><p>回溯算法可用于解决许多 搜索问题，约束满足问题和组合优化问题</p><ol><li>搜索问题：这类问题的目标是 找到满足特定条件的解决方案<ul><li>全排列问题：给定一个集合，求出其所有可能的排列组合</li><li>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集</li></ul></li><li>约束满足问题：这类问题的目标是 找到满足所有约束条件的解<ul><li>n皇后：在n*n的棋盘上放置n个皇后，使得它们互不攻击</li><li>数独：在9<em>9的网格中填入数字1~9，使得每行，每列和每3</em>3子网格中的数字不重复</li><li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</li></ul></li><li>组合优化问题：这类问题的目标是 在一个组合空间中找到满足某些条件的最优解<ul><li>0-1背包问题：给定一组物品和一个背包，每个物品具有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大</li><li>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径</li><li>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之前都有边相连</li></ul></li><li>请注意：对于许多组合优化问题，回溯不是最优解决方案<ul><li>0-1背包问题通常使用动态规划解决，以达到更高的时间效率</li><li>旅行商是一个著名的NP-Hard问题，常用解法有遗传算法和蚁群算法等</li><li>最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决</li></ul></li></ol><h2 id="1-2-全排列问题"><a href="#1-2-全排列问题" class="headerlink" title="1.2 全排列问题"></a>1.2 全排列问题</h2><ol><li>全排列问题是回溯算法的一个典型应用，它的定义是：<em><strong>在给定一个集合(如一个数组或字符串)的情况下，找出其中元素的所有可能的排列</strong></em></li><li><img src="/images/AlgoGettingStart/img_95.png" alt="img_95.png"></li></ol><h3 id="1-2-1-无相等元素的情况"><a href="#1-2-1-无相等元素的情况" class="headerlink" title="1.2.1 无相等元素的情况"></a>1.2.1 无相等元素的情况</h3><p>例题：输入一个整数数组，其中不包含重复元素，返回所有可能的排列</p><ol><li>从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果<ul><li>假设输入数组为[1,2,3]，如果我们先选择1，再选择3，最后选择2，则获得排列[1,3,2]。</li><li>回退表示撤销一个选择，之后继续尝试其他选择</li></ul></li><li>从回溯代码的角度看，候选集合choices是输入数组中的所有元素，状态state是直至目前已被选择的元素。<ul><li>请注意，每个元素只允许被选择一次，因此state中的所有元素都应该是唯一的</li></ul></li><li><img src="/images/AlgoGettingStart/img_96.png" alt="img_96.png"></li></ol><h4 id="1-2-1-1-重复选择剪枝"><a href="#1-2-1-1-重复选择剪枝" class="headerlink" title="1.2.1.1 重复选择剪枝"></a>1.2.1.1 重复选择剪枝</h4><ol><li>为了实现每个元素只被选择一次，我们考虑引入一个布尔型数组selected，其中<code>selected[i]</code>表示<code>choices[i]</code>是否已被选择，并基于它实现以下剪枝操作<ul><li>在做出选择choices[i]后，我们就讲selected[i]赋值为true，代表它已被选择</li><li>遍历选择列表choices时，跳过所有已被选择的节点，即剪枝</li><li><img src="/images/AlgoGettingStart/img_97.png" alt="img_97.png"></li><li>如图所示，该剪枝操作将搜索空间大小从O(n^n)减小至O(n!)</li></ul></li></ol><h4 id="1-2-1-2-代码实现"><a href="#1-2-1-2-代码实现" class="headerlink" title="1.2.1.2 代码实现"></a>1.2.1.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),nums,<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length],res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state.size()==choices.length)&#123;<span class="comment">//长度相等</span></span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> choice=choices[i];</span><br><span class="line">      <span class="keyword">if</span>(!selected[i])&#123;<span class="comment">//没被选择,剪枝</span></span><br><span class="line">         selected[i]=<span class="literal">true</span>;</span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         state.add(choice);</span><br><span class="line">         backTrack(state,choices,selected,res);</span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         selected[i]=<span class="literal">false</span>;</span><br><span class="line">         state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-考虑相等元素的情况"><a href="#1-2-2-考虑相等元素的情况" class="headerlink" title="1.2.2 考虑相等元素的情况"></a>1.2.2 考虑相等元素的情况</h3><p>例题：输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列</p><ol><li>假设输入数组为[1,1,2]。上述方法生成的排列有一半是重复的<ul><li><img src="/images/AlgoGettingStart/img_98.png" alt="img_98.png"></li></ul></li><li>如何去除重复的排列：最直接的，考虑借助一个哈希表，直接对排列结果进行去重。然而这样做不够优雅，因为生成重复排列的搜索分支没有必要，应当提前识别并剪枝，这样可以进一步提升算法效率</li></ol><h4 id="1-2-2-1-相等元素剪枝"><a href="#1-2-2-1-相等元素剪枝" class="headerlink" title="1.2.2.1 相等元素剪枝"></a>1.2.2.1 相等元素剪枝</h4><ol><li><img src="/images/AlgoGettingStart/img_99.png" alt="img_99.png"><ul><li>在第一轮中，选择1或1是等价的，在这两个选择之下生成的所有排列都是重复的。因此应该把其中一个1剪枝</li><li>在第一轮选择2之后，第二轮选择中的1和1也会产生重复分支，因此也应将第二轮的1剪枝</li></ul></li><li>从本质上看，我们的目标是在某一轮选择中，保证多个相等的元素仅被选择一次</li></ol><h4 id="1-2-2-2-代码实现"><a href="#1-2-2-2-代码实现" class="headerlink" title="1.2.2.2 代码实现"></a>1.2.2.2 代码实现</h4><p>在上一题的代码基础上，我们考虑在每一轮选择中开启一个哈希表duplicated(重复的)，用于记录该轮中已经尝试过的元素，并将重复元素剪枝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutationsI</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(),nums,<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length],res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state.size()==choices.length)&#123;<span class="comment">//长度相等</span></span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   HashSet&lt;Integer&gt; duplicated = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> choice=choices[i];</span><br><span class="line">      <span class="keyword">if</span>(!selected[i]&amp;&amp;!duplicated.contains(choice))&#123;<span class="comment">//没被选择,剪枝</span></span><br><span class="line">         selected[i]=<span class="literal">true</span>;</span><br><span class="line">         duplicated.add(choice);</span><br><span class="line">         <span class="comment">//“尝试”</span></span><br><span class="line">         state.add(choice);</span><br><span class="line">         backTrack(state,choices,selected,res);</span><br><span class="line">         <span class="comment">//“回退”</span></span><br><span class="line">         selected[i]=<span class="literal">false</span>;</span><br><span class="line">         state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>时间复杂度为<code>O(n!n)</code>：假设元素两两之间互不相同，则n个元素共有n!中排列(阶乘)；在记录结果时，需要复制长度为n的列表，需要O(n)的时间，因此时间复杂度为O(n!n)</li><li>空间复杂度为<code>O(n^2)</code>：最大递归深度为n，使用O(n)栈帧空间。selected使用O(n)空间。同一时刻最多共有n个duplicated，使用O(n^2)空间</li></ol><h4 id="1-2-2-3-两种剪枝对比"><a href="#1-2-2-3-两种剪枝对比" class="headerlink" title="1.2.2.3 两种剪枝对比"></a>1.2.2.3 两种剪枝对比</h4><p>虽然，selected和duplicated都用于剪枝，但两者的目标不同</p><ul><li>重复选择剪枝：整个搜索过程中只有一个selected。它记录的是当前状态中包含哪些元素，其作用是避免某个元素在state中重复出现<ul><li>作用在纵向的递归路线上进行剪枝</li></ul></li><li>相等元素剪枝：每轮选择(每个调用的backtrack方法)都包含一个duplicated。它记录的是在本轮遍历(for循环)中哪些元素已被选择过，其作用是保证相等元素只被选择过一次<ul><li>作用在横向的迭代路线上进行剪枝</li></ul></li></ul><p><img src="/images/AlgoGettingStart/img_100.png" alt="img_100.png"></p><h2 id="1-3-子集和问题"><a href="#1-3-子集和问题" class="headerlink" title="1.3 子集和问题"></a>1.3 子集和问题</h2><h3 id="1-3-1-无重复元素的情况"><a href="#1-3-1-无重复元素的情况" class="headerlink" title="1.3.1 无重复元素的情况"></a>1.3.1 无重复元素的情况</h3><p>例题1:给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复的组合</p><ul><li>例如，输入集合{3,4,5}和目标整数9，解为{3,3,3},{4,5}。需要注意以下两点<ul><li>输入集合中的元素可以被无限次重复选取</li><li>子集不区分元素顺序，比如{4,5}和{5,4}是同一个子集</li></ul></li></ul><h4 id="1-3-1-1-参考全排列解法"><a href="#1-3-1-1-参考全排列解法" class="headerlink" title="1.3.1.1 参考全排列解法"></a>1.3.1.1 参考全排列解法</h4><ol><li>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于target时，就将子集记录至结果列表</li><li>而与全排列不同的是，本题集合中的元素可以被无限次选取，因此无须借助selected布尔列表来记录元素是否已被选择<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">//子集和等于target时，记录解</span></span><br><span class="line">    <span class="keyword">if</span>(total==target)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; choices.length;i++)&#123;</span><br><span class="line">        <span class="comment">//剪枝，如果total+choice&gt;target，直接continue</span></span><br><span class="line">       <span class="keyword">if</span>(total+choices[i]&gt;target)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//尝试</span></span><br><span class="line">       state.add(choices[i]);</span><br><span class="line">       backTrack(state,target,total+choices[i],choices,res);</span><br><span class="line">       <span class="comment">//回退</span></span><br><span class="line">       state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">    backTrack(state,target,total,nums,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>向以上代码输入数组[3,4,5]和目标元素9，输出结果为[3,3,3],[4,5],[5,4]。虽然成功找出了所有和为9的子集，但其中存在重复的子集[4,5]和[5,4]<ul><li>这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。</li><li><img src="/images/AlgoGettingStart/img_101.png" alt="img_101.png"></li><li>先选4后选5 和 先选5后选4 是不同的分支，但对应同一个子集</li></ul></li><li>为了去除重复子集，一种直接的思路是对结果列表进行去重。但是这个方法效率很低，有两方面原因<ul><li>当数组元素较多，尤其是target较大时，搜索过程会产生大量的重复子集</li><li>比较子集(数组)的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同</li></ul></li></ol><h4 id="1-3-1-2-重复子集剪枝"><a href="#1-3-1-2-重复子集剪枝" class="headerlink" title="1.3.1.2 重复子集剪枝"></a>1.3.1.2 重复子集剪枝</h4><ol><li>考虑在搜索过程中通过剪枝进行去重。</li><li>重复子集是在 以不同顺序选择数组元素时产生的<ul><li>当第一轮和第二轮分别选择3和4时，会生成包含这两个元素的所有子集，记为[3,4..]</li><li>之后，当第一轮选择4时，则第二轮应该跳过3，因为该选择产生的子集[4,3…]和第1步中生成的子集完全重复</li></ul></li><li><img src="/images/AlgoGettingStart/img_102.png" alt="img_102.png"></li><li>总结来看，给定输入数组[x1,x2,x3,x4…,xn]，搜索过程中的选择序列为[Xi1,Xi2,….Xin]，则该选择序列需要满足<code>i1&lt;=i2&lt;=...&lt;=in</code>(递归纵向而言的)</li></ol><h4 id="1-3-1-3-代码实现"><a href="#1-3-1-3-代码实现" class="headerlink" title="1.3.1.3 代码实现"></a>1.3.1.3 代码实现</h4><ol><li>为了实现该剪枝，初始化变量start，用于指示遍历起始点。当做出选择Xi后，设定下一轮从索引i开始遍历。<ul><li>这样做就可以让选择序列满足i1&lt;&#x3D;i2&lt;&#x3D;…&lt;&#x3D;im,从而保证子集唯一</li></ul></li><li>除此之外，还对代码进行了以下两项优化<ul><li>在开启搜索前，现将数据nums排序。在遍历所有选择时，当子集和超过target时直接结束循环，因为后面的元素更大，其子集和一定超过taget</li><li>省区元素和 变量total，通过在target上执行剑法来统计元素和，当target等于0时记录解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state,<span class="type">int</span> target,<span class="type">int</span> start,<span class="type">int</span>[] choices,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt; choices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target-choices[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//“尝试”</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        backTrack(state,target-choices[i],i,choices,res);</span><br><span class="line">        <span class="comment">//“回退”</span></span><br><span class="line">       state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backTrack(state,target,start,nums,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/AlgoGettingStart/img_103.png" alt="img_103.png"></li></ul></li></ol><h3 id="1-3-2-考虑重复元素的情况"><a href="#1-3-2-考虑重复元素的情况" class="headerlink" title="1.3.2 考虑重复元素的情况"></a>1.3.2 考虑重复元素的情况</h3><p>问题：给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组可能“包含重复元素”，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合</p><ol><li>相比于上题，本题的输入数组可能包含重复元素，这引入了新的问题。例如，给定数组[4,4,5]和目标元素9，则现有代码的输出结果为[4,5]和[4,5]，出现了重复子集</li><li>造成这种重复的原因是相等元素在某轮中被多次选择<ul><li><img src="/images/AlgoGettingStart/img_104.png" alt="img_104.png"></li></ul></li></ol><h4 id="1-3-2-1-相等元素剪枝"><a href="#1-3-2-1-相等元素剪枝" class="headerlink" title="1.3.2.1 相等元素剪枝"></a>1.3.2.1 相等元素剪枝</h4><ol><li>为解决此问题，我们需要限制相等元素在每一轮中只能被选择一次。实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。<ul><li>这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过了，因此直接跳过当前元素(剪枝)</li></ul></li><li>与此同时，本题规定每个数组元素只能被选择一次。幸运的是，我们也可以利用变量start来满足该约束：当做出选择Xi后，设定下一轮从索引i+1开始向后遍历。这样可以避免重复选择元素</li></ol><h4 id="1-3-2-2-代码实现"><a href="#1-3-2-2-代码实现" class="headerlink" title="1.3.2.2 代码实现"></a>1.3.2.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      state.add(choices[i]);</span><br><span class="line">      backTrack(state, target - choices[i], i + <span class="number">1</span>, choices, res);</span><br><span class="line">      state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumII</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   Arrays.sort(nums);</span><br><span class="line">   backTrack(state,target,start,nums,res);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/AlgoGettingStart/img_105.png" alt="img_105.png"></p><h2 id="1-4-N皇后问题"><a href="#1-4-N皇后问题" class="headerlink" title="1.4 N皇后问题"></a>1.4 N皇后问题</h2><p>问题：根据国际象棋的规则，皇后可以攻击与其处于同一行，一列或一条斜线上的棋子。给定n个皇后和一个n*n大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案</p><ol><li><img src="/images/AlgoGettingStart/img_106.png" alt="img_106.png"><ul><li>从回溯算法的角度看，n*n大小的棋盘共有n^2个格子，给出了所有的选择choices。</li><li>在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘状态就是state</li></ul></li><li><img src="/images/AlgoGettingStart/img_107.png" alt="img_107.png"><ul><li>本题的三个约束条件：多个皇后不能在同一行，同一列，同一条对角线上。</li><li>对角线分为主对角线和辅对角线两种</li></ul></li></ol><h3 id="1-4-1-逐行放置策略"><a href="#1-4-1-逐行放置策略" class="headerlink" title="1.4.1 逐行放置策略"></a>1.4.1 逐行放置策略</h3><ol><li>皇后的数量和棋盘的行数都为n，因此我们容易得到一个推论：棋盘每行都允许且只允许放置一个皇后</li><li>也就是说，可以采取逐行放置策略：从第一行开始，在每行放置一个皇后，直至最后一行结束</li><li><img src="/images/AlgoGettingStart/img_108.png" alt="img_108.png"></li><li>从本质上看，逐行放置策略起到了剪枝的作用，它避免了同一行出现多个皇后的所有搜索分治</li></ol><h3 id="1-4-2-列与对角线剪枝"><a href="#1-4-2-列与对角线剪枝" class="headerlink" title="1.4.2 列与对角线剪枝"></a>1.4.2 列与对角线剪枝</h3><ol><li>为了满足列约束，可以利用一个长度为n的布尔型数组cols记录每一列是否有皇后。在每次决定放置前，我们通过cols将已有皇后的列进行剪枝，并在回溯中动态更新cols的状态</li><li>对角线上所有格子的row-col为恒定值，辅对角线上所有鸽子的row+col是恒定值</li><li>因此可以借助布尔型数组diags1和diags2记录主对角线和辅对角线上是否有皇后</li><li><img src="/images/AlgoGettingStart/img_109.png" alt="img_109.png"></li></ol><h3 id="1-4-3-代码实现"><a href="#1-4-3-代码实现" class="headerlink" title="1.4.3 代码实现"></a>1.4.3 代码实现</h3><p>n维方阵中row-col的范围是[-n+1,n-1]，row+col的范围是[0,2n-2]，所以主对角线和辅对角线的数量都为2n-1，即数组diags1和diags2的长度都为2n-1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   List&lt;List&lt;List&lt;String&gt;&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   List&lt;List&lt;String&gt;&gt; state=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      ArrayList&lt;String&gt; col = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">         col.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      state.add(col);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">   <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">   <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">   backTrack(<span class="number">0</span>,n,state,res,cols,diags1,diags2);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state,</span></span><br><span class="line"><span class="params">                             List&lt;List&lt;List&lt;String&gt;&gt;&gt; res,<span class="type">boolean</span>[] cols,<span class="type">boolean</span>[] diags1,<span class="type">boolean</span>[] diags2)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">      List&lt;List&lt;String&gt;&gt; tmp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (List&lt;String&gt; strings : state) &#123;</span><br><span class="line">         tmp.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(strings));</span><br><span class="line">      &#125;</span><br><span class="line">      res.add(tmp);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">      <span class="type">int</span> diag1=row-col+n-<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> diag2=row+col;</span><br><span class="line">      <span class="keyword">if</span>(!(cols[col]||diags1[diag1]||diags2[diag2]))&#123;</span><br><span class="line">         state.get(row).set(col,<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">         cols[col]=diags1[diag1]=diags2[diag2]=<span class="literal">true</span>;</span><br><span class="line">         backTrack(row+<span class="number">1</span>,n,state,res,cols,diags1,diags2);</span><br><span class="line">         cols[col]=diags1[diag1]=diags2[diag2]=<span class="literal">false</span>;</span><br><span class="line">         state.get(row).set(col,<span class="string">&quot;#&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>逐行放置n次，考虑列约束则从第一行到最后一行分别有n,n-1,…,2,1个选择，使用O(n!)时间。当记录解时，需要复制矩阵并添加进res，复制操作使用O(n^2)时间。因此，总体时间复杂度为<code>O(n^2n!)</code><ul><li>实际上，根据对角线约束的剪枝也能够大幅缩小搜索空间，因而搜索效率往往优于以上时间复杂度</li></ul></li><li>数据state使用O(n^2)空间，数据cols,diags1,diags2皆使用<code>O(n)</code>空间。最大递归深度为n，使用O(n)栈帧空间。因此空间复杂度为O(n^2)</li></ol><h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><ol><li>回溯算法本质是穷举法，通过对解空间进行深度优先遍历来寻找符合条件的解。在搜索过程中，遇到满足条件的解则记录，直至找到所有解或遍历完成后结束</li><li>回溯算法的搜索过程包括尝试和回退两个部分。它通过深度优先搜索来尝试各种选择，当遇到不满足约束条件的情况时，则撤销上一步的选择，退回到之前的状态，并继续尝试其他选择。尝试与回退是两个 方向相反的操作</li><li>回溯问题通常包含多个约束条件，它们可用于实现剪枝操作。剪枝可以提前结束不必要的搜索分支，大幅提升搜索效率</li><li>回溯算法主要可用于解决搜索问题和约束满足问题。组合优化问题虽然可以用回溯算法解决，但往往存在效率更高或效果更好的解法</li><li>全排列问题旨在搜索给定集合元素的所有可能的排列。借助一个数组来记录每个元素是否被选择,剪掉重复选择同一元素的搜索分支，确保每个元素只被选择一次</li><li>在全排列问题中，如果集合中存在重复元素，则最终结果会出现重复排列。需要约束相等元素在每轮中只能被选择一次，这通常借助一个哈希表来实现</li><li>子集和问题的目标是在给定集合中找到和为目标值的所有子集。集合不区分元素顺序，而搜索过程会输出所有顺序的结果，产生重复子集。我们在回溯前将数据进行排序，并设置一个变量来指示每一轮遍历的起始点，从而将产生重复子集的搜索分支进行剪枝</li><li>对于子集和问题，数组中的相等元素会产生重复集合。我们利用数组已排序的前置条件，通过判断相邻元素是否相等实现剪枝，从而确保相等元素在每轮中只能被选中一次</li><li>n皇后问题旨在寻找将n个皇后放置到n*n尺寸棋盘上的方案，要求所有皇后两两之间无法攻击对方。该问题的约束条件有 行约束，列约束，主对角线和辅对角线约束。为满足行约束，我们采用按行放置的策略，保证每行只放置一个皇后</li><li>列约束和对角线约束的处理方式类似。对于列约束，我们利用一个数组来记录每一列是否有皇后，从而指示选中的格子是否合法。对于对角线约束，我们借助两个数组来分别记录该对角线上是否存在皇后，难点在于找处在同一主(副)对角线上的格子满足的索引规律</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04哈希表</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class4/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><ol><li>哈希表，又称散列表，它通过建立 键<code>key</code>与值<code>value</code>之间的映射，实现“高效的元素查询O(1)”</li></ol><h3 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h3><ol><li>get：查询</li><li>put：修改，添加</li><li>remove：移除</li><li>遍历方式：<ul><li>遍历键值对–entrySet</li><li>遍历键–keySet</li><li>遍历值–values</li></ul></li></ol><h3 id="哈希表简单实现"><a href="#哈希表简单实现" class="headerlink" title="哈希表简单实现"></a>哈希表简单实现</h3><ol><li>在哈希表中，将数组中的每个空位称为 <code>桶bucket</code>。每个桶可存储一个键值对，因此，查询操作就是找到key对应的桶，并在桶中获取value</li><li>基于key定位对应的桶：通过<code>哈希函数(hash function)</code>实现<ul><li>哈希函数的作用是将 一个较大的输入空间映射到一个较小的输出空间</li><li>在哈希表中，输入空间是所有 <code>key/hash(key)</code>，输出空间是所有index</li><li>即我们可以通过哈希函数得到key对应的键值对在数组中的存储位置</li></ul></li><li>哈希函数的计算过程<ul><li>通过某种哈希算法<code>hash()</code>计算得到哈希值</li><li>将哈希值对桶数量(数组长度)capacity取模，从而获取该key对应的数组索引index<ul><li>对capacity取模：保证了结果都在索引范围内—&gt;将较大的输入空间映射到较小的输出空间</li></ul></li></ul></li></ol><h3 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h3><ol><li>哈希函数的作用是将所有key构成的输入空间映射到数组所有索引构成的输出空间。而输入空间往往大于输出空间。因此,<em><strong>理论上一定存在“多个输入对应相同输出”的情况</strong></em>–&gt;哈希冲突</li><li>哈希表容量越大，多个key被分配到同一个桶中的概率就越低，冲突就越少。所以可以通过扩容哈希表来减少哈希冲突</li><li>编程语言通常会预留足够大的哈希表容量，防止频繁扩容<ul><li>因为扩容的代价很大：</li><li>1:类似于数组扩容，哈希表扩容需要将所有键值对拷贝至新哈希表</li><li>2:由于容量capacity的改变，每个键值对都要重新使用哈希函数计算索引</li></ul></li><li>负载因子(load factor)用于衡量哈希冲突的严重程度，常作为哈希表扩容的触发条件</li></ol><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希表扩容操作效率太低。为了提升效率，采用以下策略  </p><ol><li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作</li><li>仅在必要时，即当哈希冲突比较严重时(load factor)，才执行扩容操作</li></ol><h4 id="哈希表的结构改良方法主要包括“链式地址”和“开放寻址”"><a href="#哈希表的结构改良方法主要包括“链式地址”和“开放寻址”" class="headerlink" title="哈希表的结构改良方法主要包括“链式地址”和“开放寻址”"></a>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”</h4><h3 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h3><ol><li>在原始哈希表中，每个bucket仅能存储一个键值对</li><li>链式地址 将单个元素转换为链表(即每个bucket存储一个链表)，将键值对作为链表节点，将所有发生哈希冲突的键值对都存储在同一链表中</li><li><img src="/images/AlgoGettingStart/image-7.png" alt="Alt text"></li></ol><h4 id="基于链式地址实现的哈希表的操作方法发生了变化"><a href="#基于链式地址实现的哈希表的操作方法发生了变化" class="headerlink" title="基于链式地址实现的哈希表的操作方法发生了变化"></a>基于链式地址实现的哈希表的操作方法发生了变化</h4><ol><li>查询元素：输入key，经过哈希函数可以得到index，即可访问链表头节点，然后遍历链表并对比key(“&#x3D;&#x3D;”or”equals”)以查找目标键值对</li><li>添加元素：首先通过哈希函数得到index，再遍历链表对比key，如果key相等，那么添加失败。如果key不相等，那么将该键值对添加到链表尾部</li><li>删除元素：首先通过哈希函数得到index，再遍历链表对比key，找到目标节点并将其删除</li></ol><h4 id="链式地址存在以下局限性"><a href="#链式地址存在以下局限性" class="headerlink" title="链式地址存在以下局限性"></a>链式地址存在以下局限性</h4><ol><li>占用空间增大：链表包括节点指针，更加耗费空间</li><li>查询效率降低：需要线性遍历链表</li></ol><h4 id="当链表很长时，查询效率很差。此时可以将链表转换为“AVL树”或“红黑树”，从而将查询操作的时间复杂度优化"><a href="#当链表很长时，查询效率很差。此时可以将链表转换为“AVL树”或“红黑树”，从而将查询操作的时间复杂度优化" class="headerlink" title="当链表很长时，查询效率很差。此时可以将链表转换为“AVL树”或“红黑树”，从而将查询操作的时间复杂度优化"></a>当链表很长时，查询效率很差。此时可以将链表转换为“AVL树”或“红黑树”，从而将查询操作的时间复杂度优化</h4><h3 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h3><ol><li>开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括“线性探测，平方探测和多次哈希等”</li><li>开放寻址哈希表都存在“不能直接删除元素”的问题</li></ol><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><ol><li>线性探测采用 固定步长 的线性搜索来进行探测(处理哈希冲突)<ul><li>插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历(步长通常为1)，直至找到空桶，将元素插入其中</li><li>查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历。直到找到对应元素。如果遇到空桶，说明目标元素不在哈希表中</li><li>理解：将链式地址的 横向链表 改为数组中的 纵向元素。</li></ul></li><li>线性探测容易产生“聚集现象”。<ul><li>数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大(即索引不同的key发现位置也被占了)从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删改查操作效率劣化</li></ul></li><li>我们不能在开放寻址哈希表中直接删除元素<ul><li>这是因为删除元素会在连续排列的元素中产生一个空位(在数组中产生一个空桶)，而当查询元素时，线性探测到该空桶就会返回，导致空桶后面的元素都无法被正常访问</li></ul></li><li>为了解决这个问题，可以采用<code>懒删除 lazy deletion</code><ul><li>不直接从哈希表中移除元素，而是利用一个常量<code>TOMBSTONE</code>来标记这个桶</li><li>在该机制下，null和TOMBSTONE都代表空桶，都可以放置键值对。但是线性探测到null时会直接返回，而线性探测到TOMBSTONE则会继续遍历</li></ul></li><li>然而，懒删除可能会加速哈希表的性能退化<ul><li>因为每次删除操作都不会真正将该对象移除，随着TOMBSTONE的增加，导致“无效数据量”增加，导致搜索时间的增加(因为线性探测可能需要跳过多个TOMBSTONE才能找到目标元素)</li></ul></li><li>为了解决这个问题，考虑在线性探测中记录遇到的 首个TOMBSTONE索引，并将搜索到的目标元素与该TOMBSTONE交换位置—&gt;当每次 查询或添加元素 时，元素会被移动至距离理想位置(探测起始点)更近的桶，从而优化查询效率</li><li></li></ol><h4 id="平方探测-更改步长"><a href="#平方探测-更改步长" class="headerlink" title="平方探测(更改步长)"></a>平方探测(更改步长)</h4><ol><li>平方探测与线性探测类似，区别在于当发生哈希冲突时，平方探测不是简单的跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即”1,4,9,…”</li><li>平方探测主要具有以下优势<ul><li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应</li><li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布的更加均匀</li></ul></li><li>平方探测的弊端<ul><li>仍然存在聚集现象，即某些位置比其他位置更容易被占用</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它</li></ul></li></ol><h4 id="多次哈希"><a href="#多次哈希" class="headerlink" title="多次哈希"></a>多次哈希</h4><ol><li>多次哈希方法使用多个哈希函数进行探测<ul><li>插入元素：若哈希函数f1(x)出现冲突，则尝试f2(x)，以此类推，直到找到空位后插入元素</li><li>查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回。如果遇到空位(说明该元素没被添加)或已尝试所有哈希函数(但是仍没找到)，说明哈希表中不存在该元素</li></ul></li><li>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量</li></ol><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><ol><li>无论是开放寻址还是链式寻址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生</li><li>如果哈希冲突过于频繁，哈希表的性能则会急剧劣化(降低查询效率)</li><li>键值对的分布情况(index)由哈希函数决定<code>index=hash(key)%capacity</code>，即当capacity不变时，<code>哈希算法hash</code>决定了index(键值对在哈希表中的分布情况)</li></ol><h3 id="哈希算法的目标"><a href="#哈希算法的目标" class="headerlink" title="哈希算法的目标"></a>哈希算法的目标</h3><ol><li>为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点<ul><li>确定性：对于相同的输入，哈希算法应始终产生相同的输出，以确保哈希表是可靠的</li><li>效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高</li><li>均匀分布：哈希算法应使得键值对均匀分布在哈希表中，分布越均匀，哈希冲突的概率越低</li></ul></li><li>哈希算法在其他领域的使用：<ul><li>密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确</li><li>数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送，接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整</li></ul></li><li>对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高级的安全特性<ul><li>单向性：无法通过哈希值反推出关于输入数据的任何信息</li><li>抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同</li><li>雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化</li></ul></li><li>“均匀分布”和“抗碰撞性”是两个独立的概念</li></ol><h3 id="哈希算法的设计"><a href="#哈希算法的设计" class="headerlink" title="哈希算法的设计"></a>哈希算法的设计</h3><ol><li>加法哈希：对输入的每个字符的ASCII码进行相加，将得到的总和作为哈希值</li><li>乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的ASCII码累积到哈希值中</li><li>异或哈希：将输入数据的每个元素通过异或操作累积到哈希值中</li><li>旋转哈希：将每个字符的ASCII码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作</li><li>每种哈希算法的最后一步都是对大质数1000000007取模，可以最大化的保证哈希值的均匀分布<ul><li>因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突</li><li><img src="/images/AlgoGettingStart/image-8.png" alt="Alt text"></li><li>如果能保证key时随机均匀分布的，那么选择质数或合数作为模数都可以。而当key的分布存在某种周期性时，对合数取模更容易出现聚集现象</li><li>总之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性的key带来的聚集现象，提升哈希算法的稳定性</li></ul></li></ol><h3 id="常见哈希算法"><a href="#常见哈希算法" class="headerlink" title="常见哈希算法"></a>常见哈希算法</h3><ol><li>在实际中，我们通常会用一些标准哈希算法，可以将任意长度的输入数据映射到恒定长度的哈希值<ul><li><img src="/images/AlgoGettingStart/image-9.png" alt="Alt text"></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09排序算法</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class9/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class9/</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1-1-排序算法"><a href="#1-1-排序算法" class="headerlink" title="1.1 排序算法"></a>1.1 排序算法</h2><ol><li>排序算法<code>sorting algorithm</code>用于对一组数据按照“特定顺序”进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效的查找，分析和处理</li><li><img src="/images/AlgoGettingStart/img_44.png" alt="img_44.png"><ul><li>排序算法中的数据类型可以是整数，浮点数，字符或字符串等。排序的判断规则可根据需求设定，如数字大小，字符ASCII码顺序或自定义规则(<code>comparator</code>)</li></ul></li></ol><h3 id="1-1-1-评价维度"><a href="#1-1-1-评价维度" class="headerlink" title="1.1.1 评价维度"></a>1.1.1 评价维度</h3><ol><li>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少(时间复杂度中的常数项变小)。对于大数据量的情况，运行效率显得尤为重要</li><li>就地性：顾名思义，“原地排序”通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快</li><li>稳定性：“稳定排序”在完成排序后，“相等元素”在数组中的“相对顺序”不发生改变<ul><li>稳定排序是多极排序场景的必要条件(你的排序不能破坏别人排序的成果)</li><li><img src="/images/AlgoGettingStart/img_45.png" alt="img_45.png"></li></ul></li><li>自适应性：“自适应排序”的时间复杂度会受输入数据的影响，即最佳时间复杂度，最差时间复杂度，平均时间复杂度并不完全相等<ul><li>自适应性需要根据具体情况来评估。</li><li>如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性</li><li>如果最佳时间复杂度优于平均时间复杂度，说明排序算法在某些数据下性能可能优化，因此被视为正面属性</li></ul></li><li>是否基于比较：“基于比较的排序”依赖比较运算符(&lt;,&#x3D;,&gt;)来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为O(nlogn)。而“非比较排序”不使用比较运算符，时间复杂度可达O(n)，但其通用性相对较差</li></ol><h3 id="1-1-2-理想排序算法"><a href="#1-1-2-理想排序算法" class="headerlink" title="1.1.2 理想排序算法"></a>1.1.2 理想排序算法</h3><ol><li>运行快，原地，稳定，正向自适应，通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，“需要根据具体的数据特点和问题需求来决定”</li></ol><h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><ol><li>选择排序<code>selection sort</code>的工作原理非常简单:开启一个循环，每轮从“未排序区间”选择最小的元素，将其放到已排序区间的末尾</li><li>设数组的长度为n，选择排序的算法流程如下：<ul><li>1.初始状态下，所有元素未排序，即未排序(索引)区间为[0,n-1]</li><li>2.选取区间[0,n-1]中的最小元素，将其与索引0处的元素交换。完成后，数组前1个元素已排序</li><li>3.选取区间[1,n-1]中的最小元素，将其与索引1处的元素交换。完成后，数组前2个元素已排序</li><li>4.以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序</li><li>5.仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外循环，等待排序的索引位置为i，只用对前n-1个元素进行排序</span></span><br><span class="line">      <span class="type">int</span> minIndex=i;<span class="comment">//记录最小索引</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt; nums.length;j++)&#123;<span class="comment">//在未排序区间[i,n-1]中寻找最小元素</span></span><br><span class="line">         minIndex=nums[j]&lt;nums[minIndex]?j:minIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,minIndex);<span class="comment">//交换元素</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-1-算法特性"><a href="#1-2-1-算法特性" class="headerlink" title="1.2.1 算法特性"></a>1.2.1 算法特性</h3><ol><li>时间复杂度为<code>O(n^2)</code>，非自适应排序：外循环一共包括n-1轮，第一轮的未排序区间长度为n，最后一轮的未排序区间长度为2，求和为 (n-1)(n+2)&#x2F;2即O(n^2)</li><li>空间复杂度为<code>O(1)</code>，原地排序：指针i和指针j使用常数大小的额外空间</li><li>非稳定排序：如图所示<ul><li><img src="/images/AlgoGettingStart/img_46.png" alt="img_46.png"></li></ul></li></ol><h2 id="1-3-冒泡排序"><a href="#1-3-冒泡排序" class="headerlink" title="1.3 冒泡排序"></a>1.3 冒泡排序</h2><ol><li>冒泡排序<code>bubble sort</code>通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序</li><li>冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素&gt;右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端<ul><li>第i轮，将第i大(小)的元素放在倒数第i个位置</li></ul></li><li>图示：<ul><li><img src="/images/AlgoGettingStart/img_47.png" alt="img_47.png"></li><li><img src="/images/AlgoGettingStart/img_48.png" alt="img_48.png"></li><li><img src="/images/AlgoGettingStart/img_49.png" alt="img_49.png"></li><li><img src="/images/AlgoGettingStart/img_50.png" alt="img_50.png"></li><li><img src="/images/AlgoGettingStart/img_51.png" alt="img_51.png"></li><li><img src="/images/AlgoGettingStart/img_52.png" alt="img_52.png"></li><li><img src="/images/AlgoGettingStart/img_53.png" alt="img_53.png"></li></ul></li></ol><h3 id="1-3-1-算法流程"><a href="#1-3-1-算法流程" class="headerlink" title="1.3.1 算法流程"></a>1.3.1 算法流程</h3><p>设数组的长度为n，冒泡排序的步骤为：</p><ul><li>1.首先，对n个元素执行“冒泡”，将数组的最大元素交换至正确位置</li><li>2.接下来，对剩余n-1个元素执行“冒泡”，将第二大元素交换至正确位置</li><li>3.以此类推，经过n-1轮“冒泡”后，前n-1大的元素都被交换至正确位置</li><li>4.仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</li><li><img src="/images/AlgoGettingStart/img_54.png" alt="img_54.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> length= nums.length;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;<span class="comment">//只需要进行n-1次排序</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-<span class="number">1</span>-i;j++)&#123;<span class="comment">//每轮都在未排序区间,通过相邻元素的比较和交换,将最大的元素移动到右端</span></span><br><span class="line">         <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-2-效率优化"><a href="#1-3-2-效率优化" class="headerlink" title="1.3.2 效率优化"></a>1.3.2 效率优化</h3><ol><li>如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。</li><li>因此，我们可以增加一个<code>标志位flag</code>来监测这种情况，一旦出现就立即返回</li><li>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为<code>O(n^2)</code>。但当输入数组完全有序时，可达到最佳时间复杂度O(n)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSortWithFlag</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> length= nums.length;</span><br><span class="line">   <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">            flag=<span class="literal">false</span>;<span class="comment">//只要执行一次swap那么flag就为false不会导致循环终止</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-3-算法特性"><a href="#1-3-3-算法特性" class="headerlink" title="1.3.3 算法特性"></a>1.3.3 算法特性</h3><ol><li>时间复杂度<code>O(n^2)</code>，自适应排序：各轮“冒泡”遍历的数组长度依次为n-1,n-2,…,2,1。总和为 (n-1)n&#x2F;2。在引入flag优化后，最佳时间复杂度可达到<code>O(n)</code></li><li>空间复杂度<code>O(1)</code>，原地排序：指针i和指针j使用常数大小的额外空间</li><li>稳定排序：由于在“冒泡”中遇到相等元素不交换</li></ol><h2 id="1-4-插入排序"><a href="#1-4-插入排序" class="headerlink" title="1.4 插入排序"></a>1.4 插入排序</h2><ol><li>插入排序<code>insertion sort</code>是一种简单的排序算法，它的工作原理与“手动整理一副牌”的过程非常相似</li><li>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置</li><li>设基准元素为base，我们需要将 从目标索引到base之间的所有元素[targetIndex,base)向右移动一位，然后将base赋值给目标索引<ul><li><img src="/images/AlgoGettingStart/img_55.png" alt="img_55.png"></li></ul></li></ol><h3 id="1-4-1-算法流程"><a href="#1-4-1-算法流程" class="headerlink" title="1.4.1 算法流程"></a>1.4.1 算法流程</h3><p>插入排序的整体流程如下：</p><ul><li>1.初始状态下，数组的第1个元素已完成排序</li><li>2.选取数组的第2个元素作为base，将其插入到正确位置后，“数组的前2个元素已排序”</li><li>3.选取数组的第3个元素作为base，将其插入到正确位置后，“数组的前3个元素已排序”</li><li>4.以此类推，在最后一轮中，选取最后一个元素作为base，将其插入到正确位置后，“所有元素均已排序”<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> base=<span class="number">1</span>;base&lt; nums.length;base++)&#123;<span class="comment">//base从第2个元素开始直到第n个,已排序区间为[0,base)</span></span><br><span class="line">      <span class="type">int</span> tmp=nums[base];<span class="comment">//临时变量存储base的值</span></span><br><span class="line">      <span class="type">int</span> index=base-<span class="number">1</span>;<span class="comment">//从base-1开始向前查找第一个小于base的元素(它的下一个即为base应该插入的位置)</span></span><br><span class="line">      <span class="keyword">while</span> (index&gt;=<span class="number">0</span>&amp;&amp;nums[index]&gt;nums[base])&#123;</span><br><span class="line">         nums[index+<span class="number">1</span>]=nums[index];<span class="comment">//位于插入位置之前的元素不需要向后移动</span></span><br><span class="line">         index--;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[index+<span class="number">1</span>]=tmp;<span class="comment">//index的下一个位置才为base应该插入的位置</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-2-算法特性"><a href="#1-4-2-算法特性" class="headerlink" title="1.4.2 算法特性"></a>1.4.2 算法特性</h3><ol><li>时间复杂度为<code>O(n^2)</code>，自适应排序：在最差情况下，每次插入操作分别需要循环n-1,n-1…2,1次，求和得到(n-1)n&#x2F;2，因此时间复杂度为<code>O(n^2)</code>。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度O(n)</li><li>空间复杂度为<code>O(1)</code>，原地排序：指针i和j使用常数大小的额外空间</li><li>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序</li></ol><h3 id="1-4-3-插入排序的优势"><a href="#1-4-3-插入排序的优势" class="headerlink" title="1.4.3 插入排序的优势"></a>1.4.3 插入排序的优势</h3><ol><li>插入排序的时间复杂度为<code>O(n^2)</code>，而我们即将学习的快速排序的时间复杂度为<code>O(nlogn)</code>。尽管插入排序的时间复杂度更高，但在数据量较小的情况下，插入排序通常更快<ul><li>这个结论与线性查找和二分查找的的适用情况的结论类似。快速排序这类O(nlogn)的算法属于基于分治策略的排序算法，往往包含更多“单元计算操作”。而在数据量较小时，n^2和nlogn的数值比较接近，且复杂度不占主导地位，每轮中的单元操作数量起到决定性作用</li></ul></li><li>实际上，许多编程语言(例如Java)的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序</li><li>虽然冒泡排序，选择排序和插入排序的时间复杂度都为<code>O(n^2)</code>，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因<ul><li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及3个单元操作；插入排序基于元素赋值实现，仅需1个单元操作。因此，冒泡排序的计算开销通常比插入排序更高</li><li>选择排序在任何情况下的时间复杂度都为<code>O(n^2)</code>。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</li><li>选择排序不稳定，无法应用于多级排序</li></ul></li></ol><h2 id="1-5-快速排序"><a href="#1-5-快速排序" class="headerlink" title="1.5 快速排序"></a>1.5 快速排序</h2><ol><li>快速排序<code>quick sort</code>是一种基于“分治策略”的排序算法，运行高效，应用广泛</li><li>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧(流程如下)<ul><li>1.选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端</li><li>2.设置一个循环，在每轮中使用i(j)分别寻找“第一个”比基准数大(小)的元素，然后交换这两个元素</li><li>3.循环执行步骤2，直到i和j相遇为止，最后将基准数交换至两个子数组的分界线</li><li><img src="/images/AlgoGettingStart/img_56.png" alt="img_56.png"></li><li><img src="/images/AlgoGettingStart/img_57.png" alt="img_57.png"></li><li><img src="/images/AlgoGettingStart/img_58.png" alt="img_58.png"></li><li><img src="/images/AlgoGettingStart/img_59.png" alt="img_59.png"></li><li><img src="/images/AlgoGettingStart/img_60.png" alt="img_60.png"></li><li><img src="/images/AlgoGettingStart/img_61.png" alt="img_61.png"></li><li><img src="/images/AlgoGettingStart/img_62.png" alt="img_62.png"></li><li><img src="/images/AlgoGettingStart/img_63.png" alt="img_63.png"></li><li><img src="/images/AlgoGettingStart/img_64.png" alt="img_64.png"></li></ul></li><li>哨兵划分完成后，原数组被划分成三个部分：左子数组，右子数组，基准数。且满足“左子数组任意元素&lt;&#x3D;基准数&lt;&#x3D;右子数组任意元素”。</li><li>因此，我们接下来只需对这两个子数组进行排序</li><li>哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;<span class="comment">//left和right是为了满足在递归中被调用的</span></span><br><span class="line">    <span class="comment">//以nums[left]为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[j] &gt;= nums[left]) &#123;</span><br><span class="line">            j--;<span class="comment">//从右向左找首个小于基准数的元素</span></span><br><span class="line">        &#125;<span class="comment">//以最左端为基准数时必须要先从右向左查找</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; i &amp;&amp; nums[i] &lt;= nums[left]) &#123;</span><br><span class="line">            i++;<span class="comment">//从左向右找首个大于基准数的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, i);<span class="comment">//将基准数交换至两个子数组的分界线</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-5-1-算法流程"><a href="#1-5-1-算法流程" class="headerlink" title="1.5.1 算法流程"></a>1.5.1 算法流程</h3><p><img src="/images/AlgoGettingStart/img_65.png" alt="img_65.png"></p><ul><li>1.首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组</li><li>2.然后，对左子数组和右子数组分别递归执行”哨兵划分”</li><li>3.持续递归，直至子数组长度为1时终止，从而完成整个数组的排序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="comment">//子数组长度为1时终止递归</span></span><br><span class="line">   <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//哨兵划分</span></span><br><span class="line">   <span class="type">int</span> pivot=partition(nums, left, right);</span><br><span class="line">   <span class="comment">//递归左子数组，右子数组</span></span><br><span class="line">   quickSort(nums,left,pivot-<span class="number">1</span>);</span><br><span class="line">   quickSort(nums,pivot+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-2-算法特性"><a href="#1-5-2-算法特性" class="headerlink" title="1.5.2 算法特性"></a>1.5.2 算法特性</h3><ol><li>时间复杂度为<code>O(nlogn)</code>，自适应排序：在平均情况下，哨兵划分的“递归层次为logn”每层中的总循环数为n，总体使用<code>O(nlogn)</code>时间。<ul><li>在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为1和n-1的两个子数组，此时递归层数达到n，(平均)每层中的循环数为(n+1)n&#x2F;2,总体使用<code>O(n^2)</code>时间</li></ul></li><li>空间复杂度为<code>O(n)</code>,原地排序：在输入数组完全倒序的情况下，达到最差递归深度n，使用<code>O(n)</code>栈帧空间。排序操作是在原数组上进行的，未借助额外数组</li><li>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。例如[4,4,3,5]–&gt;[3,4,4,5]。相同元素4的相对顺序发生了改变</li></ol><h3 id="1-5-3-快速排序为什么快"><a href="#1-5-3-快速排序为什么快" class="headerlink" title="1.5.3 快速排序为什么快"></a>1.5.3 快速排序为什么快</h3><p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因</p><ul><li>出现最差情况的概率很低：虽然快速排序的最差时间复杂度为<code>O(n^2)</code>，并没有归并排序稳定，但在绝大多数情况下，快速排序能在<code>O(nlogn)</code>的时间复杂度下运行</li><li>缓存使用效率：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性</li><li>复杂度的常数系数小：在上述三种算法中，快速排序的比较，赋值，交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似</li></ul><h3 id="1-5-4-基准数优化"><a href="#1-5-4-基准数优化" class="headerlink" title="1.5.4 基准数优化"></a>1.5.4 基准数优化</h3><ol><li>快速排序在某些输入下的时间效率可能降低。<ul><li>举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为n-1，右子数组长度为0。如此递归下去，每轮哨兵划分后都有一个子数组的长度为1，分治策略失效。快速排序退化为“冒泡排序”的近似形式</li></ul></li><li>为了尽量避免这种情况发生，我们可以“优化哨兵划分中的基准数的选取策略”。<ul><li>例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意</li></ul></li><li>需要注意的是，编程语言通常生成的都是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化</li><li>为了进一步改进，我们可以在数组中选取三个候选元素(通常为数组的首，尾，中点元素)，并将这三个候选元素的中位数(第二大)作为基准数。这样一来，基准数“既不太小，也不太大”的概率将大幅提升。<ul><li>当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至O(n)的概率大大降低<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">medianThree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;<span class="comment">//找到三个数中的中位数并返回索引</span></span><br><span class="line">   <span class="type">int</span> l=nums[left];</span><br><span class="line">   <span class="type">int</span> m=nums[mid];</span><br><span class="line">   <span class="type">int</span> r=nums[right];</span><br><span class="line">   <span class="keyword">if</span>((m&gt;=l&amp;&amp;r&gt;=m)||(m&lt;=l&amp;&amp;r&lt;=m))&#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基准数优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partitionPro</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="type">int</span> med=medianThree(nums,left,(left+right)/<span class="number">2</span>,right);<span class="comment">//选取三个候选元素的中位数</span></span><br><span class="line">   swap(nums,left,med);<span class="comment">//将中位数交换至数组最左端</span></span><br><span class="line">   <span class="type">int</span> i=left;</span><br><span class="line">   <span class="type">int</span> j=right;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;<span class="comment">//以nums[left]作为基准数</span></span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[j]&gt;=nums[left])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]&lt;=nums[left])&#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,j);</span><br><span class="line">   &#125;</span><br><span class="line">   swap(nums,i,left);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-5-5-尾递归优化"><a href="#1-5-5-尾递归优化" class="headerlink" title="1.5.5 尾递归优化"></a>1.5.5 尾递归优化</h3><ol><li>在某些输入下，快速排序可能占用空间较多。以完全有序的输入数组为例，设递归中的子数组长度为m，每轮哨兵划分操作都将产生长度为1的左子数组和长度为m-1的右子数组，这意味着每一层递归调用减少的问题规模非常小(只减少一个元素)，递归树的高度会达到n-1，此时需要使用O(n)大小的栈帧空间</li><li>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较这两个子数组的长度，仅对较短的子数组进行递归(将层的深度(递归)转化为单层的广度(循环))<ul><li>由于较短子数组的长度不会超过n&#x2F;2，因此这种方法能确保递归深度不超过logn，从而将最差空间复杂度优化至<code>O(logn)</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=left;<span class="type">int</span> j=right;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[j]&gt;=nums[left])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]&lt;=nums[left])&#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(nums,i,j);</span><br><span class="line">   &#125;</span><br><span class="line">   swap(nums,left,i);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSortPro</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(right&gt;left)&#123;<span class="comment">//子数组长度为1时终止(递归终止条件)</span></span><br><span class="line">      <span class="type">int</span> i=partition(nums, left, right);<span class="comment">//每轮循环/递归都要更新基准数</span></span><br><span class="line">      <span class="keyword">if</span>(i-left&gt;right-i)&#123;<span class="comment">//寻找较小的子数组</span></span><br><span class="line">         quickSortPro(nums,i,right);<span class="comment">//递归较小数组</span></span><br><span class="line">         right=i-<span class="number">1</span>;<span class="comment">//更新边界 进循环</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         quickSortPro(nums,left,i);</span><br><span class="line">         left=i+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-6-归并排序"><a href="#1-6-归并排序" class="headerlink" title="1.6 归并排序"></a>1.6 归并排序</h2><ol><li>归并排序<code>merge sort</code>是一种基于“分治策略”的排序算法，包含“划分”和“合并”阶段<ul><li>划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题</li><li>合并阶段：当子数组长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束</li><li><img src="/images/AlgoGettingStart/img_66.png" alt="img_66.png"></li></ul></li></ol><h3 id="1-6-1-算法流程"><a href="#1-6-1-算法流程" class="headerlink" title="1.6.1 算法流程"></a>1.6.1 算法流程</h3><ol><li>“划分阶段”从顶至底递归地将数组“从中点”切分为两个子数组<ul><li>1.计算数组中点<code>mid</code>，递归划分左子数组(区间<code>[left,mid]</code>)和右子数组(区间<code>[mid+1,right]</code>)</li><li>2.递归执行步骤1，直至子数组区间长度为1时终止</li></ul></li><li>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为1的子数组开始合并，合并阶段中的每个子数组都是有序的<ul><li><img src="/images/AlgoGettingStart/img_67.png" alt="img_67.png"></li><li><img src="/images/AlgoGettingStart/img_68.png" alt="img_68.png"></li><li><img src="/images/AlgoGettingStart/img_69.png" alt="img_69.png"></li></ul></li><li>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的<ul><li>后序遍历：先递归左子树，再递归右子树，最后处理根节点</li><li>归并排序：先递归左子数组，再递归右子数组，最后处理合并<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="comment">//左子数组区间为[left,mid],右子数组区间为[mid+1,right]</span></span><br><span class="line">   <span class="comment">//创建一个临时数组tmp，用于存放合并后的结果</span></span><br><span class="line">   <span class="type">int</span>[] tmp=<span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始化左子数组和右子数组的起始索引</span></span><br><span class="line">   <span class="type">int</span> i=left;</span><br><span class="line">   <span class="type">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">//当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<span class="comment">//双指针法</span></span><br><span class="line">      <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">         tmp[k++]=nums[i++];</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         tmp[k++]=nums[j++];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//因为每一个子数组都是局部有序的，经过上面的排序后多于的数组元素即为最大的数组元素，直接放到数组后面就可以了</span></span><br><span class="line">   <span class="comment">//将剩余元素复制到临时数组中</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">      tmp[k++]=nums[i++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">      tmp[k++]=nums[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将临时数组中的元素复制回原数组的对应区间</span></span><br><span class="line">   <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;tmp.length;k++)&#123;</span><br><span class="line">      nums[left+k]=tmp[k];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">      <span class="keyword">return</span>;<span class="comment">//终止递归的情况</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//划分阶段</span></span><br><span class="line">   <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//计算中点</span></span><br><span class="line">   mergeSort(nums, left, mid);<span class="comment">//递归左子数组</span></span><br><span class="line">   mergeSort(nums,mid+<span class="number">1</span>,right);<span class="comment">//递归右子数组</span></span><br><span class="line">   <span class="comment">//合并阶段</span></span><br><span class="line">   merge(nums,left,mid,right);<span class="comment">//合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-6-2-算法特性"><a href="#1-6-2-算法特性" class="headerlink" title="1.6.2 算法特性"></a>1.6.2 算法特性</h3><ol><li>时间复杂度为<code>O(nlogn)</code>，非自适应排序：划分产生高度为log n的递归树，每层合并的总操作数量为n，因此总体时间复杂度为<code>O(nlogn)</code></li><li>空间复杂度<code>O(n)</code>，非原地排序：递归深度为logn，使用<code>O(logn)</code>大小的栈帧空间。合并操作需要借助辅助数组实现，使用<code>O(n)</code>大小的额外空间</li><li>稳定排序：在合并过程中，相等元素的次序保持不变(合并操作时两个子数组都是朝一个方向线性遍历的)</li></ol><h3 id="1-6-3-链表排序"><a href="#1-6-3-链表排序" class="headerlink" title="1.6.3 链表排序"></a>1.6.3 链表排序</h3><ol><li>对于链表，归并排序相较于其他排序算法具有显著优势，可以将链表排序任务的空间复杂度优化至<code>O(1)</code><ul><li>划分阶段：可以使用“迭代”替代“递归”来实现链表划分工作，从而省区递归使用的栈帧空间</li><li>合并阶段：在链表中，节点增删操作仅需改变引用即可实现，因此合并阶段(将两个短有序链表合并为一个长有序链表)无须创建额外链表<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h2><ol><li>堆排序<code>heap sort</code>是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序<ul><li>1.输入数组并建立小顶堆，此时最小元素位于堆顶</li><li>2.不断执行出堆操作，依次记录出堆元素，即可得到从小到大的序列</li></ul></li><li>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式</li></ol><h3 id="1-7-1-算法流程"><a href="#1-7-1-算法流程" class="headerlink" title="1.7.1 算法流程"></a>1.7.1 算法流程</h3><ol><li>设数组的长度为n</li></ol><ul><li><ol><li>输入数组并建立大顶堆。完成后，最大元素位于堆顶</li></ol></li><li><ol start="2"><li>将堆顶元素(第一个元素)与堆底元素(最后一个元素)交换。完成交换后，堆的长度减1，已排序元素数量加1<ul><li>类似与出堆操作，但是没有真正的删除该元素而是移动索引位置</li></ul></li></ol></li><li><ol start="3"><li>从堆顶元素开始，从顶到底执行堆化操作(sift down)。完成堆化后，堆的性质得到修复</li></ol></li><li><ol start="4"><li>循环执行第2步和第3步。循环n-1轮后，即可完成数组排序<ul><li><img src="/images/AlgoGettingStart/img_70.png" alt="img_70.png"></li><li><img src="/images/AlgoGettingStart/img_71.png" alt="img_71.png"></li><li><img src="/images/AlgoGettingStart/img_72.png" alt="img_72.png"></li></ul></li></ol></li></ul><ol start="2"><li>在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化“siftDown()”函数。值的注意的是，由于堆的有效长度会随着提取最大元素而减小，因此我们需要给“siftDown()”函数添加一个长度参数n，用于指定堆的当前有效长度<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//初始化堆</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//((nums.length-1)-1)/2</span></span><br><span class="line">      siftDown(nums, nums.length, i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//有效长度(迭代有效长度)</span></span><br><span class="line">      swap(nums,<span class="number">0</span>,i-<span class="number">1</span>);<span class="comment">//首和有效区间的尾交换，即0和有效长度-1</span></span><br><span class="line">      siftDown(nums,i-<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//向下堆化，此时有效长度已经-1了，因为已经“出去一个”</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] heap,<span class="type">int</span> n,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">//找到最大节点</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> i;</span><br><span class="line">      <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (leftIndex &lt; n &amp;&amp; heap[leftIndex] &gt; heap[max]) &#123;</span><br><span class="line">         max = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rightIndex &lt; n &amp;&amp; heap[rightIndex] &gt; heap[max]) &#123;</span><br><span class="line">         max = rightIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果左右子节点的索引越界或是i即为最大</span></span><br><span class="line">      <span class="keyword">if</span> (max == i) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//交换</span></span><br><span class="line">      swap(heap,max,i);</span><br><span class="line">      <span class="comment">//迭代向下堆化</span></span><br><span class="line">      i=max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-7-2-算法特性"><a href="#1-7-2-算法特性" class="headerlink" title="1.7.2 算法特性"></a>1.7.2 算法特性</h3><ol><li>时间复杂度为<code>O(nlogn)</code>，非自适应排序：建堆操作使用O(n)时间。从堆中提取最大元素的时间复杂度为<code>O(logn)</code>(堆化)，共循环n-1轮</li><li>空间复杂度为<code>O(1)</code>，原地排序：几个指针变量使用O(1)空间。元素交换和堆化操作都是在原数组上进行的</li><li>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化</li></ol><h2 id="1-8-桶排序"><a href="#1-8-桶排序" class="headerlink" title="1.8 桶排序"></a>1.8 桶排序</h2><ol><li>前面几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越<code>O(nlogn)</code>。</li><li>接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶</li><li>桶排序<code>bucket sort</code>是“分治策略”的一个典型应用。它通过“设置一些具有大小顺序的桶”，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有元素合并</li></ol><h3 id="1-8-1-算法流程"><a href="#1-8-1-算法流程" class="headerlink" title="1.8.1 算法流程"></a>1.8.1 算法流程</h3><p>考虑一个长度为n的数组，其元素是范围[0,1)内的浮点数</p><ul><li><ol><li>初始化k个桶，将n个元素分配到k个桶中</li></ol></li><li><ol start="2"><li>对每个桶分别执行排序(使用内置函数或其他排序算法)</li></ol></li><li><ol start="3"><li>按照桶从小到大的顺序合并结果</li></ol></li><li><img src="/images/AlgoGettingStart/img_73.png" alt="img_73.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">double</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//建桶</span></span><br><span class="line">   <span class="type">int</span> k= nums.length/<span class="number">2</span>;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Double&gt;&gt; arrayLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">      arrayLists.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//把值放进不同的桶中</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">double</span> num : nums) &#123;</span><br><span class="line">      <span class="type">int</span> index=(<span class="type">int</span>)num*k;<span class="comment">//将值映射成桶的索引</span></span><br><span class="line">      arrayLists.get(index).add(num);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对每个桶进行排序</span></span><br><span class="line">   <span class="keyword">for</span> (ArrayList&lt;Double&gt; arrayList : arrayLists) &#123;</span><br><span class="line">      Collections.sort(arrayList);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历所有桶，合并结果</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (ArrayList&lt;Double&gt; arrayList : arrayLists) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Double v : arrayList) &#123;</span><br><span class="line">         nums[i++]=v;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-8-2-算法特性"><a href="#1-8-2-算法特性" class="headerlink" title="1.8.2 算法特性"></a>1.8.2 算法特性</h3><p>桶排序适用于处理体量很大的数据。例如，输入数据包含100万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成1000个桶，然后分别对每个桶进行排序，最后将结果合并</p><ul><li>时间复杂度为<code>O(n+k)</code>:假设元素在各个桶内平均分布，那么每个桶内的元素数量为 n&#x2F;k。假设排序单个桶使用O(n&#x2F;k log n&#x2F;k)的时间，则排序所有桶使用O(nlog n&#x2F;k)时间。当桶数量k比较大时，时间复杂度则趋向于<code>O(n)</code>。合并结果时需要遍历所有桶和元素，花费<code>O(n+k)</code>时间</li><li>自适应排序：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用O(n^2)时间</li><li>空间复杂度为<code>O(n+k)</code>，非原地排序：需要借助k的桶和n个元素的额外空间</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定</li></ul><h3 id="1-8-3-如何实现平均分配"><a href="#1-8-3-如何实现平均分配" class="headerlink" title="1.8.3 如何实现平均分配"></a>1.8.3 如何实现平均分配</h3><ol><li>桶排序的时间复杂度理论上可以达到O(n)，关键在于“将元素均匀分配到各个桶中”，因为实际数据往往不是均匀分布的。</li><li>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到3个桶中。分配完毕后，再将元素较多的桶继续划分为3个桶，直至所有桶中的元素数量大致相等</li><li>这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。</li><li>不一定要每轮将数据划分成3个桶，具体划分方式可根据数据特点灵活选择<ul><li><img src="/images/AlgoGettingStart/img_74.png" alt="img_74.png"></li></ul></li><li>如果我们提前知道元素值的概率分布，则“可以根据数据概率分布设置每个桶的分界线”</li><li>数据分布不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似<ul><li><img src="/images/AlgoGettingStart/img_75.png" alt="img_75.png"></li></ul></li></ol><h2 id="1-9-计数排序"><a href="#1-9-计数排序" class="headerlink" title="1.9 计数排序"></a>1.9 计数排序</h2><ol><li>计数排序<code>counting sort</code>通过统计元素数量来实现排序，通常应用于整数数组</li><li>类似于 稀疏数组</li></ol><h3 id="1-9-1-简单实现"><a href="#1-9-1-简单实现" class="headerlink" title="1.9.1 简单实现"></a>1.9.1 简单实现</h3><p>先来看一个简单的例子。给定一个长度为n的数组nums，其中的元素都是“非负整数”，计数排序的整体流程为：</p><ul><li><ol><li>遍历数组，找出其中的最大数字，记为m，然后创建一个长度为m+1的辅助数组counter</li></ol></li><li><ol start="2"><li>借助counter统计nums中各数字的出现次数，其中counter[num]对应数字num的出现次数。统计方法很简单，只需遍历nums，每轮将counter[num]+1即可</li></ol></li><li><ol start="3"><li>由于counter的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，遍历counter，根据各数字出现次数从小到大填入nums即可</li></ol></li><li><img src="/images/AlgoGettingStart/img_76.png" alt="img_76.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] : max;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      counter[nums[i]]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt; counter.length;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;counter[i];j++)&#123;</span><br><span class="line">         nums[k++]=i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>计数排序与桶排序之间的联系：</li><li>从桶排序的角度看，我们可以将计数排序中的计数数组counter的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例</li></ul><h3 id="1-9-2-完整实现"><a href="#1-9-2-完整实现" class="headerlink" title="1.9.2 完整实现"></a>1.9.2 完整实现</h3><ol><li>如果输入数据是对象，而不是整型数据，那么上述步骤就失效了。<ul><li>假设输入数据是商品对象，我们想按照商品价格(类的成员变量)对商品进行排序，而上述算法只能给出价格的排序结果，而不能得到商品的排序结果</li></ul></li><li>得到原数据的排序结果—&gt;首先计算counter的“前缀和”<ul><li>索引i处的前缀和<code>perfix[i]</code>等于 数组前i个元素只和</li><li><img src="/images/AlgoGettingStart/img_77.png" alt="img_77.png"></li></ul></li><li>前缀和具有明确的意义，<code>prefix[num]-1</code>代表元素num在结果数组res中最后一次出现的索引<ul><li>这个信息非常关键，因为它告诉我们“各个元素应该出现在结果数组的哪个位置”</li></ul></li><li>接下来，我们倒叙遍历原数据nums的每个元素num，在每轮迭代中执行以下两步<ul><li><ol><li>将num填入数组res索引<code>prefix[num]-1</code>处</li></ol></li><li><ol start="2"><li>令前缀和<code>prefix[num]</code>减小1，从而得到下次防止num的索引</li></ol></li></ul></li><li>遍历完成后，数组res中就是排序好的结果，最后使用res覆盖原数组nums即可<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSortPro</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//假定输入一个商品数组 ItemArray</span></span><br><span class="line">   <span class="comment">//由此得到其成员变量价格 的数组 PriceArray</span></span><br><span class="line">   <span class="comment">//对PriceArray中的元素进行计数排序得到prefix--&gt;元素插入位置</span></span><br><span class="line">   <span class="comment">//再遍历ItemArray得到 满足价格排序的 商品数组 且是稳定排序</span></span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] : max;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//得到counter数组</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      counter[nums[i]]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//得到prefix数组</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; counter.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      counter[i+<span class="number">1</span>]+=counter[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建存储结果的数组res</span></span><br><span class="line">   <span class="comment">//Item[] res;</span></span><br><span class="line">   <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">   <span class="comment">//关键步骤</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="type">int</span> num=nums[i];</span><br><span class="line">      <span class="comment">//res[counter[num]-1]=ItemArray[i]</span></span><br><span class="line">      res[counter[num]-<span class="number">1</span>]=nums[i];<span class="comment">//counter[num]得到该数据对应的prefix</span></span><br><span class="line">      counter[num]-=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用结果数组res覆盖原数组nums</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      nums[i]=res[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-9-3-算法特性"><a href="#1-9-3-算法特性" class="headerlink" title="1.9.3 算法特性"></a>1.9.3 算法特性</h3><ol><li>时间复杂度为<code>O(n+m)</code>：涉及遍历nums和counter，都使用线性时间</li><li>空间复杂度为<code>O(n+m)</code>，非原地排序：借助了长度分别为n和m的数组res和counter</li><li>稳定排序：由于向res中填充元素的顺序是“从右向左”的，因此倒序遍历nums可以避免改变相等元素之间的相对位置，从而实现稳定排序。<ul><li>实际上，正序遍历nums也可以得到正确的排序结果，但结果是非稳定的</li></ul></li></ol><h3 id="1-9-4-局限性"><a href="#1-9-4-局限性" class="headerlink" title="1.9.4 局限性"></a>1.9.4 局限性</h3><ol><li>计数排序只适用于非负整数。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。<ul><li>例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将所有数字转换为正数，排序完成后再转换回去</li></ul></li><li>计数排序适用于数据量大但数据范围较小的情况(n&gt;&gt;m)。<ul><li>例如，在上述示例中m不能太大，否则会占用过多空间。而当n&lt;&lt;m时，计数排序使用O(m)时间，可能比O(nlogn)的排序算法还要慢</li></ul></li></ol><h2 id="1-10-基数排序"><a href="#1-10-基数排序" class="headerlink" title="1.10 基数排序"></a>1.10 基数排序</h2><ol><li>上一节介绍了计数排序，它适用于数据量n较大但数据范围m较小的情况。<ul><li>假设我们需要对n&#x3D;10^6个学号进行排序，而学号是一个8位数字，这意味着数据范围m&#x3D;10^8非常大，使用计数排序需要分配大量内存空间</li><li>而基数排序可以避免这种情况</li></ul></li><li>基数排序<code>radix sort</code>的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果</li></ol><h3 id="1-10-1-算法流程"><a href="#1-10-1-算法流程" class="headerlink" title="1.10.1 算法流程"></a>1.10.1 算法流程</h3><ol><li>以学号数据为例，假设数字的最低位是第1位，最高位是第8位。基数排序的流程如下<ul><li><ol><li>初始化位数k&#x3D;1</li></ol></li><li><ol start="2"><li>对学号的第k位执行“计数排序”。完成后，数据会根据第k位从小到大排序</li></ol></li><li><ol start="3"><li>将k增加1，然后返回步骤2，继续迭代，直到所有位都排序完成后结束<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素num的第k位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digit</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> exp)</span>&#123;</span><br><span class="line">   <span class="comment">//传入exp而非k可以避免重复执行昂贵的次方运算</span></span><br><span class="line">   <span class="keyword">return</span> (num/exp)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对元素num的第k为排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSortForDigit</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> exp)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//十进制最多就10个数</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      <span class="type">int</span> digit=digit(nums[i], exp);</span><br><span class="line">      counter[digit]++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//得到prefix</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; counter.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      counter[i+<span class="number">1</span>]+=counter[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="type">int</span> digit=digit(nums[i], exp);</span><br><span class="line">      res[counter[digit]-<span class="number">1</span>]=nums[i];</span><br><span class="line">      counter[digit]--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      nums[i]=res[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">   <span class="comment">//获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">   <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">      max=nums[i]&gt;max?nums[i] :max ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> exp=<span class="number">1</span>;exp&lt;=max;exp*=<span class="number">10</span>)&#123;</span><br><span class="line">      countingSortForDigit(nums,exp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li>为什么从最低位开始排序<ul><li>在连续的排序轮次中，后一轮的排序会覆盖前一轮排序的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位</li></ul></li></ol><h3 id="1-10-2-算法特性"><a href="#1-10-2-算法特性" class="headerlink" title="1.10.2 算法特性"></a>1.10.2 算法特性</h3><ol><li>相较于计数排序，基数排序适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位数不能过大<ul><li>例如，浮点数不适合使用基数排序，因为其位数k过大，可能导致时间复杂度O(nk)&gt;&gt;O(n^2)</li></ul></li><li>时间复杂度为<code>O(nk)</code>：设数据量为n，数据为d进制，最大位数为k，则对某一位执行计数排序时使用<code>O(n+d)</code>时间(遍历nums和counter)，排序所有k位使用<code>O((n+d)k)</code>时间<ul><li>通常情况下，d和k都相对较小，时间复杂度趋向O(n)</li></ul></li><li>空间复杂度为<code>O(n+d)</code>,非原地排序：与计数排序相同，基数排序需要借助长度为n和d的数组res和counter</li><li>稳定排序：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果</li></ol><h2 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h2><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ol><li>冒泡排序通过交换相邻元素来实现排序。通过添加一个flag来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到O(n)</li><li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为O(n^2)，但由于单元操作相对较少，因此在“小数据量”的排序任务中非常受欢迎</li><li>快速排序基于“哨兵划分”操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至O(n^2)。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到O(logn)</li><li>归并排序包括划分和合并两个阶段，典型的体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为O(n)；然而排序链表的空间复杂度可以优化至O(1)</li><li>桶排序包含三个步骤：数据分桶，桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配</li><li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并要求数据能够转换为正整数</li><li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字</li><li><img src="/images/AlgoGettingStart/img_78.png" alt="img_78.png"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08搜索/查找算法</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class8/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class8/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="1-1-二分查找"><a href="#1-1-二分查找" class="headerlink" title="1.1 二分查找"></a>1.1 二分查找</h2><ol><li>二分查找<code>binary search</code>是一种基于分治策略的高效搜索算法。</li><li>它利用数据的“有序性”，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空 为止</li></ol><h4 id="问题：给定一个长度为n的数组nums，元素按从小到大的顺序排列且不重复。请查找并返回元素target在数组中的索引。若数组不包含该元素，请返回-1"><a href="#问题：给定一个长度为n的数组nums，元素按从小到大的顺序排列且不重复。请查找并返回元素target在数组中的索引。若数组不包含该元素，请返回-1" class="headerlink" title="问题：给定一个长度为n的数组nums，元素按从小到大的顺序排列且不重复。请查找并返回元素target在数组中的索引。若数组不包含该元素，请返回-1"></a>问题：给定一个长度为n的数组nums，元素按从小到大的顺序排列且不重复。请查找并返回元素target在数组中的索引。若数组不包含该元素，请返回-1</h4><p><img src="/images/AlgoGettingStart/img_32.png" alt="img_32.png"></p><ol><li>先初始化指针 i&#x3D;0和j&#x3D;n-1，分别指向数组首元素和尾元素，代表搜索区间<code>[0,n)</code><ul><li><img src="/images/AlgoGettingStart/img_33.png" alt="img_33.png"></li></ul></li><li>接下来，循环执行以下两步<ul><li>计算 “中点索引”m&#x3D;[(i+j)&#x2F;2]，其中<code>[]</code>表示向下取整操作</li><li>判断 nums[m]和target的大小关系，分为以下三种情况(更新范围区间)<ul><li>a. 当 nums[m]&lt;target 时，说明target在区间<code>[m+1,j]</code>中，因此执行 i&#x3D;m+1</li><li>a. 当 nums[m]&#x3D;target 时，说明找到target，因此返回索引m</li><li>a. 当 nums[m]&gt;target 时，说明target在区间<code>[i,m-1]</code>中，因此执行 j&#x3D;m-1</li></ul></li></ul></li><li>若数组不包含目标元素，搜索区间最终会缩小为空。此时返回-1</li><li>注意：由于i和j都是int类型，因此“i+j可能会超出int类型的取值范围”。为了避免大数越界，通常采用公式<code>[m=i+(j-i)/2]</code>来计算中点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码，左闭右闭风格[a,b]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j= nums.length-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;=i)&#123;</span><br><span class="line">      <span class="type">int</span> m=i+(j-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[m]&gt;target)&#123;<span class="comment">//位于[i,m-1]</span></span><br><span class="line">         j=m-<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&lt;target) &#123;<span class="comment">//位于[m+1,j]</span></span><br><span class="line">         i=m+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;res_index=&quot;</span>+m);</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;no such element&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-1-1-区间表示方法"><a href="#1-1-1-区间表示方法" class="headerlink" title="1.1.1 区间表示方法"></a>1.1.1 区间表示方法</h3><ol><li>除了上述双闭区间外，常见的区间表示还有“左闭右开”区间，定义为<code>[0,n)</code>，即左边界包含自身，右边界不包含自身<ul><li>即区间[i,j)在i&#x3D;j时为空<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码，左闭右开风格[a,b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchOpen</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length;</span><br><span class="line">   <span class="keyword">while</span> (j &gt; i) &#123;<span class="comment">//当i=j时区间为空</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[m] &gt; target) &#123;<span class="comment">//位于[i,m)</span></span><br><span class="line">         j = m;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) &#123;<span class="comment">//位于[m+1,j)</span></span><br><span class="line">         i = m + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;res=&quot;</span> + m);</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;no such element&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-1-2-优点与局限性"><a href="#1-1-2-优点与局限性" class="headerlink" title="1.1.2 优点与局限性"></a>1.1.2 优点与局限性</h3><ol><li>二分查找在时间和空间方面都有较好的性能<ul><li>二分查找的时间效率高。在大数据量下，对数阶的时间复杂度具有显著优势。</li><li>二分查找无须额外的空间</li></ul></li><li>然而，二分查找并非适用于所有情况<ul><li>二分查找仅适用于有序数据。若输入数据无序，为了使用二分查找而专门进行排序，得不偿失。因为排序算法的时间复杂度通常为<code>O(nlogn)</code>,比线性查找和二分查找都更高。<ul><li>并且对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为<code>O(n)</code>，也是非常昂贵的</li></ul></li><li>二分查找仅适用于数组。因为二分查找需要跳跃式(非连续地)访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构</li><li>小数据量下，线性查找性能更佳。在线性查找中，每轮只需一次“判断操作”，而在二分查找中，需要一次加法，一次除法，1<del>3次判断操作，一次加法(减法)，共4</del>6个单元操作。因此，当数据量n较小时，线性查找反而比二分查找更快</li></ul></li></ol><h2 id="1-2-二分查找插入点-目标元素的插入位置"><a href="#1-2-二分查找插入点-目标元素的插入位置" class="headerlink" title="1.2 二分查找插入点(目标元素的插入位置)"></a>1.2 二分查找插入点(目标元素的插入位置)</h2><ol><li>二分查找不仅可用于搜索目标元素，还可用于解决许多变种问题，比如“搜索目标元素的插入位置”</li></ol><h3 id="1-2-1-无重复元素的情况"><a href="#1-2-1-无重复元素的情况" class="headerlink" title="1.2.1 无重复元素的情况"></a>1.2.1 无重复元素的情况</h3><ol><li>问题：给定一个长度为n的有序数组nums和一个元素target，数组不存在重复元素。现将target插入数组nums中，并保持其有序性。若数组中已存在元素target，则插入到其左方。请返回插入后target在数组中的索引<ul><li><img src="/images/AlgoGettingStart/img_34.png" alt="img_34.png"></li></ul></li><li>两个问题：<ul><li>当数组中包含target时，插入点的索引是否是该元素的索引</li><li>当数组中不包含target时，插入点是哪个元素的索引</li></ul></li><li>思考<ul><li><ol><li>题目要求将target插入到相等元素的左边，这意味着新插入的target替换了原来target的位置。所以“当数组包含target时，插入点的索引就是该target的索引”</li></ol></li><li><ol start="2"><li>思考二分查找的过程：指针i在向大于等于target的元素靠近，指针j在向小于等于target的元素靠近。因此二分查找结束时一定有</li></ol><ul><li>左闭右闭[a,b]：i指向首个大于target的元素,j指向首个i小于target的元素</li><li>左闭右开[a,b)：i和j都指向首个大于target的元素</li><li>易得“当数组不包含target时，插入索引为i”<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码，左闭右开情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchInsertIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length;</span><br><span class="line">   <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">         j = m;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">         i = m + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="1-2-2-存在重复元素的情况"><a href="#1-2-2-存在重复元素的情况" class="headerlink" title="1.2.2 存在重复元素的情况"></a>1.2.2 存在重复元素的情况</h3><ol><li>在上题基础上，规定数组可能包含重复元素，其余不变</li><li>假设数组中存在多个target，则普通二分查找只能返回其中一个target的索引，而无法确定“该元素左右两边还有多少target”</li><li>题目要求要将目标元素插入到最左边，所以我们需要查找数组中最左一个target的索引</li><li>方法一：(效率低)<ul><li>执行二分查找，得到任意一个target索引，记为k</li><li>从索引k开始，向左进行线性遍历，当找到最左边的target时返回</li><li><img src="/images/AlgoGettingStart/img_35.png" alt="img_35.png"></li><li>此方法虽然可用，但其包含线性查找，因此时间复杂度为<code>O(n)</code>。当数组中存在很多重复的target时，该方法效率很低</li></ul></li><li>方法二：拓展二分查找代码<ul><li>当<code>nums[m]&lt;target</code>或<code>nums[m]&gt;target</code>时，说明还没有找到target，因此采用普通二分查找的缩小区间操作，从而使指针i和j向target靠近。</li><li>当<code>nums[m]==target</code>时，说明小于<code>target</code>的元素在区间<code>[i,m-1]</code>中，因此采用<code>j=m-1</code>来缩小区间，从而使指针j向小于target的元素靠近<ul><li>左闭右闭[a,b]：循环完成后，i指向最左边的target，j指向首个小于target的元素，因此索引i就是插入点</li><li>左闭右开[a,b)：循环完成后，ihej指向最左边的target,因此索引i和j都是插入点</li></ul></li><li>因此索引i就是插入点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码,左闭右开</span></span><br><span class="line"><span class="comment">//nums[m]&gt;target和nums[m]==target的操作相同，因此两者可以合并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchInsertIndexMul</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j= nums.length;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> m=i+(j-i)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">         i=m+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         j=m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-3-小结"><a href="#1-2-3-小结" class="headerlink" title="1.2.3 小结"></a>1.2.3 小结</h3><ol><li>总的来看，二分查找无非就是“给指针i和j分别设定搜索目标”，目标可能是一个具体的元素(target)，也可能是一个元素范围(例如小于target的元素)</li><li>在不断的循环二分中，指针i和j都逐渐逼近预先设定的目标。最终，它们或是成功找到答案，或是越过边界后停止</li></ol><h2 id="1-3-二分查找边界"><a href="#1-3-二分查找边界" class="headerlink" title="1.3 二分查找边界"></a>1.3 二分查找边界</h2><h3 id="1-3-1-查找左边界"><a href="#1-3-1-查找左边界" class="headerlink" title="1.3.1 查找左边界"></a>1.3.1 查找左边界</h3><ol><li>问题：给定一个长度为n的有序数组nums，其中可能包含重复元素。请返回其中最左一个元素target的索引。若数组中不包含该元素，则返回-1</li><li>回忆二分查找插入点的方法，搜索完成后i指向最左一个target，因此查找插入点本质上是在查找最左一个target的索引</li><li>考虑通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含target，这种情况可能导致以下两种结果<ul><li>插入点的索引i越界(大于数组中的任意元素)</li><li>元素nums[i]和target不想等(当数组中不存在target时也会找到插入点)</li></ul></li><li>当遇到以上两种情况时，直接返回-1即可<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftEdge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="comment">//等价于查找target的插入点，但是排除target不存在的情况</span></span><br><span class="line">   <span class="type">int</span> index=binarySearchInsertIndexMul(nums,target);</span><br><span class="line">   <span class="keyword">if</span>(index== nums.length||nums[index]!=target)&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//不存在</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-2-查找右边界"><a href="#1-3-2-查找右边界" class="headerlink" title="1.3.2 查找右边界"></a>1.3.2 查找右边界</h3><ol><li>最直接的方式是修改代码，替换在<code>nums[m]==target</code>情况下的指针搜索操作<ul><li>将找到最左边的插入点改为找到最右边的插入点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightEdgeGradually</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j= nums.length;;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> m=i+(j-i)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[m]&gt;target)&#123;</span><br><span class="line">         j=m;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         i=m+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i-=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(i== -<span class="number">1</span>||nums[i]!=target)&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="1-3-2-1-复用-查找最左插入点"><a href="#1-3-2-1-复用-查找最左插入点" class="headerlink" title="1.3.2.1 复用 查找最左插入点"></a>1.3.2.1 复用 查找最左插入点</h4><ol><li>实际上，我们可以利用查找最左元素的函数来查找最右元素，具体方法为：“将查找最右一个target转化为查找最左一个<code>target+1</code>”</li><li><img src="/images/AlgoGettingStart/img_36.png" alt="img_36.png"><ul><li>查找完成后，指针i指向最左一个<code>target+1</code>(如果存在)，因此<code>i-1</code>表示target的最右一个</li><li>如果<code>target+1</code>不存在，那么查询的也是target最右一个的下一位置(插入的位置)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightEdgeReuse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> index=binarySearchInsertIndexMul(nums,target+<span class="number">1</span>);</span><br><span class="line">   index-=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(index!=target||index==-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>为什么判断条件中有<code>i==-1</code><ul><li>因为执行了<code>i-=1</code>这部操作，导致查找元素过大情况的i&#x3D;nums.length-1，交给<code>nums[i]!=target</code>处理</li><li>而当i过小时，i本该为0，但因执行了<code>i-=1</code>，导致i为-1，索引越界</li></ul></li></ol><h4 id="1-3-2-2-转化为查找元素"><a href="#1-3-2-2-转化为查找元素" class="headerlink" title="1.3.2.2 转化为查找元素"></a>1.3.2.2 转化为查找元素</h4><ol><li>当数组不包含target时，最终i和j会分别指向首个大于，小于target的元素(对于左闭右闭区间而言)</li><li>因此，我们可以构造一个数组中不存在的元素，用于查找左右边界<ul><li>查找最左一个target：可以转化为查找<code>target-0.5</code>,并返回指针i</li><li>查找最右一个target：可以转化为查找<code>tarhet+0.5</code>,并返回指针j</li><li><img src="/images/AlgoGettingStart/img_37.png" alt="img_37.png"></li></ul></li><li>注意：<ul><li>给定数组不包含小数，这意味着我们无须关心如何处理相等的情况</li><li>因为该方法引入了小数，所以要将方法中的变量target改为浮点数类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchEdgeLeft</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">double</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=nums.length;</span><br><span class="line">   target-=<span class="number">0.5</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> m=i+(j-i)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">         i=m+<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m]&gt;target)&#123;</span><br><span class="line">         j=m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(i== nums.length||nums[i]!=(<span class="type">int</span>)(target+<span class="number">0.5</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchEdgeRight</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">double</span> target)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=nums.length;</span><br><span class="line">   target+=<span class="number">0.5</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> m=i+(j-i)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">         i=m+<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[m]&gt;target)&#123;</span><br><span class="line">         j=m;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   i-=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(i== -<span class="number">1</span>||nums[i]!=(<span class="type">int</span>)(target-<span class="number">0.5</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-4-哈希优化策略"><a href="#1-4-哈希优化策略" class="headerlink" title="1.4 哈希优化策略"></a>1.4 哈希优化策略</h2><ol><li>在算法题中，我们常通过将 线性查找 替换为 哈希查找 来降低算法的时间复杂度。借助一个算法题来加深理解</li><li>问题：给定一个整数数组nums和一个目标元素target，请在数组中搜索 “和” 为target的两个元素，并返回它们的数组索引。返回任意一个解即可</li></ol><h3 id="1-4-1-线性查找：以时间换空间"><a href="#1-4-1-线性查找：以时间换空间" class="headerlink" title="1.4.1 线性查找：以时间换空间"></a>1.4.1 线性查找：以时间换空间</h3><ol><li>考虑直接遍历所有可能的组合。<ul><li><img src="/images/AlgoGettingStart/img_38.png" alt="img_38.png"></li><li>此方法的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code></li></ul></li></ol><h3 id="1-4-2-哈希查找：以空间换时间"><a href="#1-4-2-哈希查找：以空间换时间" class="headerlink" title="1.4.2 哈希查找：以空间换时间"></a>1.4.2 哈希查找：以空间换时间</h3><ol><li>考虑借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组，每轮执行两个步骤<ul><li><ol><li>判断数字<code>target-nums[i]</code>是否在哈希表中，如果在，则直接返回这两个元素的索引</li></ol></li><li><ol start="2"><li>将键值对<code>nums[i]</code>和<code>i</code>添加进哈希表</li></ol></li><li><img src="/images/AlgoGettingStart/img_39.png" alt="img_39.png"></li><li><img src="/images/AlgoGettingStart/img_40.png" alt="img_40.png"></li><li><img src="/images/AlgoGettingStart/img_41.png" alt="img_41.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hashSearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">   HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(hashMap.containsKey(target-nums[i]))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>+i+<span class="string">&quot;,&quot;</span>+hashMap.get(target-nums[i])+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      hashMap.put(nums[i],i );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;no result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>该方法只需要单层循环即可，通过哈希查找将时间复杂度从<code>O(n^2)</code>降至<code>O(n)</code>，大幅提升运行效率</li><li>由于需要维护一个额外的哈希表，因此空间复杂度为<code>O(n)</code>。尽管如此，该方法的整体时空效率更为均衡，因此它是本题的最优解法</li></ol><h2 id="1-5-重识搜索算法"><a href="#1-5-重识搜索算法" class="headerlink" title="1.5 重识搜索算法"></a>1.5 重识搜索算法</h2><ol><li>搜索算法<code>[searching algorithm]</code>用于在数据结构(例如数组，链表，树或图)中搜索一个或一组满足特定条件的元素</li><li>搜索算法可根据实现思路分为以下两类<ul><li>通过遍历数据结构来定位目标元素。例如数组，链表，图和树的遍历等</li><li>利用数据组织结构或数据包含的先验信息，实现高效元素查找。例如二分查找，哈希查找和二叉搜索树查找等<ul><li>“数据包含的先验信息”指的是在数据中已经包含了一些关于数据性质或者数据关系的信息。</li></ul></li></ul></li></ol><h3 id="1-5-1-暴力搜索"><a href="#1-5-1-暴力搜索" class="headerlink" title="1.5.1 暴力搜索"></a>1.5.1 暴力搜索</h3><ol><li>暴力搜索通过“遍历数据结构的每个元素”来定位目标元素<ul><li>“线性搜索”适用于数组和链表等线性数据结构。它从数据结构的一端开始，逐个访问元素，直到找到目标元素或到达另一端仍没有找到目标元素为止</li><li>“广度优先搜索”和“深度优先搜索”是图和树的两种遍历策略。广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。深度优先搜索从初始节点开始，沿着一条路径走到头，再回溯并尝试其他路径，直到遍历完整个数据结构</li></ul></li><li>暴力搜索的优点是简单且通用性好，无须对数据做预处理和借助额外的数据结构</li><li>然而，此类算法的时间复杂度为O(n)，其中n为元素数量，因此在数据量较大的情况下性能较差</li></ol><h3 id="1-5-2-自适应搜索"><a href="#1-5-2-自适应搜索" class="headerlink" title="1.5.2 自适应搜索"></a>1.5.2 自适应搜索</h3><ol><li>自适应搜索利用数据的特有属性(例如有序性)来优化搜索过程，从而更高效地定位目标元素<ul><li>“二分查找”利用数据的有序性实现高效查找，仅适用于数组</li><li>“哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作</li><li>“树查找”在特定的树结构(例如二叉搜索树)中，基于比较节点值来快速排除节点，从而定位目标元素</li></ul></li><li>此类算法的优点是效率高，时间复杂度可达到O(logn)甚至O(1)</li><li>然而，使用这些算法往往需要“对数据进行预处理”。例如，二分查找需要预先对数组进行排序，哈希查找和树查找都需要借助额外的数据结构，维护这些数据结构也需要额外的时间和空间开销</li><li>自适应搜索算法常被称为“查找算法”，主要用于“在特定数据结构中快速检索目标元素”</li></ol><h3 id="1-5-3-搜索方法选取"><a href="#1-5-3-搜索方法选取" class="headerlink" title="1.5.3 搜索方法选取"></a>1.5.3 搜索方法选取</h3><ol><li><img src="/images/AlgoGettingStart/img_42.png" alt="img_42.png"></li><li><img src="/images/AlgoGettingStart/img_43.png" alt="img_43.png"></li><li>搜索算法的选择还取决于 数据体量，搜索性能要求，数据查询与更新频率等</li></ol><h4 id="1-5-3-1-线性搜索"><a href="#1-5-3-1-线性搜索" class="headerlink" title="1.5.3.1 线性搜索"></a>1.5.3.1 线性搜索</h4><ol><li>通用性较好，无须任何数据预处理操作。假如我们仅需查询一次数据，那么其他三种方法的数据预处理的时间比线性搜索的时间还要更长</li><li>适用于体量较小的数据，此情况下时间复杂度对效率影响较小</li><li>适用于数据更新频率较高的场景，因为该方法不需要对数据进行任何额外维护</li></ol><h4 id="1-5-3-2-二分查找"><a href="#1-5-3-2-二分查找" class="headerlink" title="1.5.3.2 二分查找"></a>1.5.3.2 二分查找</h4><ol><li>适用于大数据量的情况，效率表现稳定，最差时间复杂度为O(logn)</li><li>数据量不能过大，因为存储数组需要连续的内存空间</li><li>不适用于高频增删数据的场景，因为维护有序数组的开销较大</li></ol><h4 id="1-5-3-3-哈希查找"><a href="#1-5-3-3-哈希查找" class="headerlink" title="1.5.3.3 哈希查找"></a>1.5.3.3 哈希查找</h4><ol><li>适合对查询性能要求很高的场景，平均时间复杂度为O(1)</li><li>不适合需要有序数据或范围查找的场景，因为哈希表无法维护数据的有序性</li><li>对哈希函数和哈希冲突处理策略的依赖性较高，具有较大的性能劣化风险</li><li>不适合数据量过大的情况，因为哈希表需要额外空间来最大程度的减少冲突，从而提供良好的查询性能</li><li>用哈希查找替换线性查找是一种常用的优化运行时间的策略，可将时间复杂度从O(n)降至O(1)</li></ol><h4 id="1-5-3-4-树查找"><a href="#1-5-3-4-树查找" class="headerlink" title="1.5.3.4 树查找"></a>1.5.3.4 树查找</h4><ol><li>适用于海量数据，因为树的节点在内存中是分散存储的</li><li>适合需要维护有序数据或范围查找的情景</li><li>在持续增删节点的过程中，二叉搜索树可能产生倾斜，时间复杂度劣化至<code>O(n)</code></li><li>若使用AVL树或红黑树，则各项操作可在<code>O(logn)</code>效率下稳定运行，但维护树平衡的操作会增加额外的开销</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07图</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class7/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class7/</url>
      
        <content type="html"><![CDATA[<h1 id="图Graph"><a href="#图Graph" class="headerlink" title="图Graph"></a>图Graph</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ol><li><code>图graph</code>是一种非线性数据结构，由<code>顶点vertex</code>和<code>边edge</code>组成。</li><li>我们可以将图G抽象地表示为一组顶点V和一组边E的集合<ul><li><img src="/images/AlgoGettingStart/img_12.png" alt="img_12.png"></li></ul></li><li>如果将顶点看作节点，将边看作连接各个节点的引用。就可以将图看作一种从链表拓展而来的数据结构</li><li>相较于线性关系(链表)和分治关系(树)，网络关系(图)的自由度更高，因而更为复杂<ul><li><img src="/images/AlgoGettingStart/img_13.png" alt="img_13.png"></li></ul></li></ol><h3 id="1-1-1-图的常见类型与术语"><a href="#1-1-1-图的常见类型与术语" class="headerlink" title="1.1.1 图的常见类型与术语"></a>1.1.1 图的常见类型与术语</h3><ol><li>根据边是否具有方向，可分为<code>无向图undirected graph</code>和<code>有向图directed graph</code><ul><li>在无向图中，边表示两顶点之间的“双向”连接关系。例如微信或QQ中的“好友关系”</li><li>在有向图中，边具有方向性，即A-&gt;B和A&lt;-B两个方向的边是相互独立的。例如微博或抖音上的“关注”与“被关注”关系</li><li><img src="/images/AlgoGettingStart/img_14.png" alt="img_14.png"></li></ul></li><li>根据“所有顶点是否连通”，可分为<code>连通图connected graph</code>和<code>非连通图disconnected graph</code><ul><li>对于连通图，从某个顶点出发，可以到达其余任意顶点</li><li>对于非连通图，从某个顶点出发，至少有一个顶点无法到达</li><li><img src="/images/AlgoGettingStart/img_15.png" alt="img_15.png"></li></ul></li><li>还可以为边添加“权重”属性，从而得到<code>有权图weighted graph</code>。<ul><li>例如在王者荣耀中，系统会根据共同游戏时间来计算玩家之间的“亲密度”，这种亲密度网络就可以用有权图来表示</li><li><img src="/images/AlgoGettingStart/img_16.png" alt="img_16.png"></li></ul></li><li>图数据结构包含以下常用术语：<ul><li><code>邻接adjacency</code>：当两顶点之间存在边相连时，称这两顶点“邻接”</li><li><code>路径path</code>：从顶点A到顶点B经过的边构成的序列被称为从A到B的“路径”</li><li><code>度degree</code>：一个顶点拥有的边数。对于有向图，<code>入度in-degree</code>表示有多少条边指向该顶点，<code>出度out-degree</code>表示有多少条边从该顶点指出</li></ul></li></ol><h3 id="1-1-2-图的表示"><a href="#1-1-2-图的表示" class="headerlink" title="1.1.2 图的表示"></a>1.1.2 图的表示</h3><ol><li>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例</li></ol><h4 id="1-1-2-1-邻接矩阵"><a href="#1-1-2-1-邻接矩阵" class="headerlink" title="1.1.2.1 邻接矩阵"></a>1.1.2.1 邻接矩阵</h4><ol><li>设图的顶点数为n，<code>邻接矩阵adjacency matrix</code>使用一个n*n大小的矩阵(二维数组)来表示图，每一行(列)代表一个顶点和其他节点之间的关系。矩阵元素代表边，用0或1表示两个顶点之间是否存在边</li><li><img src="/images/AlgoGettingStart/img_17.png" alt="img_17.png"><ul><li>设邻接矩阵M，顶点列表V，那么矩阵元素 M[i,j]&#x3D;1表示顶点V[i]到顶点V[j]之间存在边。</li><li>反之 M[i,j]&#x3D;0 表示两顶点之间无边</li></ul></li><li>邻接矩阵具有以下特性<ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称</li><li>将邻接矩阵的元素从1和0替换为权重，则可表示有权图</li></ul></li><li>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删改查操作效率很高，时间复杂度均为O(1)。然而，矩阵的空间复杂度为O(n^2)，内存占用较多</li></ol><h4 id="1-1-2-2-邻接表"><a href="#1-1-2-2-邻接表" class="headerlink" title="1.1.2.2 邻接表"></a>1.1.2.2 邻接表</h4><ol><li><code>邻接表adjacency list</code>使用n个链表来表示图，链表节点表示顶点。第i个链表对应顶点i，其中存储了该顶点的所有邻接顶点(与该顶点相连的点)</li><li><img src="/images/AlgoGettingStart/img_18.png" alt="img_18.png"></li><li>邻接表仅存储实际存在的边，而边的总数通常远小于n^2，因此它更加节省空间</li><li>然而，在邻接表中需要通过遍历链表来查找边。因此其时间效率不如邻接矩阵</li><li>邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率。<ul><li>比如当链表较长时，可以将链表转化为AVL树或红黑树，从而将时间效率从O(n)优化至<code>O(logn)</code></li><li>还可以把链表转换为哈希表(再哈希)，从而将时间复杂度降至O(1)</li></ul></li></ol><h3 id="1-1-3-图的常见应用"><a href="#1-1-3-图的常见应用" class="headerlink" title="1.1.3 图的常见应用"></a>1.1.3 图的常见应用</h3><p><img src="/images/AlgoGettingStart/img_19.png" alt="img_19.png"></p><h2 id="图的基础操作"><a href="#图的基础操作" class="headerlink" title="图的基础操作"></a>图的基础操作</h2><ol><li>图的基础操作可分为对“边”的操作和对“顶点”的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同</li></ol><h3 id="1-2-1-基于邻接矩阵的实现"><a href="#1-2-1-基于邻接矩阵的实现" class="headerlink" title="1.2.1 基于邻接矩阵的实现"></a>1.2.1 基于邻接矩阵的实现</h3><h4 id="给定一个顶点数量为n的无向图，则各种操作的实现方式如下"><a href="#给定一个顶点数量为n的无向图，则各种操作的实现方式如下" class="headerlink" title="给定一个顶点数量为n的无向图，则各种操作的实现方式如下"></a>给定一个顶点数量为n的无向图，则各种操作的实现方式如下</h4><ol><li>添加或删除边：直接在邻接矩阵中修改指定的边即可，使用<code>O(1)</code>时间。而由于是无向图，因此需要同时更新两个方向的边<ul><li><img src="/images/AlgoGettingStart/img_20.png" alt="img_20.png"></li><li><img src="/images/AlgoGettingStart/img_21.png" alt="img_21.png"></li></ul></li><li>添加顶点：在邻接矩阵的尾部添加一行一列，并全部填0即可，使用<code>O(n)</code>时间(一行一列)<ul><li><img src="/images/AlgoGettingStart/img_22.png" alt="img_22.png"></li></ul></li><li>删除节点：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将(n-1)^2个元素“向左上移动”，从而使用<code>O(n^2)</code>时间<ul><li><img src="/images/AlgoGettingStart/img_23.png" alt="img_23.png"></li></ul></li><li>初始化：传入n个顶点，初始化长度为n的顶点列表”vertices”，使用<code>O(n)</code>时间；初始化n*n大小的邻接矩阵adjMat，使用<code>O(n^2)</code>时间<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdjMatGraph</span> &#123;</span><br><span class="line">   List&lt;Integer&gt; vertices;<span class="comment">//顶点列表</span></span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; adjMat;<span class="comment">//邻接矩阵</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AdjMatGraph</span><span class="params">(<span class="type">int</span>[] vertices,<span class="type">int</span>[][] edges)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.vertices=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="built_in">this</span>.adjMat=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> vertex : vertices) &#123;</span><br><span class="line">         <span class="built_in">this</span>.vertices.add(vertex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> vertices.size();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Integer&gt; column : adjMat) &#123;</span><br><span class="line">         column.add(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vertices.add(num);</span><br><span class="line">      ArrayList&lt;Integer&gt; newColumn = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size();i++)&#123;</span><br><span class="line">         newColumn.add(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      adjMat.add(newColumn);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> vertices.indexOf(num);</span><br><span class="line">      <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      vertices.remove(index);</span><br><span class="line">      adjMat.remove(index);</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Integer&gt; column : adjMat) &#123;</span><br><span class="line">         column.remove(index);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(from &lt; <span class="number">0</span> || from&gt;=size()||to&lt;<span class="number">0</span>||to&gt;=size())&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(adjMat.get(from).get(to)!=<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;edge has lived&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         adjMat.get(from).set(to,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(from &lt; <span class="number">0</span> || from&gt;=size()||to&lt;<span class="number">0</span>||to&gt;=size())&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(adjMat.get(from).get(to)==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;edge has not lived&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         adjMat.get(from).set(to,<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAdjMat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;顶点列表=&quot;</span>);</span><br><span class="line">      System.out.println(vertices);</span><br><span class="line">      System.out.println(<span class="string">&quot;邻接矩阵=&quot;</span>);</span><br><span class="line">      System.out.println(adjMat);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> vertices.isEmpty()|| adjMat.isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-2-基于邻接表的实现"><a href="#1-2-2-基于邻接表的实现" class="headerlink" title="1.2.2 基于邻接表的实现"></a>1.2.2 基于邻接表的实现</h3><h4 id="设无向图的顶点总数为n-边总数为m，则各种操作的实现方式如下"><a href="#设无向图的顶点总数为n-边总数为m，则各种操作的实现方式如下" class="headerlink" title="设无向图的顶点总数为n,边总数为m，则各种操作的实现方式如下"></a>设无向图的顶点总数为n,边总数为m，则各种操作的实现方式如下</h4><ol><li>添加边：在顶点对应链表的末尾添加边即可，使用<code>O(1)</code>时间。因为是无向图，所以需要同时添加两个方向的边<ul><li><img src="/images/AlgoGettingStart/img_24.png" alt="img_24.png"></li></ul></li><li>删除边：在顶点对应链表中查找并删除指定边，使用<code>O(m)</code>时间(最差情况，所有边都在一个链表上)。在无向图中，需要同时删除两个方向的边<ul><li><img src="/images/AlgoGettingStart/img_25.png" alt="img_25.png"></li></ul></li><li>添加顶点：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用<code>O(1)</code>时间<ul><li><img src="/images/AlgoGettingStart/img_26.png" alt="img_26.png"></li></ul></li><li>删除顶点：需遍历整个邻接表，删除包含指定顶点的所有边，使用<code>O(n+m)</code>时间(最差情况，和所有顶点都有连接并且都在链表尾部)<ul><li><img src="/images/AlgoGettingStart/img_27.png" alt="img_27.png"></li></ul></li><li>初始化：在邻接表中创建n个顶点和2m条边，使用<code>O(n+m)</code>时间<ul><li><img src="/images/AlgoGettingStart/img_28.png" alt="img_28.png"></li></ul></li><li>代码实现：实际代码有以下不同<ul><li>为了方便添加与删除节点，以及简化代码，使用列表(动态数组)来代替链表</li><li>使用哈希表来存储邻接表，key为顶点实例，value为该顶点的邻接顶点列表(链表)</li><li>在邻接表中使用Vertex类来表示顶点，这样做的原因是：如果与邻接矩阵一样，用列表索引来区分不同的顶点，那么假设要删除索引为i的顶点，则需遍历整个邻接表，将所有大于i的索引全部-1，效率很低</li><li>如果每个顶点都是唯一的vertex实例，删除某一顶点后就无须改动其他顶点了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdjList</span> &#123;</span><br><span class="line">    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdjList</span><span class="params">(Vertex[][] edges)</span> &#123;</span><br><span class="line">        adjList = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex[] edge : edges) &#123;</span><br><span class="line">            addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">            addVertex(edge[<span class="number">1</span>]);</span><br><span class="line">            addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(Vertex vertex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjList.containsKey(vertex)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.put(vertex, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(Vertex vertex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vertex)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.remove(vertex);</span><br><span class="line">        Collection&lt;List&lt;Vertex&gt;&gt; values = adjList.values();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Vertex&gt; value : values) &#123;</span><br><span class="line">            value.remove(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(Vertex from, Vertex to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(from) || !adjList.containsKey(to) || from == to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.get(from).add(to);</span><br><span class="line">        <span class="comment">//adjList.get(to).add(from);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(Vertex from, Vertex to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(from) || !adjList.containsKey(to) || from == to) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.get(from).remove(to);</span><br><span class="line">        adjList.get(to).remove(from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接表=&quot;</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt;&gt; entries = adjList.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; entry : entries) &#123;</span><br><span class="line">            System.out.print(entry.getKey().val + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Vertex vertex : entry.getValue()) &#123;</span><br><span class="line">                System.out.print(vertex.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-2-3-效率对比"><a href="#1-2-3-效率对比" class="headerlink" title="1.2.3 效率对比"></a>1.2.3 效率对比</h3><ol><li>设图中共有n个顶点和m条边，对比邻接矩阵和邻接表的时间效率和空间效率<ul><li><img src="/images/AlgoGettingStart/img_29.png" alt="img_29.png"></li></ul></li><li>似乎邻接表(哈希表)的时间效率和空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需一次数组访问或赋值操作即可。</li><li>综合来看，邻接矩阵体现了“以空间换时间”的原则。邻接表体现了“以时间换空间”的原则</li></ol><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ol><li>树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作图的一种特例</li><li>显然，树的遍历操作也是图的遍历操作的一种特例</li><li>树和图都需要应用搜索算法来实现遍历操作。图的遍历方式也可分为两种：“广度优先遍历”和“深度优先遍历”</li></ol><h3 id="1-3-1-广度优先遍历"><a href="#1-3-1-广度优先遍历" class="headerlink" title="1.3.1 广度优先遍历"></a>1.3.1 广度优先遍历</h3><ol><li>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并“一层层向外扩张”</li><li><img src="/images/AlgoGettingStart/img_30.png" alt="img_30.png"><ul><li>从左上角顶点出发，首先遍历该顶点的所有邻接顶点(存储在队列中)，然后遍历下一个顶点(出队列)的所有邻接顶点，以此类推，直至所有顶点访问完毕</li></ul></li></ol><h4 id="1-3-1-1-算法实现"><a href="#1-3-1-1-算法实现" class="headerlink" title="1.3.1.1 算法实现"></a>1.3.1.1 算法实现</h4><ol><li>BFS通常借助队列来实现。队列具有“先入先出”的性质，这与BFS的“由近及远”的思想异曲同工<ul><li><ol><li>将遍历起始顶点<code>startVet</code>加入队列，并开启循环</li></ol></li><li><ol start="2"><li>在循环的每轮迭代中，弹出 队首顶点 并记录访问(记录该顶点已被访问)，然后将该顶点的所有邻接顶点加入到队列尾部</li></ol></li><li><ol start="3"><li>循环步骤二，直到所有顶点被访问完毕后结束</li></ol></li></ul></li><li>为了防止重复遍历顶点，需要借助一个哈希表<code>visited</code>来记录哪些顶点已被访问(记录访问)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(Map&lt;Vertex,List&lt;Vertex&gt;&gt; listMap,Vertex startVet)</span>&#123;</span><br><span class="line">   HashSet&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   Queue&lt;Vertex&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">   queue.offer(startVet);</span><br><span class="line">   visited.add(startVet);</span><br><span class="line">   <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">      <span class="type">Vertex</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();<span class="comment">//队首顶点出队</span></span><br><span class="line">      System.out.println(poll.val);<span class="comment">//记录访问顶点</span></span><br><span class="line">      <span class="keyword">for</span> (Vertex vertex : listMap.get(poll)) &#123;</span><br><span class="line">         <span class="keyword">if</span>(visited.contains(vertex))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//跳过已被访问的顶点</span></span><br><span class="line">         &#125;</span><br><span class="line">         visited.add(vertex);<span class="comment">//标记该顶点已被访问</span></span><br><span class="line">         queue.offer(vertex);<span class="comment">//入队未被访问的顶点</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>广度优先遍历的序列不唯一，因为广度优先遍历只要求按“由近及远”的顺序遍历，而多个相同距离的顶点的遍历顺序允许被任意打乱(同一层之间的顺序不做要求)</li></ol><h4 id="1-3-1-2-复杂度分析"><a href="#1-3-1-2-复杂度分析" class="headerlink" title="1.3.1.2 复杂度分析"></a>1.3.1.2 复杂度分析</h4><ol><li>时间复杂度：所有顶点都会入队并出队一次，使用<code>O(|V|)</code>时间。在遍历邻接节点的过程中，由于是无向图，因此所有边都会被访问两次，使用<code>O(2|E|)</code>的时间。总体使用<code>O(|V|+|E|)</code>时间</li><li>空间复杂度：存储序列的列表:res，哈希表:visited，队列:queue 中的顶点数量最多为|V|，使用<code>O(|V|)</code>空间</li></ol><h3 id="1-3-2-深度优先遍历"><a href="#1-3-2-深度优先遍历" class="headerlink" title="1.3.2 深度优先遍历"></a>1.3.2 深度优先遍历</h3><ol><li>深度优先遍历是一种“优先走到底，无路可走再回头”的遍历方式</li><li><img src="/images/AlgoGettingStart/img_31.png" alt="img_31.png"><ul><li>从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成</li></ul></li></ol><h4 id="1-3-2-1-算法实现"><a href="#1-3-2-1-算法实现" class="headerlink" title="1.3.2.1 算法实现"></a>1.3.2.1 算法实现</h4><ol><li>这种“走到尽头再返回”的算法范式通常基于递归来实现。</li><li>与广度优先遍历类似，在深度优先遍历中，我们也需要借助一个哈希表visited来记录已被访问的顶点，以避免重复访问顶点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(Map&lt;Vertex,List&lt;Vertex&gt;&gt; vertices,Vertex startVet)</span>&#123;</span><br><span class="line">   HashSet&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//存储已经访问过的节点</span></span><br><span class="line">   DFSHelper(vertices,startVet,visited);<span class="comment">//借助递归辅助方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">DFSHelper</span><span class="params">(Map&lt;Vertex,List&lt;Vertex&gt;&gt; vertices,Vertex vertex,HashSet&lt;Vertex&gt; visited)</span>&#123;</span><br><span class="line">   System.out.println(vertex.val+<span class="string">&quot;\t&quot;</span>);<span class="comment">//记录查找到的顶点</span></span><br><span class="line">   visited.add(vertex);<span class="comment">//加入到已访问列表中</span></span><br><span class="line">   <span class="keyword">for</span> (Vertex vertex1 : vertices.get(vertex)) &#123;<span class="comment">//遍历邻接节点</span></span><br><span class="line">      <span class="keyword">if</span>(!visited.contains(vertex1))&#123;</span><br><span class="line">         DFSHelper(vertices,vertex1,visited);<span class="comment">//如果从未被访问，那么就访问该节点，然后重复上述操作(递归)</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历</li><li>以树的遍历为例，前序，中序，后序遍历有不同的遍历优先级，然而这三种都属于深度优先遍历</li></ol><h4 id="1-3-2-2-复杂度分析"><a href="#1-3-2-2-复杂度分析" class="headerlink" title="1.3.2.2 复杂度分析"></a>1.3.2.2 复杂度分析</h4><ol><li>时间复杂度：所有顶点都会被访问一次，使用<code>O(|V|)</code>时间，所有边都会被访问2次，使用<code>O(2|E|)</code>时间。总体使用<code>O(|V|+|E|)</code>时间</li><li>空间复杂度：遍历列表res,哈希表visited,顶点数量最多为|V|,递归深度最多为|V|，因此使用<code>O(|V|)</code>空间</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06堆</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class6/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-堆heap"><a href="#1-堆heap" class="headerlink" title="1. 堆heap"></a>1. 堆heap</h1><h2 id="1-1-堆"><a href="#1-1-堆" class="headerlink" title="1.1. 堆"></a>1.1. 堆</h2><ol><li><code>堆heap</code>是一种满足特定条件的“完全二叉树”，主要可分为两种类型<ul><li>大顶堆<code>max heap</code>：任意节点的值&gt;&#x3D;其子节点的值(大在顶)</li><li>小顶堆<code>min heap</code>：任意节点的值&lt;&#x3D;其子节点的值(小在顶)</li></ul></li><li>堆作为完全二叉树的一个特例，具有以下特性<ul><li>最底层节点靠左填充，其他层节点都被填满</li><li>将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”</li><li>对于大顶堆(小顶堆)，堆顶元素(根节点)的值是最大的(最小的)</li></ul></li></ol><h3 id="1-1-1-堆的常用操作"><a href="#1-1-1-堆的常用操作" class="headerlink" title="1.1.1. 堆的常用操作"></a>1.1.1. 堆的常用操作</h3><ol><li>许多编程语言提供的是<code>优先队列 priority queue</code>，这是一种抽象的数据结构，定义为具有优先级排序的队列</li><li>实际上，堆通常用于实现优先队列。大顶堆相当于元素按从大到小的顺序出队的优先队列</li><li>从使用角度来看，可以将“优先队列”和“堆”看作等价的数据结构</li><li><img src="/images/AlgoGettingStart/image-47.png" alt="Alt text"><ul><li>方法名根据编程语言决定</li></ul></li><li>可以通过设置一个<code>Comparator</code>实现“大顶堆”与“小顶堆”之间的转换<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span></span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-1-2-堆的实现"><a href="#1-1-2-堆的实现" class="headerlink" title="1.1.2. 堆的实现"></a>1.1.2. 堆的实现</h3><ol><li>实现的是大顶堆。如果要将其转换为小顶堆，只需要将所有大小逻辑判断取逆</li></ol><h4 id="1-1-2-1-堆的存储与表示"><a href="#1-1-2-1-堆的存储与表示" class="headerlink" title="1.1.2.1. 堆的存储与表示"></a>1.1.2.1. 堆的存储与表示</h4><ol><li>因为完全二叉树非常适合用数组来表示。且堆正是一种完全二叉树，因此 <strong>采用数组来存储堆</strong></li><li>当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。“节点引用”通过 “索引映射公式”来实现</li><li>给定索引i，其左子节点是<code>2i+1</code>,右子节点是<code>2i+2</code>，父节点的索引为<code>(i-1)/2</code>。当索引越界时，表示空节点或节点不存在<ul><li><img src="/images/AlgoGettingStart/image-48.png" alt="Alt text"></li></ul></li><li>可以将索引映射公式封装成函数，方便后续使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-1-2-2-访问堆顶元素"><a href="#1-1-2-2-访问堆顶元素" class="headerlink" title="1.1.2.2. 访问堆顶元素"></a>1.1.2.2. 访问堆顶元素</h4><p>堆顶元素即为二叉树的根节点，也就是列表的首个元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storeHeap.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-3-元素入堆"><a href="#1-1-2-3-元素入堆" class="headerlink" title="1.1.2.3. 元素入堆"></a>1.1.2.3. 元素入堆</h4><ol><li>给定元素val，我们首先将其添加到堆底</li><li>添加之后，由于val可能大于堆中其他元素，堆的成立条件可能已被破坏</li><li>因此需要修复 从插入节点到根节点 路径上的各个节点。这个操作被称为“堆化”</li><li>考虑从入堆节点开始，从底至顶执行堆化<ul><li><img src="/images/AlgoGettingStart/image-49.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-50.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-51.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-52.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-53.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-54.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-55.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-56.png" alt="Alt text"></li><li>比较插入节点与其父节点的值，如果插入节点更大，则将他们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无需交换的节点时结束<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    storeHeap.add(num);</span><br><span class="line">    siftUp(storeHeap.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        parent=parent(index);</span><br><span class="line">        <span class="keyword">if</span>(parent&lt;<span class="number">0</span>||storeHeap.get(index)&lt;=storeHeap.get(parent))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(index,parent);</span><br><span class="line">        <span class="comment">//循环向上堆化</span></span><br><span class="line">        index=parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=storeHeap.get(index1);</span><br><span class="line">    storeHeap.set(index1, storeHeap.get(index2));</span><br><span class="line">    storeHeap.set(index2,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="1-1-2-4-堆顶元素出堆"><a href="#1-1-2-4-堆顶元素出堆" class="headerlink" title="1.1.2.4. 堆顶元素出堆"></a>1.1.2.4. 堆顶元素出堆</h4><ol><li>堆顶元素是二叉树的根节点，即列表首元素。</li><li>如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难</li><li>为了尽量减少元素索引的变动，我们采用以下步骤<ul><li>交换堆顶元素与堆底元素</li><li>交换完成后，将堆底从列表中删除(因为进行了交换，实际上删除的是原来的堆顶元素)</li><li>从根节点开始，从顶至底执行堆化</li></ul></li><li>“从顶至底堆化”的操作方向与“从底至顶堆化”相反。<ul><li><img src="/images/AlgoGettingStart/image-57.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-58.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-59.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-60.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-61.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-62.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-63.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-64.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-65.png" alt="Alt text"></li><li><img src="/images/AlgoGettingStart/image-66.png" alt="Alt text"></li><li>将根节点的值与其两个子节点的值进行比较<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        left=left(index);</span><br><span class="line">        right=right(index);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;storeHeap.size()-<span class="number">1</span>||storeHeap.get(index)&gt;= storeHeap.get(left)&amp;&amp;</span><br><span class="line">                storeHeap.get(index)&gt;=storeHeap.get(right))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp= storeHeap.get(left)&gt; storeHeap.get(right)? storeHeap.get(left) : storeHeap.get(right);</span><br><span class="line">        swap(index,temp);</span><br><span class="line">        index=temp;</span><br><span class="line">        <span class="comment">//int l = left(i), r = right(i), ma = i;</span></span><br><span class="line">        <span class="comment">//if (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))</span></span><br><span class="line">        <span class="comment">//    ma = l;</span></span><br><span class="line">        <span class="comment">//if (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))</span></span><br><span class="line">        <span class="comment">//    ma = r;</span></span><br><span class="line"><span class="comment">//若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="comment">//if (ma == i)</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line"><span class="comment">//交换两节点</span></span><br><span class="line">        <span class="comment">//swap(i, ma);</span></span><br><span class="line"><span class="comment">//循环向下堆化</span></span><br><span class="line">        <span class="comment">//i = ma; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-1-3-堆的常见应用"><a href="#1-1-3-堆的常见应用" class="headerlink" title="1.1.3. 堆的常见应用"></a>1.1.3. 堆的常见应用</h3><ol><li>优先队列:堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为<code>O(logn)</code>，而建队操作为O(n)，这些操作都非常高效</li><li>堆排序:给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现“堆排序”</li><li>获取最大的k个元素:这是一个经典的算法问题，同时也是一种典型应用。例如选择热度前10的新闻作为热搜，选取销量前十的商品等</li></ol><h2 id="1-2-建堆操作"><a href="#1-2-建堆操作" class="headerlink" title="1.2. 建堆操作"></a>1.2. 建堆操作</h2><p>在某些情况下，我们希望使用一个列表的所有元素来构建一个堆，这个过程被称为“建堆操作”</p><h3 id="1-2-1-借助入堆操作实现"><a href="#1-2-1-借助入堆操作实现" class="headerlink" title="1.2.1. 借助入堆操作实现"></a>1.2.1. 借助入堆操作实现</h3><ol><li>我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化</li><li>每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的</li><li>设元素数量为n，每个元素的入堆操作使用<code>O(logn)</code>时间，因此该建堆方法的时间复杂度为<code>O(logn)</code></li></ol><h3 id="1-2-2-通过遍历堆化实现"><a href="#1-2-2-通过遍历堆化实现" class="headerlink" title="1.2.2. 通过遍历堆化实现"></a>1.2.2. 通过遍历堆化实现</h3><ol><li>实际上，可以实现一种更为高效的建堆方法，共分为两步<ul><li><ol><li>将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足</li></ol></li><li><ol start="2"><li>倒叙遍历堆(层序遍历的倒叙)，依次对每个非叶节点执行“从顶至底的堆化”</li></ol></li></ul></li><li>每当堆化一个节点后，以该节点为根节点的子树 就形成一个合法的子堆。</li><li>由于是倒叙遍历，因此堆是“自下而上”构建的</li><li>之所以选择倒叙遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的</li><li>值得说明的是，由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化</li><li>最后一个非叶节点是最后一个节点的父节点，从它开始倒叙遍历并执行堆化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(List&lt;Integer&gt; nums)</span>&#123;</span><br><span class="line">   <span class="comment">//将列表元素添加进堆</span></span><br><span class="line">   storeHeap=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line">   <span class="comment">//倒叙堆化除叶节点外的其他节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=parent(storeHeap.size()-<span class="number">1</span>);i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">      siftDown(i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-3-复杂度分析"><a href="#1-2-3-复杂度分析" class="headerlink" title="1.2.3 复杂度分析"></a>1.2.3 复杂度分析</h3><ol><li>推算第二种建堆方法的时间复杂度<ul><li>假设完全二叉树的节点数量为n，则叶节点数量为(n+1)&#x2F;2。因此需要堆化的节点数量为(n-1)&#x2F;2[完美二叉树的计算公式]</li><li>在从顶至底堆化的过程中，每个节点最多堆化到叶节点，因此最大迭代次数为二叉树高度logn</li></ul></li><li>将上述两者相乘，可得到建堆过程的时间复杂度为O(nlogn)。但是这个估算结果并不准确，因为我们没有考虑到二叉树底层节点数量远多于顶层节点 的性质</li><li>为了降低计算难度，假设给定一个节点数量为n，高度为h的完美二叉树</li><li>节点“从顶至底堆化”的最大迭代次数等于该节点到叶节点的距离，而该距离正是“节点高度”。因此，我们可以对各层的“节点数量*节点高度”求和，得到所有节点的堆化迭代次数的总和<ul><li><img src="/images/AlgoGettingStart/img.png" alt="img.png"></li><li><img src="/images/AlgoGettingStart/img_1.png" alt="img_1.png"></li></ul></li><li>高度为h的完美二叉树的节点数量为：n&#x3D;2^(h+1)-1。易得复杂度O(2^h)&#x3D;<code>O(n)</code></li><li>因此，输入列表并建堆的时间复杂度为<code>O(n)</code>，非常高效</li></ol><h2 id="Top-k问题"><a href="#Top-k问题" class="headerlink" title="Top-k问题"></a>Top-k问题</h2><ol><li>问题介绍：给定一个长度为n的无序数组nums，请返回数组中最大的k个元素</li><li>对于该问题，先看两种思路比较直接的解法，再看效率更高的堆解法</li></ol><h3 id="1-3-1-方法一：遍历-选择-选择排序，但是只排前几个"><a href="#1-3-1-方法一：遍历-选择-选择排序，但是只排前几个" class="headerlink" title="1.3.1 方法一：遍历+选择(选择排序，但是只排前几个)"></a>1.3.1 方法一：遍历+选择(选择排序，但是只排前几个)</h3><ol><li>我们可以进行k轮遍历，分别在每轮中提取第1,2….k大的元素，时间复杂度为O(nk)</li><li>此方法只适用于”k&lt;&lt;n”的情况，因为当k与n比较接近时，其时间复杂度趋向于O(n^2)</li><li><img src="/images/AlgoGettingStart/img_2.png" alt="img_2.png"><ul><li>当k&#x3D;n时，可以得到完整的有序序列，此时等价于“选择排序算法”</li></ul></li></ol><h3 id="1-3-2-方法二：排序"><a href="#1-3-2-方法二：排序" class="headerlink" title="1.3.2 方法二：排序"></a>1.3.2 方法二：排序</h3><ol><li>我们可以先对数组nums进行排序，再返回最右边的k个元素，时间复杂度为O(nlogn)</li><li>显然，该方法“超额”完成任务了，因为我们只需要找出最大的k个元素即可，而不需要排序其他元素<ul><li><img src="/images/AlgoGettingStart/img_3.png" alt="img_3.png"></li></ul></li></ol><h3 id="1-3-3-方法三：堆"><a href="#1-3-3-方法三：堆" class="headerlink" title="1.3.3 方法三：堆"></a>1.3.3 方法三：堆</h3><ol><li>可以基于堆更加高效地解决Top-k问题(类似于使用max存储最大值然后不断进行比较，如果遇到更大的数就更新max。是一样的思想)<ul><li><ol><li>初始化一个小顶堆，其堆顶元素最小</li></ol></li><li><ol start="2"><li>先将数组的前k个元素依次入堆</li></ol></li><li><ol start="3"><li>从第k+1个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆</li></ol></li><li><ol start="4"><li>遍历完成后，堆中保存的就是最大的k个元素</li></ol></li></ul></li><li>流程图：<ul><li><img src="/images/AlgoGettingStart/img_4.png" alt="img_4.png"></li><li><img src="/images/AlgoGettingStart/img_5.png" alt="img_5.png"></li><li><img src="/images/AlgoGettingStart/img_6.png" alt="img_6.png"></li><li><img src="/images/AlgoGettingStart/img_7.png" alt="img_7.png"></li><li><img src="/images/AlgoGettingStart/img_9.png" alt="img_9.png"></li><li><img src="/images/AlgoGettingStart/img_10.png" alt="img_10.png"></li><li><img src="/images/AlgoGettingStart/img_11.png" alt="img_11.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; <span class="title function_">topK</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">      minHeap.offer(nums.get(i));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.size();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(minHeap.peek()&lt;nums.get(i))&#123;</span><br><span class="line">         minHeap.poll();</span><br><span class="line">         minHeap.offer(nums.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> minHeap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>总共执行了n轮入堆和出堆，堆的最大长度为k，因此时间复杂度为<code>O(nlogk)</code></li><li>该方法的效率很高，当k较小时，时间复杂度趋向<code>O(n)</code>；当k较大时，时间复杂度不会超过<code>O(nlogn)</code></li><li>另外，该方法适用于 “动态数据流” 的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大的k个元素的动态更新</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12动态规划</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class12/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-1-初探动态规划"><a href="#1-1-初探动态规划" class="headerlink" title="1.1 初探动态规划"></a>1.1 初探动态规划</h2><ol><li>动态规划<code>dynamic programming</code>是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率(重叠子问题)</li><li>在本节中，我们从一个经典例题入手，先给出暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法</li><li>问题：爬楼梯：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，请问有多少种方案可以爬到楼顶<ul><li><img src="/images/AlgoGettingStart/img_110.png" alt="img_110.png"></li><li>本题的目标是求解方案数量，我们可以考虑通过回溯来穷举所有可能性。</li><li>将爬楼梯想象成一个多轮选择的过程：从地面出发，每轮选择上1阶或2阶，每当到达楼梯顶部时就将方案数量+1，当越过楼梯顶部时就将其剪枝<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climb</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">   ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backTrack(n,<span class="number">0</span>,ints,res);</span><br><span class="line">   <span class="keyword">return</span> res.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> state, <span class="type">int</span>[] choices, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(state==n)&#123;</span><br><span class="line">      res.set(<span class="number">0</span>,res.get(<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> choice : choices) &#123;</span><br><span class="line">      <span class="keyword">if</span>(state+choice&gt;n)&#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      backTrack(n,state+choice,choices,res);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="1-1-1-方法一：暴力搜索"><a href="#1-1-1-方法一：暴力搜索" class="headerlink" title="1.1.1 方法一：暴力搜索"></a>1.1.1 方法一：暴力搜索</h3><ol><li>回溯算法通常并不显式地对问题进行拆解，而是将求解问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解</li><li>我们可以尝试从“问题分解”的角度分析这道题。设爬到第i阶共有dp[i]种方案，那么dp[i]就是原问题，其子问题包括dp[i-1],dp[i-2]…dp[2],dp[1]</li><li>由于每轮只能上1阶或2阶，因此当我们站在第i阶楼梯上时，上一轮只可能站在第i-1阶或第i-2阶上。换句话说，我们只能从第i-1阶或第i-2阶迈向第i阶</li><li>由此便可得出一个重要推论：爬到第i-1阶的方案数加上爬到第i-2阶的方案书就等于爬到第i阶的方案数<ul><li><code>dp[i]=dp[i-1]+dp[i-2]</code></li></ul></li><li>这意味着在爬楼梯问题中，各个子问题之间存在递推关系，原问题的解可以由子问题的解构建而来<ul><li><img src="/images/AlgoGettingStart/img_111.png" alt="img_111.png"></li></ul></li><li>我们可以根据递推公式得到暴力搜索解法。以dp[n]为起始点，递归地将一个较大问题拆解为两个较小问题的和，直至到达最小子问题dp[1]和dp[2]时返回。其中，最小子问题的解是已知的，即dp[1]&#x3D;1,dp[2]&#x3D;2，表示爬到第1，2阶分别有1，2种方案<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dfs(n-<span class="number">1</span>)+dfs(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> dfs(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于问题dp[n]，其递归树的深度为n，时间复杂度为O(2^n)。指数阶属于爆炸式增长，如果我们输入一个比较大的n，则会陷入漫长的等待中<ul><li><img src="/images/AlgoGettingStart/img_112.png" alt="img_112.png"></li></ul></li><li>观察图，<em><strong>指数阶的时间复杂度是“重叠子问题”导致的</strong></em>。<ul><li>例如dp[9]被分解为dp[8]和dp[7]，dp[8]被分解为dp[7]和dp[6]。两者都包含子问题dp[7]</li><li>以此类推，子问题中包含更小的重叠子问题。绝大部分计算资源都浪费在这些重叠的子问题上</li></ul></li></ol><h3 id="1-1-2-方法二：记忆化搜索"><a href="#1-1-2-方法二：记忆化搜索" class="headerlink" title="1.1.2 方法二：记忆化搜索"></a>1.1.2 方法二：记忆化搜索</h3><ol><li>为了提升算法效率，<em><strong>我们希望所有重叠的子问题都只被计算一次</strong></em>。</li><li>为此，我们声明一个数组mem来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝<ul><li>当首次计算dp[i]时，我们将其记录至mem[i]，以便之后使用</li><li>当再次需要计算dp[i]时，我们便可直接从mem[i]中获取结果，从而避免重复计算该子问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDfs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> dfs(n,ints);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] mem)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(mem[n]==<span class="number">0</span>)&#123;</span><br><span class="line">      mem[n]=dfs(n-<span class="number">1</span>,mem)+dfs(n-<span class="number">2</span>,mem);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mem[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至O(n)<ul><li><img src="/images/AlgoGettingStart/img_113.png" alt="img_113.png"></li></ul></li></ol><h3 id="1-1-3-方法三：动态规划"><a href="#1-1-3-方法三：动态规划" class="headerlink" title="1.1.3 方法三：动态规划"></a>1.1.3 方法三：动态规划</h3><ol><li>记忆化搜索是一种“从顶至底”的方法：我们从原问题(根节点)开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题(叶节点)。之后，通过回溯逐层收集子问题的解，构建出原问题的解</li><li>与之相反，<em><strong>动态规划是一种“从底至顶”的方法</strong></em>：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解</li><li>由于动态规划不包含回溯过程，因此只需使用“循环迭代”实现，无须使用递归。</li><li>在以下代码中，我们初始化一个数组dp来存储子问题的解，它起到了与记忆化搜索中数组mem相同的记录作用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDP</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//初始化dp表，用于存储子问题的解</span></span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始状态：预设最小子问题的解</span></span><br><span class="line">   dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">   <span class="comment">//状态转移：从较小子问题逐步求解(构建)较大子问题</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/images/AlgoGettingStart/img_114.png" alt="img_114.png"></li><li>与回溯算法一样，动态规划也使用“状态”概念来表示“问题求解的特定阶段”，每个状态都对应一个子问题以及相应的局部最优解。<ul><li>例如，爬楼梯问题的状态定义为当前所在楼梯阶数i</li></ul></li><li>动态规划的常用术语:<ul><li>将数组dp称为<code>dp表</code>,dp[i]表示“状态i对应子问题的解”</li><li>将最小子问题对应的状态(第1阶和第2阶楼梯)，称为<code>初始状态</code></li><li>将递推公式 dp[i]&#x3D;dp[i-1]+dp[i-2]称为<code>状态转移方程</code></li></ul></li></ol><h3 id="1-1-4-空间优化"><a href="#1-1-4-空间优化" class="headerlink" title="1.1.4 空间优化"></a>1.1.4 空间优化</h3><p>由于dp[i]只与dp[i-1]和dp[i-2]有关，因此我们无须使用一个数组dp来存储所有子问题的解。而只需要“两个变量滚动前进”即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbDP</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=b;</span><br><span class="line">        b=a+b;</span><br><span class="line">        a=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>观察以上代码，由于省去了数组dp占用的空间，因此空间复杂度从O(n)降至O(1)</li><li>在动态规划问题中，<em><strong>当前状态往往仅与前面有限个状态有关</strong></em>，这时我们可以<em><strong>只保留必要的状态</strong></em>，通过“降维”来节省内存空间。</li><li>这种空间优化技巧被称为“滚动变量”或“滚动数组”</li></ol><h2 id="1-2-动态规划问题特性"><a href="#1-2-动态规划问题特性" class="headerlink" title="1.2 动态规划问题特性"></a>1.2 动态规划问题特性</h2><ol><li>在上一节中，学习了动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治，动态规划，回溯中的侧重点不同<ul><li>分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解</li><li>动态规划也对原问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题</li><li>回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题</li></ul></li><li>实际上，动态规划常用来求解“最优化问题”，它们不仅包含“重叠子问题”，还具有另外两大特性：最优子结构，无后效性</li></ol><h3 id="1-2-1-最优子结构"><a href="#1-2-1-最优子结构" class="headerlink" title="1.2.1 最优子结构"></a>1.2.1 最优子结构</h3><ol><li>我们对爬楼梯问题稍作改动，使之更加适合展示最优子结构概念<ul><li>给定一个楼梯，每步可以上1阶或2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶需要付出的代价。给定一个非负整数数组cost，其中cost[i]表示在第i个台阶需要付出的代价，cost[0]为地面(起始点)。请计算最少需要付出多少代价才能到达顶部</li><li><img src="/images/AlgoGettingStart/img_115.png" alt="img_115.png"></li></ul></li><li>设dp[i]为爬到第i阶累计付出的代价，由于第i阶只可能从第i-1阶或第i-2阶走来。因此dp[i]只可能等于<code>dp[i-1]+cost[i]</code>或<code>dp[i-2]+cost[i]</code>。<ul><li>为了尽可能减少代价，我们应该选择两者中较小的那一个 <code>dp[i]=min(dp[i-1],dp[i-2])+cost[i]</code></li></ul></li><li>这便可以引出最优子结构的含义：<em><strong>原问题的最优解是从子问题的最优解构建而来的</strong></em></li><li>本题显然具有最优子结构：我们从两个子问题的最优解dp[i-1]和dp[i-2]中挑选出最优的那一个，并用它构建出原问题dp[i]的最优解<ul><li>那么，上一节的爬楼梯题目是否有最优子结构呢？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。</li><li>意外发现，虽然题目修改前后是等价的，但最优子结构浮现出来了：第n阶最大方案数量等于第n-1阶和第n-2阶最大方案数量之和。</li><li>最优子结构的解释方式比较灵活，在不同问题中会有不同的含义</li></ul></li><li>根据状态转移方程:<code>dp[i]=min(dp[i-1],dp[i-2])+cost[i]</code>，以及初始状态<code>dp[1]=cost[1]</code>和<code>dp[2]=cost[2]</code>，可以得到动态规划代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] cost,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> cost[n];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//还可以使用dp表存储从下至上的信息，</span></span><br><span class="line">   <span class="comment">// 不过本题每一个子问题只与有限个更小子问题有关，因此可以使用滚动变量</span></span><br><span class="line">   <span class="comment">//初始状态</span></span><br><span class="line">   <span class="type">int</span> a=cost[<span class="number">1</span>];</span><br><span class="line">   <span class="type">int</span> b=cost[<span class="number">2</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="type">int</span> tmp=b;</span><br><span class="line">      b=Math.min(a,b)+cost[i];<span class="comment">//状态转移方程</span></span><br><span class="line">      a=tmp;</span><br><span class="line">      <span class="comment">//滚动数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/images/AlgoGettingStart/img_116.png" alt="img_116.png"></li></ol><h3 id="1-2-2-无后效性"><a href="#1-2-2-无后效性" class="headerlink" title="1.2.2 无后效性"></a>1.2.2 无后效性</h3><ol><li>无后效性是动态规划能够有效解决问题的重要特性之一，其定义为：<em><strong>给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关</strong></em></li><li>以爬楼梯问题为例，给定状态i，它会发展出状态i+1和状态i+2，分别对应跳1步和跳2步。在做出这两种选择时，我们无须考虑状态i之前的状态，它们对状态i的未来没有影响</li><li>然而，如果我们给爬楼梯问题添加一个约束，情况就不一样了<ul><li>问题：给定一个共有n阶的楼梯，你每步可以上1阶或2阶，但不能连续两轮跳1阶，请问有多少中方案可以爬到楼顶</li><li><img src="/images/AlgoGettingStart/img_117.png" alt="img_117.png"></li></ul></li><li>在该问题中，如果上一轮是跳1阶上来的，那么下一轮就必须跳2阶。这意味着：<em><strong>下一步选择不能由当前状态(当前所在楼梯阶数)独立决定，还和前一个状态(上一轮所在楼梯阶数)有关</strong></em><ul><li>不难发现，此问题已不满足“无后效性”，状态转移方程dp[i]&#x3D;dp[i-1]+dp[i-2]也失效了。</li><li>因为dp[i-1]代表本轮跳1阶，但其中包含了许多“上一轮是跳1阶上来的”方案，而为了满足约束，我们就不能将dp[i-1]直接计入dp[i]中</li></ul></li><li>为此，我们需要“扩展状态定义”：状态[i,j]表示处在第i阶并且上一轮跳了j阶(j的取值范围为{1,2})。此状态定义有效区分了上一轮跳了1阶还是2阶，我们可以据此判断当前状态是从何而来的<ul><li>当上一轮跳了1阶时，上上一轮只能选择跳2阶，即dp[i,1]只能从dp[i-1,2]转移过来</li><li>当上一轮跳了2阶时，上上一轮可以选择跳1阶或2阶，即dp[i,2]可以从dp[i-2,1]或dp[i-2,2]转移过来</li></ul></li><li>此时的状态转移方程为：<ul><li><code>dp[i,1]=dp[i-1,2]</code></li><li><code>dp[i,2]=dp[i-2,1]+dp[i-2,2]</code></li></ul></li><li>最终，返回 dp[n,1]+dp[n,2]即可，两者之和代表爬到第n阶的方案总数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//状态转移方程</span></span><br><span class="line">   <span class="comment">//`dp[i,1]=dp[i-1,2]`</span></span><br><span class="line">   <span class="comment">// `dp[i,2]=dp[i-2,1]+dp[i-2,2]`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//设计dp表</span></span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">   <span class="comment">//初始化</span></span><br><span class="line">   dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   dp[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">   dp[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   dp[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">1</span>]=dp[i-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">      dp[i][<span class="number">2</span>]=dp[i-<span class="number">2</span>][<span class="number">1</span>]+dp[i-<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][<span class="number">1</span>]+dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面的案例中，由于“仅需多考虑前面一个状态”，因此我们仍然可以通过“扩展状态定义”(让本层的状态包含前几层的信息)，使得问题重新满足无后效性。</li><li>然而，某些问题具有非常严重的无后效性<ul><li>问题：给定一个共有n阶的楼梯，你每步可以上1阶或者2阶。规定当爬到第i阶时，系统自动会在第2i阶上放置障碍物，之后所有轮都不允许跳到第2i阶上。例如，前两轮分别跳到了第2，3阶上，则之后就不能跳到第4，6阶上。请问有多少种方案可以爬到楼顶</li></ul></li><li>在这个问题中，下次跳跃依赖过去的所有状态，因为每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃。对于这类问题，动态规划往往难以解决</li><li>实际上，许多复杂的组合优化问题(例如旅行商问题)不满足无后效性。对于这类问题，我们通常会选择使用其他方法，例如启发式搜索，遗传算法，强化学习等，从而在有限时间内得到可用的局部最优解</li></ol><h2 id="1-3-动态规划解题思路"><a href="#1-3-动态规划解题思路" class="headerlink" title="1.3 动态规划解题思路"></a>1.3 动态规划解题思路</h2><ol><li>如何判断一个问题是不是动态规划问题？</li><li>求解动态规划问题该从何处入手，完整步骤是什么？</li></ol><h3 id="1-3-1-问题判断"><a href="#1-3-1-问题判断" class="headerlink" title="1.3.1 问题判断"></a>1.3.1 问题判断</h3><ol><li>总的来说，如果一个问题包含重叠子问题，最优子结构，并满足无后效性，那么它通常适合用动态规划求解。</li><li>然而，我们很难从问题描述中直接提取出这些特性。因此我们通常会放宽条件，先观察问题是否适合使用回溯(穷举)解决<ul><li>适合用回溯解决的问题通常满足“决策树模型”，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列</li><li>换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决</li></ul></li><li>在此基础上，动态规划问题还有一些判断的“加分项”<ul><li>问题包含最大(小)或最多(少)等最优化描述</li><li>问题的状态能够使用一个列表，多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系</li></ul></li><li>相应地，也存在一些“减分项”<ul><li>问题的目标是找出所有可能的解决方案，而不是找出最优解</li><li>问题描述中有明显的排列组合的特征，需要返回具体的多个方案</li></ul></li><li>如果一个问题满足决策树模型，并具有较为明显的“加分项”，我们就可以假设它是一个动态规划问题，并在求解过程中验证它</li></ol><h3 id="1-3-2-问题求解步骤"><a href="#1-3-2-问题求解步骤" class="headerlink" title="1.3.2 问题求解步骤"></a>1.3.2 问题求解步骤</h3><ol><li>动态规划的解题流程：<code>描述决策，定义状态，建立dp表，推导状态转移方程，确定边界条件</code></li><li>例题：最小路径和<ul><li>给定一个n*m的二维网格grid，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和</li><li><img src="/images/AlgoGettingStart/img_118.png" alt="img_118.png"></li></ul></li><li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul><li>本题每一轮的决策就是从当前格子向下或向右走一步。设当前格子的行列索引为(i,j)，则向下或向右走一步后，索引变为(i+1,j)或(i,j+1)。因此，状态应包含行索引和列索引两个变量，记为(i,j)</li><li>状态(i,j)对应的子问题为：从起始点(0,0)走到(i,j)的最小路径和，解记为dp[i,j]</li><li>由此得到二维dp矩阵<ul><li><img src="/images/AlgoGettingStart/img_119.png" alt="img_119.png"></li></ul></li></ul></li><li>Note：动态规划和回溯过程可以描述为一个“决策序列”，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态<ul><li>每个状态都对应一个子问题，我们会定义一个dp表来“存储所有子问题的解”，状态的每个独立变量都是dp表的一个维度。从本质上看<code>dp表是状态和子问题的解之间的映射</code></li></ul></li><li>第二步：找出最优子结构，进而推导出状态转移方程<ul><li>对于状态(i,j)，它只能从上边格子(i-1,j)和左边格子(i,j-1)转移而来。因此最优子结构为：到达(i,j)的最小路径和 由到达(i,j-1)的最小路径和与到达(i-1,j)的最小路径和中较小的那一个决定</li><li>由此可得状态转移方程<code>dp[i,j]=min(dp[i-1,j],dp[i,j-1])+grid[i,j]</code></li><li><img src="/images/AlgoGettingStart/img_120.png" alt="img_120.png"></li></ul></li><li>Note：根据定义好的dp表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构<ul><li>一旦我们找到了最优子结构，就可以使用它来构建状态转移方程</li></ul></li><li>第三步：确定边界条件和状态转移顺序<ul><li>在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此，首行i&#x3D;0和首列j&#x3D;0是边界条件</li><li>由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列</li><li><img src="/images/AlgoGettingStart/img_121.png" alt="img_121.png"></li></ul></li><li>Note：边界条件在动态规划中用于“初始化dp表”，在搜索中用于剪枝<ul><li>状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确的计算出来</li></ul></li></ol><h4 id="1-3-2-1-方法一：暴力搜索"><a href="#1-3-2-1-方法一：暴力搜索" class="headerlink" title="1.3.2.1 方法一：暴力搜索"></a>1.3.2.1 方法一：暴力搜索</h4><p>从状态(i,j)开始搜索，不断分解为更小的状态(i-1,j)和(i,j-1)，递归函数包括以下要素</p><ol><li>递归参数：状态i,j</li><li>返回值：从(0,0)到(i,j)的最小路径和(dp[i,j])</li><li>终止条件：当i&#x3D;0且j&#x3D;0时返回代价grid[0,0]</li><li>剪枝：当i&lt;0或j&lt;0时索引越界，返回代价maxvalue，代表不可行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPath</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="comment">//若为左上角单元格，则终止搜索，因为它为“初始状态”</span></span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果越界，那么就返回无穷大代价(因为是去最小值，就相当于舍去这种情况)</span></span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> left=minPath(grid,i,j-<span class="number">1</span>);</span><br><span class="line">   <span class="type">int</span> up=minPath(grid,i-<span class="number">1</span>,j);</span><br><span class="line">   <span class="comment">//&quot;状态转移方程&quot;</span></span><br><span class="line">   <span class="keyword">return</span> Math.min(up,left)+grid[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><img src="/images/AlgoGettingStart/img_122.png" alt="img_122.png"><ul><li>该方法包含了一些“重叠子问题”，其数量会随着网格grid的尺寸变大而急剧增多</li><li>从本质上看，造成重叠子问题的原因为：存在多条路径可以从左上角到达某一单元格</li></ul></li><li>每个状态都有向下和向右两种选择，从左上角走到右下角总共需要m+n-2步，所以最差时间复杂度为O(2^(m+n))。<ul><li>请注意，这种计算方式未考虑临近网格边界的情况，当到达网格边界时只剩下一种选择，因此实际的路径数量会少一些</li></ul></li></ol><h4 id="1-3-2-2-方法二：记忆化搜索"><a href="#1-3-2-2-方法二：记忆化搜索" class="headerlink" title="1.3.2.2 方法二：记忆化搜索"></a>1.3.2.2 方法二：记忆化搜索</h4><p>引入一个和网格grid相同尺寸的记忆列表mem，用于记录各个子问题的解，并将重叠子问题进行剪枝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathMem</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span>[][] mem,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> grid[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若已有记录，则直接返回(剪枝)</span></span><br><span class="line">   <span class="keyword">if</span>(mem[i][j]!=-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mem[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> left=minPathMem(grid, mem, i, j-<span class="number">1</span>);</span><br><span class="line">   <span class="type">int</span> up=minPathMem(grid, mem, i-<span class="number">1</span>, j);</span><br><span class="line">   <span class="comment">//记录并返回</span></span><br><span class="line">   mem[i][j]=Math.min(left,up)+grid[i][j];</span><br><span class="line">   <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决与状态总数，即网格尺寸O(mn)</p><h4 id="1-3-2-3-方法三：动态规划"><a href="#1-3-2-3-方法三：动态规划" class="headerlink" title="1.3.2.3 方法三：动态规划"></a>1.3.2.3 方法三：动态规划</h4><p>基于迭代实现动态规划</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathDP</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m= grid.length;</span><br><span class="line">   <span class="type">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">   <span class="comment">//初始化dp表</span></span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;m;x++)&#123;</span><br><span class="line">      dp[x][<span class="number">0</span>]=dp[x-<span class="number">1</span>][<span class="number">0</span>]+grid[x][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;n;x++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][x]=dp[<span class="number">0</span>][x-<span class="number">1</span>]+grid[<span class="number">0</span>][x];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//状态转移，其余行列</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;m;x++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;n;y++)&#123;</span><br><span class="line">         dp[x][y]=Math.min(dp[x-<span class="number">1</span>][y],dp[x][y-<span class="number">1</span>])+grid[x][y];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历了整个网格，时间复杂度为O(mn)</li><li>数组dp大小为nm，因此空间复杂度为O(mn)</li></ol><h4 id="1-3-2-4-空间优化"><a href="#1-3-2-4-空间优化" class="headerlink" title="1.3.2.4 空间优化"></a>1.3.2.4 空间优化</h4><ol><li>由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现dp表</li><li>因为数组dp只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathDPComp</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m= grid.length;</span><br><span class="line">   <span class="type">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">   dp[<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">      dp[i]=dp[i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="comment">//状态转移：首列</span></span><br><span class="line">      dp[<span class="number">0</span>]=grid[i][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">         dp[j]=Math.min(dp[j-<span class="number">1</span>],dp[j])+grid[i][j];</span><br><span class="line">         <span class="comment">//dp[j-1]表示左边格子，dp[i]表示上边格子</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-0-1背包问题"><a href="#1-4-0-1背包问题" class="headerlink" title="1.4 0-1背包问题"></a>1.4 0-1背包问题</h2><ol><li>例题：给定n个物品，第i个物品的重量为wgt[i-1],价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值</li><li><img src="/images/AlgoGettingStart/img_123.png" alt="img_123.png"><ul><li>由于物品编号i从1开始计数，数组索引从0开始计数，因此物品i对应重量wgt[i-1]和价值val[i-1]</li></ul></li><li>我们可以将0-1背包问题看作一个由n轮决策组成的过程，对于每个物体都有放入和不放入两种决策，因此该问题满足决策树模型</li><li>该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题</li><li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul><li>对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减少。由此可得状态定义：当前物品编号i和剩余背包容量c，记为[i,c]</li><li>状态[i,c]对应的子问题为：前i个物品在剩余容量为c的背包中的最大价值，记为dp[i,c]</li><li>待求解的是dp[n,cap]，因此需要一个尺寸为(n+1)*(cap+1)的二维dp表</li></ul></li><li>第二步：找出最优子结构，进而推导出状态转移方程<ul><li>当我们做出物品i的决策后，剩余的是前i-1个物品的决策，可分为以下两种情况<ul><li>不放入物品i：背包容量不变，状态变化为[i-1,c]</li><li>放入物品i：背包容量减少wgt[i-1],价值增加val[i-1]，状态变化为[i-1,c-wgt[i-1]]</li></ul></li><li>上述分析向我们揭示了本题的最优子结构：最大价值dp[i,c]等于不放入物品i和放入物品i两种方案中价值更大的那一个<ul><li>状态转移方程:<code>dp[i,c]=max(dp[i-1,c],dp[i-1,c-wgt[i-1]]+val[i-1])</code><ul><li>如果没放入i：说明[i,c]处的val等于[i-1,c]处的val</li><li>如果放入i：说明[i,c]处的val等于[i-1,c-wgt[i-1]]处的val再加上i的val<ul><li>dp[i-1,c-wgt[i-1]]:前i-1个物品在剩余容量为“c-wgt[i-1]”的情况下所占的最大价值(wgt[i-1]的容量被i占了)</li></ul></li></ul></li></ul></li></ul></li><li>确定边界条件和状态转移顺序：<ul><li>当无物品或无剩余背包容量时最大价值为0，即首列dp[i,0]和首行dp[0,c]都等于0</li><li>当前状态[i,c]由上方的状态[i-1,c]和左上方的状态[i-1,c-wgt[i-1]]转移而来，因此通过两层循环正序遍历整个dp表即可</li></ul></li></ol><h3 id="1-4-1-方法一：暴力搜索"><a href="#1-4-1-方法一：暴力搜索" class="headerlink" title="1.4.1 方法一：暴力搜索"></a>1.4.1 方法一：暴力搜索</h3><ol><li>递归参数：状态i，c</li><li>返回值：子问题的解dp[i,c]</li><li>终止条件：当物品编号越界i&#x3D;0或背包剩余容量为0时，终止递归并返回价值0(边界条件的值)</li><li>剪枝：若当前物品重量超出背包剩余容量，则只能选择不放入背包<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span> i,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>||c==<span class="number">0</span>)&#123;<span class="comment">//边界情况</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(wgt[i-<span class="number">1</span>]&gt;c)&#123;</span><br><span class="line">      <span class="keyword">return</span> knapsackDFS(wgt, val, i-<span class="number">1</span>, c);<span class="comment">//只能选择不放入</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> no=knapsackDFS(wgt, val, i-<span class="number">1</span>, c);</span><br><span class="line">   <span class="type">int</span> yes=knapsackDFS(wgt,val,i-<span class="number">1</span>,c-wgt[i-<span class="number">1</span>])+val[i-<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> Math.max(no,yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/AlgoGettingStart/img_124.png" alt="img_124.png"></li></ol><ul><li>由于每个物品都会产生选和不选两条搜索分支，因此时间复杂度为O(2^n)</li><li>观察递归树，容易发现其中存在重叠子问题，例如dp[1,10]等。而当物品较多，背包容量较大时，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多</li></ul><h3 id="1-4-2-记忆化搜索"><a href="#1-4-2-记忆化搜索" class="headerlink" title="1.4.2 记忆化搜索"></a>1.4.2 记忆化搜索</h3><ol><li>为了保证重叠子问题只被计算一次，我们借助记忆列表mem来记录子问题的解，其中mem[i,c]对应dp[i,c]</li><li>引入记忆化后，时间复杂度取决于子问题数量，也就是O(n*cap)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDFSMem</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span>[][] mem,<span class="type">int</span> i,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>||c==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//若已有记录，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span>(mem[i][c]!=-<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> mem[i][c];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(wgt[i-<span class="number">1</span>]&gt;c)&#123;</span><br><span class="line">      <span class="keyword">return</span> knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> no=knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c);</span><br><span class="line">   <span class="type">int</span> yes=knapsackDFSMem(wgt, val, mem, i-<span class="number">1</span>, c-wgt[i-<span class="number">1</span>])+val[i-<span class="number">1</span>];</span><br><span class="line">   mem[i][c]=Math.max(no,yes);</span><br><span class="line">   <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/AlgoGettingStart/img_125.png" alt="img_125.png"></li></ol><h3 id="1-4-3-方法三：动态规划"><a href="#1-4-3-方法三：动态规划" class="headerlink" title="1.4.3 方法三：动态规划"></a>1.4.3 方法三：动态规划</h3><p>动态规划实质上就是在状态转移中填充dp表的过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDP</span><span class="params">(<span class="type">int</span>[] val,<span class="type">int</span>[] wgt,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n= val.length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//默认初始化第一列和第一行都为0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(wgt[i]&gt;c)&#123;<span class="comment">//不选</span></span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-wgt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都有数组dp大小决定，即O(n*cap)</p><h3 id="1-4-4-空间优化"><a href="#1-4-4-空间优化" class="headerlink" title="1.4.4 空间优化"></a>1.4.4 空间优化</h3><ol><li>由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从O(n^2)降至O(n)</li><li>进一步思考，能否仅用一个数组实现空间优化。每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第i行时，该数组存储的仍然是第i-1行的状态<ul><li>如果采取正序遍历，那么遍历到dp[i,j]时，左上方dp[i-1,1]~dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果</li><li>如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] val,<span class="type">int</span>[] wgt,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=val.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[c + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=c;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(wgt[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">                    dp[j]=Math.max(dp[j-wgt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>],dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[c];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-5-完全背包问题"><a href="#1-5-完全背包问题" class="headerlink" title="1.5 完全背包问题"></a>1.5 完全背包问题</h2><h3 id="1-5-1-完全背包问题"><a href="#1-5-1-完全背包问题" class="headerlink" title="1.5.1 完全背包问题"></a>1.5.1 完全背包问题</h3><p>例题：给定n个物品，第i个物品的重量为wgt[i-1]，价值为val[i-1]，和一个容量为cap的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值</p><ul><li><img src="/images/AlgoGettingStart/img_126.png" alt="img_126.png"></li></ul><h4 id="1-5-1-1-动态规划思路"><a href="#1-5-1-1-动态规划思路" class="headerlink" title="1.5.1.1 动态规划思路"></a>1.5.1.1 动态规划思路</h4><ol><li>完全背包问题和0-1背包问题非常相似，区别在于不限制物品的选择次数<ul><li>在0-1背包问题中，每种物品只有一个，因此将物品i放入背包后，只能从前i-1个物品中选择</li><li>在完全背包问题中，每种物品的数量是无限的，因此将物品i放入背包后，仍可以从前i个物品中选择</li></ul></li><li>在完全背包问题的规定下，状态[i,c]的变化分为两种情况<ul><li>不放入物品：与0-1背包问题相同，转移至[i-1,c]</li><li>放入物品，与0-1背包问题不同，转移至[i,c-wgt[i-1]]</li></ul></li><li>从而状态转移方程变为:<code>dp[i,c]=max(dp[i-1,c],dp[i,c-wgt[i-1]]+val[i-1])</code></li></ol><h4 id="1-5-1-2-代码实现"><a href="#1-5-1-2-代码实现" class="headerlink" title="1.5.1.2 代码实现"></a>1.5.1.2 代码实现</h4><p>只有状态转移方程有些许不一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDP</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">   <span class="comment">// 初始化 dp 表</span></span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][cap + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">// 状态转移</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">            dp[i][c] = Math.max(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-3-空间优化"><a href="#1-5-1-3-空间优化" class="headerlink" title="1.5.1.3 空间优化"></a>1.5.1.3 空间优化</h4><ol><li>由于当前状态是从左边和上边的状态转移而来的，因此空间优化后应该对dp表中的每一行进行正序遍历</li><li>这个遍历顺序与0-1背包正好相反(因为0-1背包问题的当前状态是从左上方和上方的状态转移而来的)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">   <span class="comment">// 初始化 dp 表</span></span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">// 状态转移</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">            <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            dp[c] = dp[c];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">            dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-5-2-零钱兑换问题"><a href="#1-5-2-零钱兑换问题" class="headerlink" title="1.5.2 零钱兑换问题"></a>1.5.2 零钱兑换问题</h3><p>例题：给定n种硬币，第i中硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，返回-1</p><ul><li><img src="/images/AlgoGettingStart/img_127.png" alt="img_127.png"></li></ul><h4 id="1-5-2-1-动态规划思路"><a href="#1-5-2-1-动态规划思路" class="headerlink" title="1.5.2.1 动态规划思路"></a>1.5.2.1 动态规划思路</h4><ol><li>零钱兑换可以看作完全背包问题的一种特殊情况，两者具有以下联系和不同点<ul><li>两道题可以相互转换，“物品”对应“硬币”，“物品重量”对应“硬币面值”，“背包容量”对应“目标金额”</li><li>优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量</li><li>完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解</li></ul></li><li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul><li>状态[i,a]对应的子问题为：前i种硬币能够凑出金额a的最少硬币数量，记为dp[i,a]</li><li>二维dp表的尺寸为(n+1)*(amt+1)</li></ul></li><li>第二步：找出最优子结构，进而推导出状态转移方程<ul><li>本题与完全背包问题的状态转移方程存在以下两点差异<ul><li>本题要求最小值，因此需要min()</li><li>优化主体是硬币数量而非商品价值，因此在选中硬币时执行+1即可</li></ul></li><li>状态转移方程：<code>dp[i,a]=min(dp[i-1,a],dp[i,a-coins[i-1]]+1)</code></li></ul></li><li>第三步：确定边界条件和状态转移顺序<ul><li>当目标金额为0时，凑出它的最少硬币数量为0，即首列所有dp[i,0]都等于0</li><li>当无硬币时，无法凑出任意&gt;0的目标金额，即是无效解。为使状态转移方程中的min()函数能够识别并过滤无效解，我们考虑使用+∞来表示它们，即令首行所有dp[0,a]都等于+∞</li></ul></li></ol><h4 id="1-5-2-2-代码实现"><a href="#1-5-2-2-代码实现" class="headerlink" title="1.5.2.2 代码实现"></a>1.5.2.2 代码实现</h4><ol><li>大多数编程语言并未提供+∞变量，只能使用整型int的最大值来代替。而这样又会导致大数越界：状态转移方程中的+1操作可能发生溢出</li><li>为此，我们采用数字amt+1来表示无效解，因为凑出amt的硬币数量最多为amt。最后返回前，判断dp[n,amt]是否等于amt+1，若是则返回-1，代表无法凑出目标金额(如果无法凑出目标金额，即表示会存在子问题的a小于任意的coins[i]，导致其值等于dp[i&#x3D;0,a])<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeDP</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span> MAX=amt+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">   <span class="comment">//初始化dp表</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amt;i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i]=MAX;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][amt]==MAX?-<span class="number">1</span>:dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-5-2-3-空间优化"><a href="#1-5-2-3-空间优化" class="headerlink" title="1.5.2.3 空间优化"></a>1.5.2.3 空间优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeDPComp</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span> MAX=amt+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amt;i++)&#123;</span><br><span class="line">      dp[i]=MAX;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!(coins[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">            dp[j]=Math.min(dp[j],dp[j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[amt]==MAX?-<span class="number">1</span>:dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-零钱兑换问题II"><a href="#1-5-3-零钱兑换问题II" class="headerlink" title="1.5.3 零钱兑换问题II"></a>1.5.3 零钱兑换问题II</h3><p>例题：给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问凑出目标金额的硬币组合数量—&gt;最大组合数量</p><ul><li><img src="/images/AlgoGettingStart/img_128.png" alt="img_128.png"></li></ul><h4 id="1-5-3-1-动态规划思路"><a href="#1-5-3-1-动态规划思路" class="headerlink" title="1.5.3.1 动态规划思路"></a>1.5.3.1 动态规划思路</h4><ol><li>子问题为：前i种硬币能够凑出金额a的(最大)组合数量。dp表为(n+1)*(amt+1)的二维矩阵</li><li>当前状态的组合数量等于“不选当前硬币”与“选当前硬币”这两种决策的组合数量之和。状态转移方程为：<ul><li><code>dp[i,a]=dp[i-1,a]+dp[i,a-coins[i-1]]</code></li></ul></li><li>当目标金额为0时，无须选择任何硬币即可凑出目标金额，因此应将首列所有dp[i,0]都初始化为1.当无硬币时，无法凑出任何&gt;0的目标金额，因此首行所有dp[0,a]都等于0</li></ol><h4 id="1-5-3-2-代码实现"><a href="#1-5-3-2-代码实现" class="headerlink" title="1.5.3.2 代码实现"></a>1.5.3.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i-<span class="number">1</span>]&gt;j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-3-3-代码优化"><a href="#1-5-3-3-代码优化" class="headerlink" title="1.5.3.3 代码优化"></a>1.5.3.3 代码优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=coins.length;</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">   dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=amt;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!(coins[i-<span class="number">1</span>]&gt;j))&#123;</span><br><span class="line">            dp[j]=dp[j]+dp[j-coins[i-<span class="number">1</span>]];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-编辑距离问题"><a href="#1-6-编辑距离问题" class="headerlink" title="1.6 编辑距离问题"></a>1.6 编辑距离问题</h2><ol><li>编辑距离，也称“Levenshtein”距离，指“两个字符串之间互相转换的最少修改次数”，通常用于在信息检索和自然语言处理中度量两个序列的相似度</li><li>例题：输入两个字符串s和t，返回将s转换为t所需要的最少编辑步数<ul><li>你可以在一个字符串中进行三种编辑操作：插入一个字符，删除一个字符，将字符替换为任意一个字符</li><li><img src="/images/AlgoGettingStart/img_129.png" alt="img_129.png"></li></ul></li><li>编辑距离问题可以很自然的用决策树模型来解释。字符串对应树节点，一轮决策(一轮编辑操作)对应树的一条边</li><li><img src="/images/AlgoGettingStart/img_130.png" alt="img_130.png"><ul><li>在不限制操作的情况下，每个节点都可以派生出许多条边，每条边对应一种操作，这意味着从hello转换到algo有许多种可能的路径</li><li>从决策树的角度看，本题的目标是求解节点hello和节点algo之间的最短路径</li></ul></li></ol><h3 id="1-6-1-动态规划思路"><a href="#1-6-1-动态规划思路" class="headerlink" title="1.6.1 动态规划思路"></a>1.6.1 动态规划思路</h3><ol><li>第一步：思考每轮的决策，定义状态，从而得到dp表<ul><li>每一轮的决策是对字符串s进行一次编辑操作</li><li>我们希望在编辑操作的过程中，问题的规模逐渐缩小，这样才能构建子问题。设字符串s和t的长度分别为n和m，我们先考虑两字符串尾部的字符s[n-1]和t[m-1]<ul><li>若s[n-1]和t[m-1]相同，我们可以跳过它们，直接考虑s[n-2]和t[m-2]</li><li>若s[n-1]和t[m-1]不同，我们需要对s进行一次编辑(插入，删除，替换)，使得两字符串尾部的字符相同，从而可以跳过它们，考虑规模更小的问题</li></ul></li><li>也就是说，我们在字符串中进行的每一轮决策(编辑操作)，都会使得s和t中剩余的待匹配字符发生变化。因此，状态为 当前在s和t中考虑的第i和第j个字符，记为[i,j]</li><li>状态[i,j]对应的子问题：将s的前i个字符更改为t的前j个字符所需要的最少编辑步数</li><li>至此，得到一个(n+1)*(m+1)的二维dp表</li></ul></li><li>找出最优子结构，进而推导出状态转移方程<ul><li>考虑子问题dp[i,j]，其对应的两个字符串的尾部字符为s[i-1]和t[j-1]，可根据不同编辑操作分为三种情况</li><li><img src="/images/AlgoGettingStart/img_131.png" alt="img_131.png"><ul><li>在s[i-1]之后添加t[j-1]，则剩余子问题dp[i,j-1] (i不动，j前移)</li><li>删除s[i-1],则剩余子问题dp[i-1,j] (j不动，i前移)</li><li>将s[i-1]替换为t[j-1]，则剩余子问题dp[i-1,j-1] (i,j都前移)</li></ul></li><li>根据以上分析可得最优子结构：dp[i,j]的最少编辑步数等于dp[i-1,j],dp[i,j-1],dp[i-1,j-1]三者中的最少编辑步数，再加上本次的编辑步数1<ul><li>对应的状态转移方程为<code>dp[i,j]=min(dp[i-1,j],dp[i,j-1],dp[i-1,j-1])+1</code></li></ul></li><li>请注意，当s[i-1]和t[j-1]相同时，无须编辑当前字符，这种状态下的状态转移方程为<ul><li><code>dp[i,j]=dp[i-1,j-1]</code></li></ul></li></ul></li><li>确定边界条件和状态转移顺序<ul><li>当两字符串都为空时，编辑步数为0，即dp[0,0]&#x3D;0。</li><li>当s为空但t不为空时，最少编辑步数等于t的长度，即首行dp[0,j]&#x3D;j。</li><li>当s不为空但是t为空时，最少编辑步数等于s的长度，即首列dp[i,0]&#x3D;i</li><li>观察状态转移方程，解dp[i,j]依赖左方，上方，左上方的解，因此通过两层循环正序遍历整个dp表即可</li></ul></li></ol><h3 id="1-6-2-代码实现"><a href="#1-6-2-代码实现" class="headerlink" title="1.6.2 代码实现"></a>1.6.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistanceDP</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=s.length();</span><br><span class="line">   <span class="type">int</span> m=t.length();</span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j]=Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]),dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-3-空间优化"><a href="#1-6-3-空间优化" class="headerlink" title="1.6.3 空间优化"></a>1.6.3 空间优化</h3><ol><li>由于dp[i,j]是由上方dp[i-1,j]，左方dp[i,j-1]，左上方dp[i-1,j-1]转移而来的，而正序遍历会丢失左上方dp[i-1,j-1]。倒序遍历无法提前构建dp[i,j-1]，因此两种遍历顺序都不可取</li><li>为此，我们可以使用一个变量leftup来暂存左上方的解dp[i-1,j-1]，从而只需考虑左方和上方的解。此时可使用正序遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">editDistanceDPComp</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">   <span class="type">int</span> m=t.length();</span><br><span class="line">   <span class="type">int</span> n=s.length();</span><br><span class="line">   <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">      dp[i]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="type">int</span> leftup=dp[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">0</span>]=i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">         <span class="type">int</span> temp=dp[j];<span class="comment">//dp[j]会被覆盖掉</span></span><br><span class="line">         <span class="keyword">if</span>(!(s.charAt(i)==t.charAt(j)))&#123;</span><br><span class="line">            dp[j]=Math.min(Math.min(dp[j],dp[j-<span class="number">1</span>]),leftup)+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[j]=leftup;</span><br><span class="line">         &#125;</span><br><span class="line">         leftup=temp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-7-小结："><a href="#1-7-小结：" class="headerlink" title="1.7 小结："></a>1.7 小结：</h2><ol><li>动态规划对问题进行分解，并通过存储子问题的解来规避重复计算，提高计算效率</li><li>不考虑时间的前提下，所有动态规划问题都可以用回溯(暴力搜索)进行求解，但递归树中存在大量的重叠子问题，效率极低。通过引入记忆化列表，可以存储所有计算过的子问题，从而保证重叠子问题只被计算一次</li><li>记忆化搜索时一种从顶至底的递归式解法，而与之对应的动态规划是一种从底至顶的递推式解法，其如同“填写表格”一样。由于当前状态仅依赖某些局部状态，因此我们可以消除dp表的一个维度，从而降低空间复杂度</li><li>子问题分解是一种通用的算法思路，在分治，动态规划，回溯中具有不同的性质</li><li>动态规划问题有三大特性：重叠子问题，最优子结构，无后效性</li><li>如果原问题的最优解可以从子问题的最优解构建得来，则它就具有最优子结构</li><li>无后效性指对于一个状态，其未来发展只与该状态有关，而与过去的所有状态无关。许多组合优化问题不具有无后效性，无法使用动态规划快速求解</li></ol><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ol><li>背包问题是最典型的动态规划问题之一，具有0-1背包，完全背包，多重背包等变种</li><li>0-1背包问题的状态定义为 前i个物品在剩余容量为c的背包中的最大价值。根据不放入背包和放入背包两种决策，可得到最优子结构，并构建出状态转移方程。在空间优化中，由于每个状态依赖正上方和左上方的状态，因此需要倒序遍历列表，避免左上方状态被覆盖</li><li>完全背包问题的每种物品的选取数量无限制，因此选择放入物品的状态转移与0-1背包问题不同。由于状态依赖与正上方状态和正左方状态，因此在空间优化中应当正序遍历</li><li>零钱兑换问题是完全背包问题的一个变种。它从求“最大”价值变为求“最小”硬币数量，因此状态转移方程中的max()应改为min()。从追求“不超过”背包容量到追求“恰好”凑出目标金额，因此使用amt+1来表示“无法凑出目标金额”的无效解</li><li>零钱兑换问题II从求“最少硬币数量”改为求“最大硬币组合数量”，状态转移方程相应地从min()改为求和运算符</li></ol><h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><ol><li>编辑距离(Levenshtein距离)用于衡量两个字符串之间的相似度，其定义为从一个字符串到另一个字符串的最少编辑步数。编辑操作包括 添加，删除，替换</li><li>编辑距离问题的状态定义为将s的前i个字符更改为t的前j个字符所需的最少编辑步数。当s[i]!&#x3D;t[j]时，具有三种决策：添加，删除，替换，它们都有相应的剩余子问题。据此便可以找出最优子结构与构建状态转移方程。而当s[i]&#x3D;t[j]时，无须编辑当前字符</li><li>在编辑距离中，状态依赖其正上方，正左方，左上方的状态，因此空间优化后正序或倒序遍历都无法正确的进行状态转移。为此，我们使用一个变量暂存左上方状态，从而转化到与完全背包问题等价的情况，可以在空间优化后进行正序遍历</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13贪心算法</title>
      <link href="/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/"/>
      <url>/2024/05/23/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/class13/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="1-1-贪心算法"><a href="#1-1-贪心算法" class="headerlink" title="1.1 贪心算法"></a>1.1 贪心算法</h2><ol><li>贪心算法<code>greedy algorithm</code>是一种常见的解决优化问题的算法</li><li>其“基本思想”是：在问题的每个决策阶段，都选择“当前看起来最优的选择”<ul><li>即贪心的做出“局部最优的决策”，以期获得全局最优解</li></ul></li><li>贪心算法简洁而高效，在许多实际问题中有着广泛的应用</li><li>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同<ul><li>动态规划会根据之前阶段的所有决策(的结果)来考虑当前决策，并使用过去子问题的解来构建当前子问题的解</li><li>贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决</li></ul></li><li>先通过例题“零钱兑换”了解贪心算法的工作原理<ul><li>例题：给定n种硬币，第i中硬币的面值为coins[i-1],目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回-1</li><li><img src="/images/AlgoGettingStart/img_132.png" alt="img_132.png"><ul><li>给定目标金额，我们贪心地选择不大于且最接近它的硬币(局部最优)，不断循环该步骤，直至凑出目标金额为止<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChangeGreedy</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">   <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(amt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(coins[i]&lt;amt&amp;&amp;coins[i]&gt;max)&#123;</span><br><span class="line">            max=coins[i];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      amt-=max;</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> amt==<span class="number">0</span>?count:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="1-1-1-贪心算法的优点和局限性"><a href="#1-1-1-贪心算法的优点和局限性" class="headerlink" title="1.1.1 贪心算法的优点和局限性"></a>1.1.1 贪心算法的优点和局限性</h3><ol><li>贪心算法不仅操作直接，实现简单，而且通常效率也很高<ul><li>在以上代码中，记硬币最小面值为min(coins)，则贪心选择最多循环 amt&#x2F;min(coins)次，时间复杂度为O(amt&#x2F;min(coins))。</li><li>这比动态规划解法的时间复杂度O(n*amt)少了一个数量级</li></ul></li><li>然而，对于某些硬币面值组合，贪心算法并不能找到最优解<ul><li>正例：coins&#x3D;[1,5,10,20,50,100]:在该硬币组合下，给定任意amt，贪心算法都可以找到最优解</li><li>反例：coins&#x3D;[1,20,50]:假设amt&#x3D;60，贪心算法只能找到 50+10<em>1的兑换组合，共计11枚硬币，但动态规划可以找到最优解 20</em>3，只需3枚硬币</li><li>反例：coins&#x3D;[1,49,50]:假设amt&#x3D;98，贪心算法只能找到 50+48<em>1的兑换组合，共计49枚硬币，但动态规划可以找到最优解 49</em>2，只需2枚硬币</li></ul></li><li>也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。硬币兑换问题更适合用动态规划解决</li><li>一般情况下，贪心算法的使用情况分为以下两种：<ul><li>可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯，动态规划更高效</li><li>可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的</li></ul></li></ol><h3 id="1-1-2-贪心算法特性"><a href="#1-1-2-贪心算法特性" class="headerlink" title="1.1.2 贪心算法特性"></a>1.1.2 贪心算法特性</h3><p>什么样的问题适合用贪心算法求解？贪心算法在什么情况下可以保证找到最优解？</p><ol><li>相较于动态规划，贪心算法的“使用条件”更加苛刻，其主要关注问题的两个性质<ul><li>贪心选择性质：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解</li><li>最优子结构：原问题的最优解包含子问题的最优解</li></ul></li><li>值的注意的是，一些问题的最优子结构并不明显，但仍然可用贪心算法解决</li><li>证明贪心选择性质很难</li></ol><h3 id="1-1-3-贪心算法解题步骤"><a href="#1-1-3-贪心算法解题步骤" class="headerlink" title="1.1.3 贪心算法解题步骤"></a>1.1.3 贪心算法解题步骤</h3><ol><li>贪心问题的解决流程大体可分为以下三步：<ul><li>问题分析：梳理与理解问题特性，包括状态定义，优化目标和约束条件等。这一步在回溯和动态规划中都有涉及</li><li>确定贪心策略：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题</li><li>正确性证明：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用数学证明，例如归纳法或反证法等</li></ul></li><li>确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因：<ul><li>不同问题的贪心策略的差异较大。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂的问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了</li><li>某些贪心策略具有较强的迷惑性。当我们设计好贪心策略，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，例如上文介绍的零钱兑换</li></ul></li><li>为保证正确性，我们应该对贪心策略进行严谨的数学证明，通常需要用到反证法或数学归纳法</li></ol><h3 id="1-1-4-贪心算法典型例题"><a href="#1-1-4-贪心算法典型例题" class="headerlink" title="1.1.4 贪心算法典型例题"></a>1.1.4 贪心算法典型例题</h3><ol><li>硬币找零问题：在某些硬币组合下，贪心算法总是可以得到最优解</li><li>区间调度问题：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。<ul><li>如果每次都选择 结束时间最早的任务，那么贪心算法就可以得到最优解</li></ul></li><li>分数背包问题：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。<ul><li>如果每次都选择性价比最高(价值&#x2F;重量)的物品，那么贪心算法在一些情况下可以得到最优解</li></ul></li><li>股票买卖问题：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润</li><li>霍夫曼编码：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度(编码长度)最小</li><li>Dijkstra算法：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法</li></ol><h2 id="1-2-分数背包问题"><a href="#1-2-分数背包问题" class="headerlink" title="1.2 分数背包问题"></a>1.2 分数背包问题</h2><p>例题：给定n个物品，第i个物品的重量为wgt[i-1]，价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值</p><ul><li><img src="/images/AlgoGettingStart/img_133.png" alt="img_133.png"></li></ul><ol><li>分数背包问题和0-1背包问题整体上非常相似，状态包含当前物品i和容量c，目标是求限定背包容量下的最大价值</li><li>不同点在于，本题允许“只选择物品的一部分”。我们可以对物品任意地进行切分，并按照重量比例来计算相应价值<ul><li>对于物品i，它在单位重量下的价值为 val[i-1]&#x2F;wgt[i-1]，简称 单位价值</li><li>假设放入一部分物品i，重量为w，则背包增加的价值为 w*(val[i-1]&#x2F;wgt[i-1])</li><li><img src="/images/AlgoGettingStart/img_134.png" alt="img_134.png"></li></ul></li></ol><h3 id="1-2-1-贪心策略确定"><a href="#1-2-1-贪心策略确定" class="headerlink" title="1.2.1 贪心策略确定"></a>1.2.1 贪心策略确定</h3><ol><li>最大化背包内物品总价值，本质上是“最大化单位重量下的物品价值”</li><li><img src="/images/AlgoGettingStart/img_135.png" alt="img_135.png"><ul><li>将物品按照单位价值从高到低进行排序</li><li>遍历所有物品，每轮贪心的选择单位价值最高的物品</li><li>若剩余背包容量不足，则使用当前物品的一部分填满背包</li></ul></li></ol><h3 id="1-2-2-代码实现"><a href="#1-2-2-代码实现" class="headerlink" title="1.2.2 代码实现"></a>1.2.2 代码实现</h3><p>我们建立了一个物品类Item，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>&#123;</span><br><span class="line">   <span class="type">int</span> w;</span><br><span class="line">   <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.w = w;</span><br><span class="line">      <span class="built_in">this</span>.v = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">fractionalKnapsack</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span> cap)</span>&#123;</span><br><span class="line">   <span class="type">int</span> n=wgt.length;</span><br><span class="line">   Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[n];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      items[i]=<span class="keyword">new</span> <span class="title class_">Item</span>(wgt[i], val[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//按照单位价值从高到低进行排序</span></span><br><span class="line">   Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((<span class="type">double</span>) item.v/item.w)));</span><br><span class="line">   <span class="comment">//循环贪心选择</span></span><br><span class="line">   <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">      <span class="keyword">if</span>(item.w&lt;cap)&#123;</span><br><span class="line">         res+=item.v;</span><br><span class="line">         cap-= item.w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">         res+=(<span class="type">double</span>)cap* item.v/item.w;</span><br><span class="line">         <span class="comment">//已无剩余容量，因此跳出循环</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除排序之外，在最差情况下，需要遍历整个物品列表，因此时间复杂度为O(n)，其中n为物品数量。由于初始化了一个Item对象列表，因此空间复杂度为O(n)</p><h3 id="1-2-3-正确性声明"><a href="#1-2-3-正确性声明" class="headerlink" title="1.2.3 正确性声明"></a>1.2.3 正确性声明</h3><ol><li>采用反证法。假设物品x是单位价值最高的物品，使用某算法求得最大价值为res，但该解中不包含物品x</li><li>现在从背包中拿出单位重量的任何物品，并替换为单位重量的物品x。由于物品x的单位价值最高，因此替换后的总价值一定大于res。这与res是最优解矛盾，说明最优解中必须包含物品x</li><li>对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，单位价值更大的物品总是更优选择，这说明贪心策略是有效地</li><li><img src="/images/AlgoGettingStart/img_136.png" alt="img_136.png"></li></ol><h2 id="1-3-最大容量问题"><a href="#1-3-最大容量问题" class="headerlink" title="1.3 最大容量问题"></a>1.3 最大容量问题</h2><p>例题：输入一个数组ht，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。容器的容量等于高度和宽度的乘积，其高度由较短的隔板决定，宽度是两个隔板的数组索引之差。请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量</p><ul><li><img src="/images/AlgoGettingStart/img_137.png" alt="img_137.png"></li></ul><ol><li>容器由任意两个隔板围成，因此本题的状态为两个隔板的索引，记为[i,j]</li><li>根据题意，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的数组索引之差。设容量为cap[i,j]，可得计算公式<ul><li><code>cap[i,j]=min(ht[i],ht[j])*(j-i)</code></li></ul></li><li>设数组长度为n，两个隔板的组合数量(状态总数)为 n(n-1)&#x2F;2。最直接的，我们可以穷举所有状态，从而求得最大容量，时间复杂度为O(n^2)</li></ol><h3 id="1-3-1-贪心策略确定"><a href="#1-3-1-贪心策略确定" class="headerlink" title="1.3.1 贪心策略确定"></a>1.3.1 贪心策略确定</h3><ol><li>这道题还有更高效率的解法。现选取一个状态[i,j]，其满足索引i&lt;j且高度ht[i]&lt;ht[j]，即i为短板，j为长板<ul><li><img src="/images/AlgoGettingStart/img_138.png" alt="img_138.png"></li></ul></li><li>若此时将长板j向短板i靠近，则容量一定减小<ul><li>这是因为在移动长板j后，宽度j-i一定变小。而高度由短板决定，因此高度只可能不变或减小</li></ul></li><li>反过来思考，我们只有向内收缩短板i，才“有可能”使容量变大。<ul><li>因为虽然宽度一定变小，但是高度可能会变大(移动后的短板i可能会变长)</li></ul></li><li>由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇</li><li>贪心策略的执行过程<ul><li>初始状态下，指针i和指针j分列数据两端</li><li>计算当前状态的容量cap[i,j]，并更新最大容量</li><li>比较板i和板j的高度，并将短板向内移动一格</li><li>循环执行第2步和第3步，直至i和j相遇时结束</li></ul></li></ol><h3 id="1-3-2-代码实现"><a href="#1-3-2-代码实现" class="headerlink" title="1.3.2 代码实现"></a>1.3.2 代码实现</h3><ol><li>代码最多循环n轮，因此时间复杂度为O(n)</li><li>变量i，j，res使用常数大小的额外空间，因此空间复杂度为O(1)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxCapacity</span><span class="params">(<span class="type">int</span>[] ht)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> j=ht.length-<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">      <span class="type">int</span> cap=Math.min(ht[i],ht[j])*(j-i);</span><br><span class="line">      max=Math.max(max,cap);</span><br><span class="line">      <span class="keyword">if</span>(ht[i]&gt;ht[j])&#123;</span><br><span class="line">         j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-3-正确性证明"><a href="#1-3-3-正确性证明" class="headerlink" title="1.3.3 正确性证明"></a>1.3.3 正确性证明</h3><ol><li>之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态</li><li>比如在状态cap[i,j]下，i为短板，j为长板。若贪心地将短板i向内移动一格，会导致如图状态被“跳过”。这意味着之后无法验证这些状态的容量大小<ul><li><img src="/images/AlgoGettingStart/img_139.png" alt="img_139.png"></li></ul></li><li>观察发现，这些被跳过的状态实际上就是将长板j向内移动的所有状态。前面我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，跳过它们不会导致错过最优解</li></ol><h2 id="1-4-最大切分乘积问题"><a href="#1-4-最大切分乘积问题" class="headerlink" title="1.4 最大切分乘积问题"></a>1.4 最大切分乘积问题</h2><p>例题：给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少</p><ul><li><img src="/images/AlgoGettingStart/img_140.png" alt="img_140.png"></li></ul><ol><li>假设我们将n切分为m个整数因子，其中第i个因子记为Ni，即<ul><li><img src="/images/AlgoGettingStart/img_141.png" alt="img_141.png"></li></ul></li><li>本题的目标是求得所有整数因子的最大乘积，即：<ul><li><img src="/images/AlgoGettingStart/img_142.png" alt="img_142.png"></li></ul></li><li>我们需要思考的是：切分数量m应该多大，每个Ni应该是多小</li></ol><h3 id="1-4-1-贪心策略确定"><a href="#1-4-1-贪心策略确定" class="headerlink" title="1.4.1 贪心策略确定"></a>1.4.1 贪心策略确定</h3><ol><li>根据经验，两个整数的乘积往往比它们的加和更大。假设从n中分出一个因子2，则它们的乘积为2(n-2)。我们将该乘积与n作比较<ul><li><img src="/images/AlgoGettingStart/img_143.png" alt="img_143.png"></li><li>当n&gt;&#x3D;4时，切分出一个2后乘积会变大，这说明“大于等于4的整数都应该被切分”</li></ul></li><li>贪心策略I：如果切分方案中包含&gt;&#x3D;4的因子，那么它就应该被继续切分。最终的切分方案只应出现1，2，3这三种因子<ul><li><img src="/images/AlgoGettingStart/img_144.png" alt="img_144.png"></li><li>接下来考虑哪个因子是最优的。在1，2，3这三个因子中，显然1是最差的，因为 1*(n-1)&lt;n恒成立，即切分出1反而会导致乘积减小</li></ul></li><li>贪心策略II：在切分方案中，最多只应存在两个2.因为三个2总是可以替换为两个3，从而获得更大的乘积</li><li>综上所述：可推理出以下贪心策略：<ul><li>输入整数n，从其不断地切分出因子3，直至余数为0，1，2</li><li>当余数为0时，代表n是3的倍数，因此不做任何处理</li><li>当余数为2时，不继续划分，保留</li><li>当余数为1时，由于 2<em>2&gt;3</em>1，因此应将最后一个3替换为2</li></ul></li></ol><h3 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h3><ol><li>无须通过循环来切分整数，可以利用向下整除运算得到3的个数a，用取模运算得到余数b，此时有<code>n=3*a+b</code></li><li>对于n&lt;&#x3D;3的边界情况，必须拆分出一个1，乘积为<code>1*(n-1)</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> a=n/<span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//当余数为1时，3*1转化为2*2</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(b==<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//当余数为2时，不做处理</span></span><br><span class="line">      <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//当余数为0时，不做处理</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度取决于编程语言的幂运算的实现方法。</li><li>变量a和b使用常数大小的额外空间，因此空间复杂度为O(1)</li></ol><h3 id="1-4-3-正确性证明"><a href="#1-4-3-正确性证明" class="headerlink" title="1.4.3 正确性证明"></a>1.4.3 正确性证明</h3><p>使用反证法，只分析n&gt;&#x3D;3的情况</p><ol><li>所有因子&lt;&#x3D;3：假设最优切分方案中存在&gt;&#x3D;4的因子x，那么一定可以将其继续划分为2(x-2)，从而获得更大的乘积。这与假设矛盾</li><li>切分方案不包括1：假设最优切分方案中存在一个因子1，那么它一定可以合并入另外一个因子中，以获得更大的乘积。这与假设矛盾</li><li>切分方案最多包含两个2:假设最优切分方案中包含三个2，那么一定可以替换为两个3，乘积更大。这与假设矛盾</li></ol><h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><ol><li>贪心算法通常用于解决最优化问题，其原理是在每个决策阶段都做出“局部最优决策”，以期获得全局最优解</li><li>贪心算法会迭代地做出一个又一个的贪心选择，每轮都将问题转换成一个规模更小的子问题，直到问题被解决</li><li>贪心算法不仅实现简单，还具有很高的解题效率。相比于动态规划，贪心算法的时间复杂度通常更低</li><li>在零钱兑换问题中，对于某些硬币组合，贪心算法可以保证找到最优解；对于另外一些硬币组合则不然，贪心算法可能找到很差的解</li><li>适合用贪心算法求解的问题具有量大性质：贪心选择性质和最优子结构。贪心选择性质代表贪心策略的有效性</li><li>对于某些复杂问题，贪心选择性质的证明并不简单。相对来说，证伪更加容易，例如零钱兑换问题</li><li>求解贪心问题主要分为三步：问题分析，确定贪心策略，正确性证明。其中，确定贪心策略是核心步骤，正确性证明往往是难点</li><li>分数背包是在0-1背包的基础上，允许选择物品的一部分，因此可使用贪心算法求解。贪心策略的正确性可以使用反证法来证明</li><li>最大容量问题可使用穷举法求解，时间复杂度为O(n^2)。通过设计贪心策略，每轮向内移动短板，可将时间复杂度优化至O(n)</li><li>在最大切分乘积问题中，我们先后推理出两个贪心策略：&gt;&#x3D;4的整数都应该继续切分，最优切分因子为3。代码中包含幂运算，时间复杂度取决于幂运算的实现方法，通常为O(1)或O(log n)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法入门学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
